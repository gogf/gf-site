---
slug: '/docs/design/interface-generic'
title: 'Interface and Generic Design'
sidebar_position: 6
hide_title: true
---

## 1. Basic Introduction

Interface-based design is a higher level of abstraction. The design of framework components尽可能 uses interfaces instead of providing specific implementations. The greatest benefit of interface-based design is that it allows users to customize implementations to replace the underlying interface layer of components, achieving great flexibility and extensibility.

## 2. Component Interface Design

The core components of the `GoFrame` framework all adopt interface-based design. For example, the following figure shows an overview of the interface-based implementation of some components:

![](/markdown/f7c64eb343963d83adee0800a7774045.png)

Most components use `Adapter` as the name of their interface layer, set the current interface implementation through the `SetAdapter` method, and obtain the current component's interface implementation object through the `GetAdapter` method. In addition, to improve usability, components provide some default `Adapter` implementations for users to choose from. Taking the `gsession` component as an example:

![](/markdown/5b6e3ff29277e5e5bd32707d9a29bf4c.png)

The underlying interface is defined with `Storage` and provides four implementations: `File/Memory/Redis/RedisHashTable`, with the default implementation being `File`.

## 3. Interface and Generics

The extensibility of component interface design is very high, but it needs to be combined with generics to achieve more flexible usage when implemented. Taking the `gsession` component as an example again, the parameters return generics, which are then converted to the corresponding data types as needed in business use.

### Enhancing Parameter Flexibility and Simplifying Usage Complexity

Without generics, our interfaces either provide methods of various types or return using the `interface{}` type, both of which have high usage complexity. Unifying through generic data type returns makes the parameter types more flexible and greatly reduces the usage complexity.

![](/markdown/b8a2950b795cf7cb987cbfa7a305ff72.png)

Generics support conversion to various types:

![](/markdown/76fcb2211bfb4d98a88bdb9d1288b574.png)

Convert to the corresponding data types as needed by the business scenario. Type conversion uses the framework's unified type conversion component, which prioritizes type identification through assertions to ensure the efficiency of the conversion.

![](/markdown/4605ec6822024dd52fe79ea75d6497d9.png)

### Unified Usage Method and Shielding Underlying Impact

For some complex type interface scenarios, the underlying implementation of the interface may involve external storage and may also involve serialization/deserialization operations, which could change or lose data types. Using generics can shield the impact of underlying implementation through a unified usage method. For example, in the following example, regardless of how the underlying `Session` implementation changes, the upper layer uses the generic `Scan` method to convert to the target object.

![](/markdown/de4f942e624d5e30a40f7d9d087c35fc.png)

## 4. Precautions

Although the framework provides generic design, it is not recommended to widely use generics in business. The design of business layer data structures, including interfaces and business model data structures, should be accurate and definite.

