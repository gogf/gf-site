---
slug: '/docs/design/initialization'
title: 'Implicit and Explicit Initialization'
sidebar_position: 7
hide_title: true
---

We know that during program startup, there is a need to perform some "initialization" logic operations, such as: `Server` configuration, various database (`MySQL`, `Redis`, `Kafka`, etc.) configurations, business object configurations, etc. In most scenarios, we have two types of initialization methods: implicit initialization and explicit initialization.

## 1. Implicit Initialization
:::warning
Special attention: After `Golang v1.21`, the initialization execution order of `init` has changed, and it may cause issues for packages that rely on `init` to execute initialization logic. Therefore, it is not recommended to perform **complex initialization logic** in `init`; **it is recommended to implement complex module initialization logic through explicit calls**.
:::
Implicit initialization is generally executed through package initialization methods `init`. It should be noted that if there is a possibility of errors in the initialization logic, since the errors from `init` methods cannot be captured by the upper layer, the program startup is often terminated directly when initialization fails. For example:

![](/markdown/9190e5a8e2acf34a70442c6814a52327.png)

Implicit initialization often terminates the program startup directly when an error occurs.

The advantage of implicit initialization is that it does not require manual calling of initialization methods, hiding the initialization details from developers, thus reducing the mental burden on developers. However, the disadvantage is also the same; developers are unaware of the initialization details, and if an error occurs, it is difficult to quickly locate the cause of the error. Therefore, when using implicit initialization, it is often required to print out detailed errors and stack information when initialization fails to facilitate error location.

Many modules of the `GoFrame` framework adopt implicit initialization, hiding the initialization details of the modules and reducing the mental burden on developers. For example:

![](/markdown/d019031d40a93f6318a933271d63c503.png)

Modules in `GoFrame` commonly have implicit initialization design.

![](/markdown/b0b839a86595ee57f2c5a1b39c559df0.png)

Using `GoFrame` framework's `main` package implicit `imports`.

Regarding the initialization process of package `init` methods:

![](/markdown/40b3b7c2b75dcb36be348c840ca0eb3e.png)

## 2. Explicit Initialization

Explicit initialization requires developers to call specific methods to perform initialization operations at program startup, such as in the `main` or `boot` module. Generally, the initialization of basic components tends to use implicit initialization more often because users are not concerned with the initialization logic of underlying basic modules, while the initialization of business modules mostly adopts explicit initialization. For example:

![](/markdown/0124c249f03cd1f9fd78fe0970ffbda6.png)Explicit initialization executed in order within the `boot` package.

![](/markdown/8417caae0e203d44d43c6bca369b3023.png)Calling `boot.Boot()` method in the `main` package to perform initialization.

## 3. How to Choose

In business scenarios, unless it is particularly necessary, we recommend everyone to adopt **explicit initialization** to ensure better maintainability.
