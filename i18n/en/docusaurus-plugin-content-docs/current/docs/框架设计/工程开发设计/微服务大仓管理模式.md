---
slug: '/docs/design/project-mono-repo'
title: 'Microservice Monorepo Management Model'
sidebar_position: 5
hide_title: true
---

This article aims to introduce the support of the `GoFrame` framework for the microservice monorepo management model (`mono-repo`), guiding developers on how to develop code and collaborate in a monorepo management model (`mono-repo`) environment.

## 1. Prerequisites

Before starting this chapter, it is recommended to understand the basic concepts of monolithic repositories (`monolith`), microservice-multirepo management (`multi-repo`), and microservice-monorepo management (`mono-repo`), as well as their respective advantages and disadvantages.

The management constraints of code repositories are not part of the framework's responsibilities. The scaffolding of the `GoFrame` framework itself also supports two types of repository project initialization commands - monorepo (`mono-repo`) and multirepo (`monolith/multi-repo`), to meet the needs of different teams. The specific choice of code repository management model is up to the development team to choose based on their own needs, scenarios, and habits.
:::tip
To simplify and clarify the description of microservice-monorepo management (`mono-repo`), we will统一 refer to the microservice-monorepo management model as **Monorepo Management** in the following context.
:::

## 2. Monorepo Management

### 1. Division of Repository Responsibilities

As we know from the prerequisite reading, there is no silver bullet in this world; monorepos have advantages as well as disadvantages, the most obvious of which are **permission control** and **repository bloat**. To better manage the code repository and avoid the higher costs brought by these two shortcomings, we suggest minimizing the scale of microservices within the monorepo. As for which microservices need to be maintained in the repository, it should be determined based on the frequency of collaboration between services.

#### 1) When the collaboration frequency within the team is higher than the inter-team collaboration frequency

- A typical scenario is for **non-microservice architectures**, where service management responsibilities can be divided according to each business team. In this way, the team can maintain several dispersed services through a unified code repository, fully utilizing the advantages of monorepo management to improve the development and maintenance efficiency within the team.
- Another scenario is when the number of microservices in the business is not many (for example, within `50`), in which case they can also be merged into a monorepo for management. It should be noted that the number of services managed in the monorepo is not determined by the number of people in the organizational structure.

#### 2) When the collaboration frequency between multiple teams and their services is very high

When there are many microservices in the business, and the interaction and collaboration between each service are frequent, it is possible to consider merging these services into the monorepo for management, which can greatly improve collaboration efficiency. This situation mostly occurs when microservices are in the same product line, across teams but not across centers or departments. However, due to the involvement of cross-team collaboration, this has certain requirements for personnel organizational structure management and needs to be driven by managers with certain permissions.
:::tip
The management of microservices is not only about the organization of code but also about the management of personnel organizational structure.
:::

### 2. How Microservices Collaborate Under Monorepo

#### 1) Management of Code Visibility

The only thing that services can expose to each other is the interface, which is the `API`. The internal logic of each service should not be visible to the outside. In `Golang`, there is a good `internal` feature that can meet the requirements of visibility management. As shown in the monorepo code example below, the `app` directory manages several services, each of which exposes its own `api` directory for other services to directly reference (improving service collaboration efficiency), but the internal business logic is included in the `internal` directory, which is not visible (and thus not referenceable) to other services.

![](/markdown/f9028ffb7bc51e7496f1d55b79091f73.png)

#### 2) Service-to-Service Interface Invocation

Protocol files are maintained separately in each service directory. If protocol file compilation is involved, then the compiled files are also stored in their own service directories. The calling party does not need to recompile and manage the protocol files of the target service separately. Taking the interface definition of `HTTP API` as an example, the caller can directly reference the `API` interface definition of the target service: (in the following screenshot, `khaos-shark` is the caller, and `khaos-oss` is the service provider)

![](/markdown/b0035d25d52202b3f1b38d18980bf3ff.png)

The same principle applies to `RPC` interface calls between microservices: (in the following screenshot, `user-api` is the caller, and `user-rpc` is the service provider)

![](/markdown/f02efd1e4c03b3cb111cb7b9015290ee.png)

#### 3) Strict Compatibility Requirements

From the above introduction, it can be seen that through the code management of the monorepo, all services in the monorepo maintain consistent versions. Whenever the `API` of the dependent service is updated, the calling service (using the `SDK`) will also be automatically updated. This requires that the interface design of all services in the repository **must strictly ensure compatibility**, otherwise, there will be problems with inter-service calls: at best, the calling service will fail to compile and require code adjustments; at worst, it will compile successfully but run-time errors will affect the business. In addition, public references to the monorepo's basic components will also be affected by compatibility.

Key points to ensure compatible code design:

- **Do not arbitrarily delete or modify interface parameters, parameter names, parameter types, or parameter validation logic.**
- **When an interface must undergo incompatible updates, interface version numbers should be used for management (e.g., `v1, v2, v3...`).**
- **Public components should try to use stable and mature external components. If necessary custom components are required, ensure the compatibility of exposed methods.** _For example: Some very basic functions, such as `json.Marshal&Unmarshal`, some people encapsulate libraries/functions, but later people may not know about this library and may not trust this function, so they will write another one... Over time, these libraries/functions are left unmaintained._

### 3. Microservice Containerization Support Under Monorepo

#### 1) Unified Management of Image Repositories

Distributed image repositories will reduce the efficiency of service containerization management and maintenance. To facilitate unified service containerization management, it is recommended that services under the monorepo use a unified image repository. The address of the image repository is uniformly maintained in the tool configuration files under each service:

![](/markdown/424878f3a64d0cca7899c6fd13a8b9c7.png)

#### 2) Unified Compilation and Submission Instructions

The framework provides common instructions to achieve program compilation, image compilation, and image submission.

- `make build`

  Compile the program to generate binary files.

  For more information, please refer to the documentation: [Cross-compilation-build](/docs/cli/build)

- `make image`

  Compile the program and compile the image to generate a `Docker` image.

  You can specify the name of the generated image label through `make image TAG=xxx`.

  For more information, please refer to the documentation: [Image Compilation-docker](/docs/cli/docker)

- `make image.push`

  Compile the program, compile the image, and push the image to the configured image repository.

  You can specify the name of the generated image label through `make image.push TAG=xxx`.

#### 3) Unified Deployment and Debugging Instructions

The framework provides common instructions to achieve containerized deployment in `Kubernetes` clusters and integrated compilation and deployment development instructions.

- `make deploy TAG=xxx`

  Deploy the current service to the `kubernetes` cluster connected to the local `kubeconfig`, where `TAG` is used to specify the `overlays` directory under the `deploy` directory. The deployment `yaml` files are managed using the industry-standard `kustomize` tool. For more information, please refer to the documentation: [https://kubernetes.io/zh-cn/docs/tasks/manage-kubernetes-objects/kustomization/](https://kubernetes.io/zh-cn/docs/tasks/manage-kubernetes-objects/kustomization/)

  ![](/markdown/353b86069be6e3cb8834aab4aad32e84.png)

- `make image.push deploy TAG=xxx`

  This command is a development and debugging instruction, used to compile binary files, compile and push `Docker` images, deploy `Kubernetes` applications, and restart applications with one command.

### 4. Other Framework Instructions Under Monorepo



The framework provides a wealth of tool instructions for project engineering management, which often need to be executed in specific service directories, such as `./app/service-name`.

#### 1) `make cli`

  Used to upgrade the local framework `CLI` to the latest stable version.

#### 2) `make up`

  Used to upgrade the local framework to the latest community stable version.

  For more information, please refer to the documentation: [Framework Upgrade-up](/docs/cli/up)

#### 3) `make dao`

  Used to generate `DAO/Entity/DO` code files.

  For more information, please refer to the documentation: [Data Specification-gen dao](/docs/cli/gen-dao)

#### 4) `make service`

  Used to parse the `logic` directory and automatically generate internal call interfaces. This instruction is often used with automated `Watcher` file changes in `Goland IDE` for automatic generation. For more information, please refer to the official documentation.

  For more information, please refer to the documentation: [Module Specification-gen service](/docs/cli/gen-service)

#### 5) `make enums`

  Used to parse the specified code directory (default is the `api` directory) and automatically generate `enums` loading code.

  For more information, please refer to the documentation: [Enumeration Maintenance-gen enums](/docs/cli/gen-enums)

#### 6) More Instructions

For more instruction support, please refer to the framework's official website tool introduction section: [Development Tools](/docs/cli)
