---
slug: '/docs/design/project-structure'
title: 'Project Directory Design ðŸ”¥'
sidebar_position: 1
hide_title: true
---

Project directory design is the further implementation of code layering design. It is recommended that you read carefully: [Code Layering Design](/docs/design/project-layer) first.

:::tip
This is the directory design for **business projects** in the `GoFrame` framework, which is mainly inspired by the three-tier architecture but has been improved and refined to better fit engineering practices and progress.
:::

## 1. Project Directory Structure

The basic directory structure of a `GoFrame` business project is as follows (taking `Single Repo` as an example):

```html
/
â”œâ”€â”€ api
â”œâ”€â”€ hack
â”œâ”€â”€ internal
â”‚   â”œâ”€â”€ cmd
â”‚   â”œâ”€â”€ consts
â”‚   â”œâ”€â”€ controller
â”‚   â”œâ”€â”€ dao
â”‚   â”œâ”€â”€ logic
â”‚   â”œâ”€â”€ model
â”‚   |   â”œâ”€â”€ do
â”‚   â”‚   â””â”€â”€ entity
â”‚   â””â”€â”€ service
â”œâ”€â”€ manifest
â”œâ”€â”€ resource
â”œâ”€â”€ utility
â”œâ”€â”€ go.mod
â””â”€â”€ main.go
```

:::info
**ðŸ”¥ Important Note ðŸ”¥**: The framework's project directory adopts a **universal design** to meet the needs of business projects of different complexities, but in actual projects, you can **appropriately add or reduce the default directories** according to the project's needs. For example, if there is no need for `i18n/template/protobuf`, **simply delete the corresponding directories**. Also, for very simple business projects (such as verification/demo projects), if you do not consider using the rigorous `dao/logic/model` directories and features, then **simply delete the corresponding directories**, and you can directly implement business logic in the `controller`. **Everything can be flexibly chosen and assembled by developers**!
:::

| Directory/File Name | Description | Details |
| --- | --- | --- |
| `api` | External Interface | Defines the input/output data structures for services provided externally. Often exists in the form of `api/xxx/v1...` due to version management needs. |
| `hack` | Utility Scripts | Stores project development tools, scripts, etc. For example, configurations for `CLI` tools, various `shell/bat` scripts, and other files. |
| `internal` | Internal Logic | Directory for storing business logic. Uses the `Golang internal` feature to hide visibility from the outside. |
| `Â  - cmd` | Entry Command | Command-line management directory. Can manage and maintain multiple command lines. |
| `Â  - consts` | Constant Definitions | All constant definitions for the project. |
| `Â  - controller` | Interface Handling | The entry/layer for receiving/parsing user input parameters. |
| `Â  - dao` | Data Access | Data Access Object, an abstract layer for interacting with the underlying database, containing only basic `CURD` methods. |
| `Â  - logic` | Business Encapsulation | Encapsulation and management of business logic, where specific business logic is implemented and encapsulated. Often the most complex part of the project. |
| `Â  - model` | Structural Model | Data structure management module, managing data entity objects and definitions for input and output data structures. |
| `Â  Â  - do` | Domain Object | Used for business model and instance model conversion in `dao` data operations, maintained by tools, and cannot be modified by users. |
| `Â  Â  - entity` | Data Model | Data models represent a one-to-one relationship with data collections, maintained by tools, and cannot be modified by users. |
| `Â  - service` | Business Interface | Interface definition layer for decoupling business modules. Specific interface implementations are injected in the `logic`. |
| `manifest` | Delivery Manifest | Contains files for program compilation, deployment, operation, and configuration. Common contents are as follows: |
| `Â  - config` | Configuration Management | Directory for configuration files. |
| `Â  - docker` | Image Files | Docker image-related dependency files, script files, etc. |
| `Â  - deploy` | Deployment Files | Deployment-related files. Provides `Yaml` templates for `Kubernetes` cluster deployment by default, managed by `kustomize`. |
| `Â  - protobuf` | Protocol Files | `Protobuf` protocol definition files used for `GRPC` protocols, compiled to generate `go` files in the `api` directory. |
| `resource` | Static Resources | Static resource files. These files can often be injected into the release files through resource packaging/mirror compilation. |
| `go.mod` | Dependency Management | Dependency description file using `Go Module` package management. |
| `main.go` | Entry File | The entry file of the program. |

### External Interfaces

External interfaces consist of two parts: interface definition (`api`) + interface implementation (`controller`).

The responsibility of service interfaces is similar to the `UI` presentation layer in the three-tier architecture design, responsible for receiving and responding to client input and output, including filtering, converting, and validating input parameters, maintaining output data structures, and calling `service` to implement business logic processing.

#### Interface Definition - `api`

The `api` package is used for defining the input and output data structures agreed upon with clients, often strongly bound to specific business scenarios.

#### Interface Implementation - `controller`

The `controller` is used to receive inputs from `api`, and can implement business logic directly within the `controller`, or call one or more `service` packages to implement business logic, encapsulating the execution results as agreed `api` output data structures.

### Business Implementation

Business implementation consists of two parts: business interface (`service`) + business encapsulation (`logic`).

The responsibility of business implementation is similar to the `BLL` business logic layer in the three-tier architecture design, responsible for the implementation and encapsulation of specific business logic.

:::info
In the subsequent chapter introductions, we will uniformly refer to business implementation as `service`, please note that it actually includes two parts.
:::

#### Business Interface - `service`

The `service` package is used to decouple the calls between business modules. Business modules often do not directly call corresponding business module resources to implement business logic, but instead call `service` interfaces. The `service` layer only has interface definitions, and the specific interface implementations are injected into each business module.

#### Business Encapsulation - `logic`

The `logic` package is responsible for the implementation and encapsulation of specific business logic. Code at various levels of the project does not directly call the business modules of the `logic` layer, but calls through the `service` interface layer.

### Structural Model

The responsibility of the `model` package is similar to the `Model` model definition layer in the three-tier architecture. The model definition code layer only includes globally public data structure definitions, often without method definitions.

It is important to note that the `model` here is not only responsible for maintaining the structure definition of data entity objects (`entity`) but also includes all input/output data structure definitions, which are commonly referenced by `api/dao/service`. The advantage of doing this is not only to unify the management of public data structure definitions but also to fully reuse data structures in the same business domain, reducing code redundancy.

#### Data Model - `entity`

Program data structure definitions bound to data collections, usually corresponding one-to-one with data tables.

#### Business Model - `model`

General data structure definitions related to business, including most method input and output definitions.

### Data Access - `dao`

The responsibility of the `dao` package is similar to the `DAL` data access layer in the three-tier architecture, responsible for all data access convergence.

![](/markdown/1e1bb98778823124dc5bf35c57e8f4cb.png)

Three-tier architecture design and framework code layer mapping relationship

## 2. Request Layered Flow

![](/markdown/df7dd9a93cb541a8ca126b5b051002ab.png)

### cmd

The `cmd` layer is responsible for guiding the program startup, with significant work including initializing logic, registering route objects, starting the `server` to listen, and blocking the program until the `server` exits.

### api

The upper `server` service receives client requests, converts them into `Req` reception objects defined in `api`, performs type conversion of request parameters to `Req` object attributes, performs basic validation binding in the `Req` object, and hands over the `Req` request object to the `controller` layer.

### controller

The `controller` layer is responsible for receiving the `Req` request object and performing some business logic validation. It can implement business logic directly within the `controller`, or call one or more `service` to implement business logic, encapsulating the execution results as agreed `Res` data structure objects and returning them.

### model

The `model` layer manages all business models, and the `Input/Output` input and output data structures of `service` resources are maintained by the `model` layer.

### service

`service` is the interface layer, used to decouple business modules. `service` does not have specific business logic implementation; the specific business implementation relies on the `logic` layer injection.

### logic

The business logic of the `logic` layer needs to implement data operations by calling `dao`, passing `do` data structure objects for query conditions and input data. After `dao` execution, the data results are returned to the `service` layer through the `Entity` data model.

### dao

The `dao` layer interacts with the underlying real database through the framework's `ORM` abstract layer component.

## 3. Frequently Asked Questions

### Does the framework support the common `MVC` development model?

**Absolutely!**

As a modularly designed basic development framework, `GoFrame` does not limit code design patterns, and the framework provides a very powerful template engine core component, which can be quickly used for template rendering development common in the `MVC` model. Compared to the `MVC` development model, in complex business scenarios, we recommend using the three-tier architecture design pattern more.

### How to maintain duplicate data structures when `api` and `model` layers exist

The data structures defined in `api` are **for external use**, bound to specific business scenarios (such as specific page interaction logic, single interface functionality), and the data structures are determined by the upper presentation layer in advance; the data structures defined in `model` are **for internal service use**, which can only be defined during interface implementation and abstraction, and the data structures in `model` can be modified at will without affecting the compatibility of the external `api` interface.

**Note that the data structures in `model` should not be directly exposed for external use**, and in the framework's engineering design, the `model` directory is deliberately placed under the `internal` directory. Also, do not define **alias types** for the data structures in `model` in the `api` layer for external access. Once the data structures in `model` are applied to the `api` layer, any modification to the internal `model` data structures will directly affect the compatibility of the `api` interface.

**If there are duplicate data structures (or even constants, enumeration types) between the two, it is recommended to define the data structures in the `api` layer**. Internal service logic can directly access the data structures in the `api` layer. The data structures in the `model` layer can also directly reference the data structures in the `api` layer, but not vice versa.

Let's look at an example for a better understanding:

![](/markdown/4d95fb64e06bb72a5456fb684704b891.png)![](/markdown/36794a54e02c2be6c0edbcf07bb8821a.png)

### How to clearly define and manage the layered responsibilities of `service` and `controller`

The `controller` layer handles `Req/Res` external interface requests. It is responsible for receiving and validating request parameters, and can implement business processing logic directly within the `controller`, or call **one or more** `service` to implement business logic processing, encapsulating the execution results as agreed `api` output data structures and returning them. The `service` layer handles `Input/Output` internal method calls. It is responsible for encapsulating **reusable** internal business logic, and the granularity of the encapsulated methods is often finer.

**Generally speaking, when developing interfaces, you only need to write the interface implementation business logic in the `controller` layer. When there is duplicate code logic, abstract and precipitate it from the logic of each `controller` interface implementation to the `service` layer**. If you pass the `Req` object directly from the `controller` layer to the `service`, and the `service` directly returns the `Res` data structure object, this method is also coupled with the external interface and only serves the external interface, making it difficult to reuse, thus increasing the technical debt cost.

### How to clearly define and manage the layered responsibilities of `service` and `dao`

This is a very classic question.

**Pain Point:**

Commonly, developers encapsulate **data-related business logic implementation** into the `dao` code layer, and the `service` code layer is just a simple `dao` call. Doing so will make the `dao` layer, which is originally responsible for maintaining data, increasingly heavy, while the business logic `service` layer code appears lighter. Developers are confused, where should I put the business logic code, in `dao` or `service`?

Business logic is actually most of the time about data `CURD` processing, doing so will cause almost all business logic to gradually precipitate in the `dao` layer, and changes in business logic will frequently modify the `dao` layer code. For example: data query requirements, in the early stage, may be simple logic, and the current code in `dao` seems fine, but as the query requirements increase or change and become more complex, it will inevitably continue to maintain and modify the original `dao` code, and the `service` code may also be updated at the same time. The original responsibilities and coupling between the business logic code responsibilities in the `service` layer and the `dao` layer code are unclear, and the coupling is heavy. Originally, the need to modify only the `service` code has become a need to modify both `service` + `dao`, greatly increasing the development and maintenance costs of the project in the later stages.

**Recommendation:**

Our recommendation. The code in the `dao` layer should try to ensure commonality, and in most scenarios, there is no need to add extra methods, just use some common chain operation methods to piece together can meet the requirements. Business logic, including logic that seems to be just simple data operations, should be encapsulated in `service`. `service` includes multiple business modules, each managing its own `dao` object. Ideally, `service` communicates data by calling methods between `service`, rather than arbitrarily calling the `dao` object of other `service` modules.

### Why use the `internal` directory to include business code

The `internal` directory is a unique feature of the `Golang` language, preventing other directories at the same level from referencing the content under it. The purpose of having this directory in business projects is to avoid unrestricted and arbitrary access between multiple sub-projects (especially in large warehouse management modes), leading to inevitable coupling between different packages of multiple projects.
