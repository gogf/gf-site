---
slug: '/docs/design/project-layer'
title: 'Code Layering Design'
sidebar_position: 0
hide_title: true
---
:::tip
The significance of code layering lies in further decoupling the program logic, designing the data flow and dependencies between layers as unidirectional links, which makes the system architecture more flexible and scalable.
:::

## Introduction

`GoFrame`, as a comprehensive engineering-based development framework, has its unique design philosophy. In this section, we will introduce its code layering design. In the pattern of server-side business code layering, we commonly see the `MVC` design pattern and the three-tier architecture design pattern (`3-Tier Architecture`).

## MVC Design Pattern

Let's review the classic `MVC` design pattern.

![MVC Design Pattern](/markdown/d90094b0f7ec2edb2220ffc0204a1c2d.png)

**Figure 1. MVC Design Pattern**

### Brief Introduction

`M` stands for Model, which represents the encapsulation of business rules. Among the three components of `MVC`, the model has the most processing tasks. The data returned by the model is neutral and format-independent, allowing a single model to provide data for multiple views. Since the code applied to the model only needs to be written once and can be reused by multiple views, it reduces code redundancy.

`V` stands for View, which is the interface that users see and interact with. For example, a web page interface composed of `HTML` elements or a client interface of a software. One of the benefits of `MVC` is that it can handle many different views for an application. No real processing occurs in the view; it is merely a way to output data and allow user manipulation.

`C` stands for Controller, which accepts user input and calls the model and view to fulfill user requirements. The controller itself does not output anything or perform any processing. It only receives requests and decides which model component to call to handle the request, then determines which view to use to display the returned data.

This design pattern is relatively simple and is more suitable for business scenarios that require server-side rendering of pages, and it is also friendly for `SEO`. However, with the rise of the `MVVM` development model and the rapid development of front-end technologies, especially the emergence of front-end development frameworks like `Vue`, `React`, `Angular`, the use of the server-side `MVC` design pattern has become less common.

### Pain Points

For business scenarios with not particularly complex logic, `MVC` can still handle them well. However, as business logic becomes large and complex, the maintenance cost of `MVC` pattern projects becomes increasingly apparent. Especially with the development of microservices architecture in internet projects, the `MVC` design pattern has become increasingly dispensable in most internet project developments. The main reasons are:

- The further decoupling of view presentation and data operation methods, especially with the development of mobile terminals and the front-end `MVVM` framework, we no longer need server-side rendering of `View` in most scenarios.
- The code layering design pattern of `MVC` is actually quite coarse-grained:
  - The `Model` layer maintains data and encapsulates business logic. As business logic becomes more complex, this layer's functional logic becomes increasingly bloated and difficult to maintain.
  - For team management, the responsibilities of `Controller` and `Model` are vague, and there are higher requirements for developers to write good code. The concept seems simple but is difficult to adapt to industrial software production.

## 3-Tier Architecture

The `GoFrame` framework recommends the three-tier architecture design pattern (`3-Tier Architecture`), but it has made certain improvements to this structural design pattern in its specific implementation. The three-tier architecture design can well reflect the software design concept of "high cohesion, low coupling."

![](/markdown/8b93ee429f05737e03dfc58bdfe04905.png)

**Figure 2. Three-Tier Architecture Design Pattern**

The traditional three-tier architecture design, as shown above, divides project code into three layers, each with its own responsibility boundaries. However, in most scenarios, we often see the following layering structure, which further extracts the data structure model for unified maintenance.

![Three-Tier Architecture Design Pattern](/markdown/fe9aea78ab05dc6db3b34d021a05ee76.png)

**Figure 3. Common Three-Tier Architecture Design Model**

### Presentation Layer - `UI`

`User Interface` is located at the top layer of the three-tier architecture and is in direct contact with users, mainly `WEB` pages in `B/S`, or `API` interfaces. The main function of the presentation layer is to achieve the input and output of system data. In this process, data can be transmitted to the `BLL` system for data processing without the need for logical judgment operations, and the processing results will be fed back to the presentation layer. In other words, the presentation layer implements user interface/`API` interface functions, conveys and feeds back user requirements, and uses `BLL` or `Model` for debugging to ensure a good user experience.

### Business Logic Layer - `BLL`

The function of `Business Logic Layer` is to make logical judgments and perform operations on specific issues. After receiving user instructions from the presentation layer `UI`, it connects to the data access layer `DAL`. The business logic layer is located between the presentation layer and the data layer in the three-tier architecture and serves as a bridge between the presentation layer and the data layer, implementing data connections and command transmission between the three layers. It can logically process received data, implement data CRUD functions, and feedback the processing results to the presentation layer `UI`, achieving software functionality.

### Data Access Layer - `DAL`

`Data Access Layer` is the main manipulation system of the database, implementing data CRUD operations and feeding back the operation results to the business logic layer `BLL`. In actual operation, the data access layer has no logical judgment capability. To achieve rigorous code writing and improve code readability, software developers generally encapsulate common data capabilities in this layer (for example, through `ORM` components) to ensure the data processing functions of the data access layer `DAL`.

### Model Definition Layer - `Model`

Model definition is also commonly represented by `Entity` entity objects, mainly used for mapping database tables. In the actual development of information system software, object instances are established to represent relational database tables in an object entity form, assisting in the control and operation execution of various system functions in software development. Establishing an entity class library to achieve parameter transmission between various structural layers and improving code readability. Essentially, the entity class library mainly serves the presentation layer, business logic layer, and data access layer, transmitting data parameters between the three layers and strengthening the simplicity of data representation.

It is important to distinguish that the `Model` here and the `Model` in the `MVC` design pattern, although they share the same name, are vastly different in responsibilities.

### Three-Tier Architecture Design and `MVC`

Since `MVC` is also a three-layer structure, some students may also generally categorize `MVC` within the three-tier architecture design, which seems to be fine in a literal sense. However, there are still certain differences between the two.

![](/markdown/2c6cfc087687cca60b1f4d23b78705c4.png)

**Figure 4. Three-Tier Architecture Design and MVC**

It can be seen that in the three-tier architecture design, the `UI` presentation layer is equivalent to the `View` and `Controller` layer of `MVC`. Originally, the logic in these two layers of `MVC` should be relatively "lightweight," so it is understandable to merge them into one layer for unified management. An important point is that the original `Model` in `MVC` is divided into `BLL` and `DAL`, that is, separating business logic from data access, further decoupling the originally bloated `Model`, which is conducive to better project maintenance.

:::tip
The evolution of software architecture, especially the evolution of internet software architecture, is essentially the process of continuously decoupling business logic.
:::

## Further Understanding

The concept of code layering is the most basic entry into engineering design. We need to implement the layering concept. For details, please refer to: [Project Directory Design ðŸ”¥](/docs/design/project-structure)
