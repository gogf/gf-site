---
slug: '/quick/scaffold-api-controller'
title: 'Step4 - 生成controller代码'
hide_title: true
sidebar_position: 4
keywords: [GoFrame,API代码生成,控制器代码,生成控制器,代码自动生成,接口实现,GoFrame框架,路由对象管理,接口路由实现,代码模板]
description: '根据API定义生成控制器代码，包括API接口文件、路由对象管理及路由实现代码等内容，利用GoFrame框架的命令工具快速生成相关代码模板，确保接口的完整实现，并展示如何通过一个个文件实现具体业务逻辑。'
---


## 根据`api`生成代码

当`api`定义完成后，我们通过`make ctrl`命令（或者`gf gen ctrl`）生成控制器代码。

```text
$ make ctrl
generated: /Users/john/Temp/demo/api/user/user.go
generated: /Users/john/Temp/demo/internal/controller/user/user.go
generated: /Users/john/Temp/demo/internal/controller/user/user_new.go
generated: /Users/john/Temp/demo/internal/controller/user/user_v1_create.go
generated: /Users/john/Temp/demo/internal/controller/user/user_v1_update.go
generated: /Users/john/Temp/demo/internal/controller/user/user_v1_delete.go
generated: /Users/john/Temp/demo/internal/controller/user/user_v1_get_one.go
generated: /Users/john/Temp/demo/internal/controller/user/user_v1_get_list.go
done!
```

![goframe api interface controller](QQ_1731678085194.png)

生成的代码主要包含`3`类文件。

## `api`接口抽象文件

定义了`api interface`，用于保证控制器实现的接口完整性，避免`controller`缺失部分接口实现的问题。由于`GoFrame`是一款严谨的开发框架，这种细节控制得比较好，至于该特性开发者使用与否，可以根据自身场景和需要来选择。

```text
/Users/john/Temp/demo/api/user/user.go
```

该文件由开发工具维护，开发者无需关心。

内容如下：
```go title="api/user/user.go"
// =================================================================================
// Code generated and maintained by GoFrame CLI tool. DO NOT EDIT.
// =================================================================================

package user

import (
    "context"

    "demo/api/user/v1"
)

type IUserV1 interface {
    Create(ctx context.Context, req *v1.CreateReq) (res *v1.CreateRes, err error)
    Update(ctx context.Context, req *v1.UpdateReq) (res *v1.UpdateRes, err error)
    Delete(ctx context.Context, req *v1.DeleteReq) (res *v1.DeleteRes, err error)
    GetOne(ctx context.Context, req *v1.GetOneReq) (res *v1.GetOneRes, err error)
    GetList(ctx context.Context, req *v1.GetListReq) (res *v1.GetListRes, err error)
}
```

## `controller`路由对象管理

用于管理控制器的初始化，以及一些控制内部使用的数据结构、常量定义。

```text
generated: /Users/john/Temp/demo/internal/controller/user/user.go
generated: /Users/john/Temp/demo/internal/controller/user/user_new.go
```

其中`internal/controller/user/user.go`是一个空的源码文件，可用于定义一些控制器内部使用的数据结构、常量等内容。
```go title="internal/controller/user/user.go"
// =================================================================================
// This is auto-generated by GoFrame CLI tool only once. Fill this file as you wish.
// =================================================================================

package user

```

另一个`internal/controller/user/user_new.go`文件是自动生成的路由对象创建文件。
```go title="internal/controller/user/user_new.go"
// =================================================================================
// This is auto-generated by GoFrame CLI tool only once. Fill this file as you wish.
// =================================================================================

package user

import (
    "demo/api/user"
)

type ControllerV1 struct{}

func NewV1() user.IUserV1 {
    return &ControllerV1{}
}
```
这两个文件都只会生成一次，随后开发者可以随意修改、扩展。

:::tip
如果后续我们需要定义`v2`接口，`make ctrl`命令会类似生成`type ControllerV2 struct{}`结构体定义，以及`func NewV2() user.IUserV2`初始化方法。
:::


## `controller`路由实现代码

用于具体的`api`接口实现的代码文件。默认情况下，会按照一个`api`接口一个源码文件的形式生成代码。当然，也可以控制按照`api`文件定义的接口聚合生成到对应的一个源码文件中。具体的命令介绍及配置请参考章节 [接口规范-gen ctrl](../../../docs/开发工具/代码生成-gen/接口规范-gen%20ctrl.md)。

```text
generated: /Users/john/Temp/demo/internal/controller/user/user_v1_create.go
generated: /Users/john/Temp/demo/internal/controller/user/user_v1_update.go
generated: /Users/john/Temp/demo/internal/controller/user/user_v1_delete.go
generated: /Users/john/Temp/demo/internal/controller/user/user_v1_get_one.go
generated: /Users/john/Temp/demo/internal/controller/user/user_v1_get_list.go
```

我们打开一个文件查看生成的代码模板：

```go title="internal/controller/user/user_v1_create.go"
package user

import (
    "context"

    "github.com/gogf/gf/v2/errors/gcode"
    "github.com/gogf/gf/v2/errors/gerror"

    "demo/api/user/v1"
)

func (c *ControllerV1) Create(ctx context.Context, req *v1.CreateReq) (res *v1.CreateRes, err error) {
    return nil, gerror.NewCode(gcode.CodeNotImplemented)
}
```
可以看到，这只是我们定义的创建接口的实现模板，我们完善这个路由函数的具体业务逻辑即可。

## 学习小结

本章节的示例源码：https://github.com/gogf/quick-demo/tree/main/internal/controller/user

`GoFrame`脚手架工具，帮助我们将一切与业务逻辑无关的代码都生成好了，我们只需要关注业务逻辑实现即可。并且，这些自动生成的代码文件，除了开发者可以扩展的个别代码文件，大部分代码文件都完全由工具自动维护，我们也无需关心其未来的维护。

是的，`GoFrame`脚手架工具的目标，就是让开发者可以将精力聚焦于业务逻辑本身，而业务逻辑以外的工作，都交给开发框架和脚手架工具来完成。

这样的开发方式简直太方便了，不要太舒爽！你以为这就是全部了吗？当然不是，在快速开始章节我们只会介绍部分入门级功能。当你深入地接触她，你会发现她更多的好、她的善解人意。

下一步，我们将完成接口的业务逻辑实现，感受下`GoFrame`数据库`ORM`组件的魅力。