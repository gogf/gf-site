"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["73672"],{358190:function(e,n,o){o.r(n),o.d(n,{metadata:()=>t,contentTitle:()=>s,default:()=>h,assets:()=>a,toc:()=>l,frontMatter:()=>r});var t=JSON.parse('{"id":"docs/\u7EC4\u4EF6\u5217\u8868/\u7F51\u7EDC\u7EC4\u4EF6/TCP\u7EC4\u4EF6/TCP\u7EC4\u4EF6-\u8FDE\u63A5\u6C60\u7279\u6027","title":"TCP - Connection Pool","description":"The connection pool feature in the gtcp module of the GoFrame framework, implemented via gtcp.PoolConn, has a fixed lifespan of 600 seconds, with a reconnect mechanism upon data transmission. It is suitable for scenarios with frequent short connection operations and high connection concurrency. The article provides two examples demonstrating the basic use of the connection pool and the reconnect mechanism, helping users deeply understand the practical application of connection pool in network programming.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u7EC4\u4EF6\u5217\u8868/\u7F51\u7EDC\u7EC4\u4EF6/TCP\u7EC4\u4EF6/TCP\u7EC4\u4EF6-\u8FDE\u63A5\u6C60\u7279\u6027.md","sourceDirName":"docs/\u7EC4\u4EF6\u5217\u8868/\u7F51\u7EDC\u7EC4\u4EF6/TCP\u7EC4\u4EF6","slug":"/docs/components/network-gtcp-connection-pool","permalink":"/en/docs/components/network-gtcp-connection-pool","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u7EC4\u4EF6\u5217\u8868/\u7F51\u7EDC\u7EC4\u4EF6/TCP\u7EC4\u4EF6/TCP\u7EC4\u4EF6-\u8FDE\u63A5\u6C60\u7279\u6027.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732443619000,"sidebarPosition":3,"frontMatter":{"slug":"/docs/components/network-gtcp-connection-pool","title":"TCP - Connection Pool","sidebar_position":3,"hide_title":true,"keywords":["GoFrame","GoFrame Framework","TCP Connection Pool","gtcp Module","Connection Pool Feature","Short Connection Operations","High Concurrency","Reconnect","Data Transmission","Example Program"],"description":"The connection pool feature in the gtcp module of the GoFrame framework, implemented via gtcp.PoolConn, has a fixed lifespan of 600 seconds, with a reconnect mechanism upon data transmission. It is suitable for scenarios with frequent short connection operations and high connection concurrency. The article provides two examples demonstrating the basic use of the connection pool and the reconnect mechanism, helping users deeply understand the practical application of connection pool in network programming."},"sidebar":"mainSidebar","previous":{"title":"TCP - TLS","permalink":"/en/docs/components/network-gtcp-tls"},"next":{"title":"UDP","permalink":"/en/docs/components/network-gudp"}}'),i=o("785893"),c=o("250065");let r={slug:"/docs/components/network-gtcp-connection-pool",title:"TCP - Connection Pool",sidebar_position:3,hide_title:!0,keywords:["GoFrame","GoFrame Framework","TCP Connection Pool","gtcp Module","Connection Pool Feature","Short Connection Operations","High Concurrency","Reconnect","Data Transmission","Example Program"],description:"The connection pool feature in the gtcp module of the GoFrame framework, implemented via gtcp.PoolConn, has a fixed lifespan of 600 seconds, with a reconnect mechanism upon data transmission. It is suitable for scenarios with frequent short connection operations and high connection concurrency. The article provides two examples demonstrating the basic use of the connection pool and the reconnect mechanism, helping users deeply understand the practical application of connection pool in network programming."},s=void 0,a={},l=[{value:"Example 1, Basic Usage",id:"example-1-basic-usage",level:2},{value:"Example 2, Connection Disconnection Scenario",id:"example-2-connection-disconnection-scenario",level:2}];function d(e){let n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,c.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"gtcp"})," module offers a connection pool feature, implemented by the ",(0,i.jsx)(n.code,{children:"gtcp.PoolConn"})," object, where the connection pool's cached fixed lifespan is 600 seconds and internally implements a reconnect mechanism during data transmission. The connection pool is particularly suitable for scenarios involving frequent short connection operations and high connection concurrency. Next, we'll demonstrate the capabilities of the connection pool using two examples."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'import "github.com/gogf/gf/v2/net/gtcp"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"API Documentation:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://pkg.go.dev/github.com/gogf/gf/v2/net/gtcp",children:"https://pkg.go.dev/github.com/gogf/gf/v2/net/gtcp"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"type PoolConn\n    func NewPoolConn(addr string, timeout ...int) (*PoolConn, error)\n    func (c *PoolConn) Close() error\n    func (c *PoolConn) Recv(length int, retry ...Retry) ([]byte, error)\n    func (c *PoolConn) RecvLine(retry ...Retry) ([]byte, error)\n    func (c *PoolConn) RecvPkg(option ...PkgOption) ([]byte, error)\n    func (c *PoolConn) RecvPkgWithTimeout(timeout time.Duration, option ...PkgOption) ([]byte, error)\n    func (c *PoolConn) RecvWithTimeout(length int, timeout time.Duration, retry ...Retry) (data []byte, err error)\n    func (c *PoolConn) Send(data []byte, retry ...Retry) error\n    func (c *PoolConn) SendPkg(data []byte, option ...PkgOption) (err error)\n    func (c *PoolConn) SendPkgWithTimeout(data []byte, timeout time.Duration, option ...PkgOption) error\n    func (c *PoolConn) SendRecv(data []byte, receive int, retry ...Retry) ([]byte, error)\n    func (c *PoolConn) SendRecvPkg(data []byte, option ...PkgOption) ([]byte, error)\n    func (c *PoolConn) SendRecvPkgWithTimeout(data []byte, timeout time.Duration, option ...PkgOption) ([]byte, error)\n    func (c *PoolConn) SendRecvWithTimeout(data []byte, receive int, timeout time.Duration, retry ...Retry) ([]byte, error)\n    func (c *PoolConn) SendWithTimeout(data []byte, timeout time.Duration, retry ...Retry) error\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since ",(0,i.jsx)(n.code,{children:"gtcp.PoolConn"})," inherits from ",(0,i.jsx)(n.code,{children:"gtcp.Conn"}),", methods of ",(0,i.jsx)(n.code,{children:"gtcp.Conn"})," can also be used."]}),"\n",(0,i.jsx)(n.h2,{id:"example-1-basic-usage",children:"Example 1, Basic Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "time"\n    "github.com/gogf/gf/v2/net/gtcp"\n    "github.com/gogf/gf/v2/os/glog"\n    "github.com/gogf/gf/v2/os/gtime"\n)\n\nfunc main() {\n    // Server\n    go gtcp.NewServer("127.0.0.1:8999", func(conn *gtcp.Conn) {\n        defer conn.Close()\n        for {\n            data, err := conn.Recv(-1)\n            if len(data) > 0 {\n                if err := conn.Send(append([]byte("> "), data...)); err != nil {\n                    fmt.Println(err)\n                }\n            }\n            if err != nil {\n                break\n            }\n        }\n    }).Run()\n\n    time.Sleep(time.Second)\n\n    // Client\n    for {\n       if conn, err := gtcp.NewPoolConn("127.0.0.1:8999"); err == nil {\n           if b, err := conn.SendRecv([]byte(gtime.Datetime()), -1); err == nil {\n               fmt.Println(string(b), conn.LocalAddr(), conn.RemoteAddr())\n           } else {\n               fmt.Println(err)\n           }\n           conn.Close()\n       } else {\n           glog.Error(err)\n       }\n       time.Sleep(time.Second)\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this example, the Server runs asynchronously using a new goroutine, while the Client runs on the main goroutine. The Server is an echo server, while the Client sends the current time to the Server every second, after which it's echoed back by the Server, and the connection port information of both sides is printed on the Client side."}),"\n",(0,i.jsx)(n.p,{children:"After execution, the output is as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> 2018-07-11 23:29:54 127.0.0.1:55876 127.0.0.1:8999\n> 2018-07-11 23:29:55 127.0.0.1:55876 127.0.0.1:8999\n> 2018-07-11 23:29:56 127.0.0.1:55876 127.0.0.1:8999\n> 2018-07-11 23:29:57 127.0.0.1:55876 127.0.0.1:8999\n> 2018-07-11 23:29:58 127.0.0.1:55876 127.0.0.1:8999\n...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can see that the Client's port remains unchanged, and each time you get the same ",(0,i.jsx)(n.code,{children:"gtcp.Conn"})," object through ",(0,i.jsx)(n.code,{children:'gtcp.NewConn("127.0.0.1:8999")'}),". Additionally, each time ",(0,i.jsx)(n.code,{children:"conn.Close()"})," does not truly close the connection but rather returns the object to the pool for reuse."]}),"\n",(0,i.jsx)(n.h2,{id:"example-2-connection-disconnection-scenario",children:"Example 2, Connection Disconnection Scenario"}),"\n",(0,i.jsx)(n.p,{children:"This example demonstrates how to deal with invalid connection objects when the server side closes the connection."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "time"\n    "github.com/gogf/gf/v2/net/gtcp"\n    "github.com/gogf/gf/v2/os/glog"\n    "github.com/gogf/gf/v2/os/gtime"\n)\n\nfunc main() {\n    // Server\n    go gtcp.NewServer("127.0.0.1:8999", func(conn *gtcp.Conn) {\n        defer conn.Close()\n        for {\n            data, err := conn.Recv(-1)\n            if len(data) > 0 {\n                if err := conn.Send(append([]byte("> "), data...)); err != nil {\n                    fmt.Println(err)\n                }\n            }\n            if err != nil {\n                break\n            }\n            return\n        }\n    }).Run()\n\n    time.Sleep(time.Second)\n\n    // Client\n    for {\n       if conn, err := gtcp.NewPoolConn("127.0.0.1:8999"); err == nil {\n           if b, err := conn.SendRecv([]byte(gtime.Datetime()), -1); err == nil {\n               fmt.Println(string(b), conn.LocalAddr(), conn.RemoteAddr())\n           } else {\n               fmt.Println(err)\n           }\n           conn.Close()\n       } else {\n           glog.Error(err)\n       }\n       time.Sleep(time.Second)\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"After execution, the output is as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> 2018-07-20 12:56:15 127.0.0.1:59368 127.0.0.1:8999\nEOF\n> 2018-07-20 12:56:17 127.0.0.1:59376 127.0.0.1:8999\nEOF\n> 2018-07-20 12:56:19 127.0.0.1:59378 127.0.0.1:8999\nEOF\n...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, the Server closes the connection after processing each request. The Client, after sending the first request, due to the IO reuse feature of the connection pool, will obtain the same connection object for the next request. As the Server connection has been actively closed, the second request write succeeds (actually hasn't been successfully sent to the Server, needing another read operation to detect the link error), but the read fails (",(0,i.jsx)(n.code,{children:"EOF"})," indicates the target connection is closed). Therefore, at this point, when the Client executes ",(0,i.jsx)(n.code,{children:"Close"}),", it will destroy the connection operation object instead of further reusing it. The next time it gets a connection object through ",(0,i.jsx)(n.code,{children:"gtcp.NewPoolConn"}),", the Client will establish a new connection with the Server for data communication. So you see, the Client's port is constantly changing because the ",(0,i.jsx)(n.code,{children:"gtcp.Conn"})," object is a new connection object, and the previous connection object has been destroyed."]}),"\n",(0,i.jsxs)(n.p,{children:["The IO reuse of connection objects involves very subtle changes in connection states. Since point-to-point network communication itself is a complex environment, the state of connection objects may change passively at any time. Therefore, when using the gtcp connection pool feature, it is crucial to pay attention to the reconstruction mechanism of the connection object when a communication error occurs. As soon as an error occurs, immediately discard (",(0,i.jsx)(n.code,{children:"Close"}),") the object (",(0,i.jsx)(n.code,{children:"gtcp.PoolConn"}),") and rebuild (",(0,i.jsx)(n.code,{children:"gtcp.NewPoolConn"}),")."]})]})}function h(e={}){let{wrapper:n}={...(0,c.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},250065:function(e,n,o){o.d(n,{Z:function(){return s},a:function(){return r}});var t=o(667294);let i={},c=t.createContext(i);function r(e){let n=t.useContext(c);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);