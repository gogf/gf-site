"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["1009"],{443438:function(e,n,t){t.r(n),t.d(n,{metadata:()=>r,contentTitle:()=>s,default:()=>h,assets:()=>c,toc:()=>d,frontMatter:()=>o});var r=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u4E8B\u52A1\u5904\u7406","title":"ORM Model - Transaction","description":"Using transaction handling in the GoFrame framework for ORM chaining methods. Through the Transaction and TX interfaces, transactional operations on the database can be achieved to ensure data consistency and reliability. Provides a detailed explanation of using the TX interface to create Model objects and the commit and rollback mechanisms in transaction handling.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u4E8B\u52A1\u5904\u7406.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C","slug":"/docs/core/gdb-chaining-transaction","permalink":"/en/docs/core/gdb-chaining-transaction","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u4E8B\u52A1\u5904\u7406.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732541616000,"sidebarPosition":8,"frontMatter":{"slug":"/docs/core/gdb-chaining-transaction","title":"ORM Model - Transaction","sidebar_position":8,"hide_title":true,"keywords":["GoFrame","Transaction Handling","ORM Chaining","GoFrame Framework","Transaction","TX Interface","Database Object","Transaction Object","Chaining Operations","Commit/Rollback"],"description":"Using transaction handling in the GoFrame framework for ORM chaining methods. Through the Transaction and TX interfaces, transactional operations on the database can be achieved to ensure data consistency and reliability. Provides a detailed explanation of using the TX interface to create Model objects and the commit and rollback mechanisms in transaction handling."},"sidebar":"mainSidebar","previous":{"title":"ORM Model - Fields Retrieval","permalink":"/en/docs/core/gdb-chaining-fields-retrieving"},"next":{"title":"ORM Model - Master/Slave","permalink":"/en/docs/core/gdb-chaining-master-slave"}}'),a=t("785893"),i=t("250065");let o={slug:"/docs/core/gdb-chaining-transaction",title:"ORM Model - Transaction",sidebar_position:8,hide_title:!0,keywords:["GoFrame","Transaction Handling","ORM Chaining","GoFrame Framework","Transaction","TX Interface","Database Object","Transaction Object","Chaining Operations","Commit/Rollback"],description:"Using transaction handling in the GoFrame framework for ORM chaining methods. Through the Transaction and TX interfaces, transactional operations on the database can be achieved to ensure data consistency and reliability. Provides a detailed explanation of using the TX interface to create Model objects and the commit and rollback mechanisms in transaction handling."},s=void 0,c={},d=[{value:"Example 1: Using <code>Transaction</code>",id:"example-1-using-transaction",level:2},{value:"Example 2: Using <code>TX</code> Chaining Operations",id:"example-2-using-tx-chaining-operations",level:2}];function l(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Model"})," objects can also be created through the ",(0,a.jsx)(n.code,{children:"TX"})," transaction interface. The functionality of a ",(0,a.jsx)(n.code,{children:"Model"})," object created through a transaction object is the same as that of one created through a ",(0,a.jsx)(n.code,{children:"DB"})," database object, except that the former's operations are based on transactions. Once the transaction is committed or rolled back, the corresponding ",(0,a.jsx)(n.code,{children:"Model"})," object cannot be used further; otherwise, an error will be returned. Because the ",(0,a.jsx)(n.code,{children:"TX"})," interface cannot be reused, a transaction object corresponds to a single transaction process and ends after ",(0,a.jsx)(n.code,{children:"Commit"}),"/",(0,a.jsx)(n.code,{children:"Rollback"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["This chapter provides a simple introduction to transaction handling methods involved in chaining operations. For more detailed information, please refer to the ",(0,a.jsx)(n.a,{href:"/en/docs/core/gdb-transaction",children:"ORM - Transaction"})," chapter."]}),"\n",(0,a.jsxs)(n.h2,{id:"example-1-using-transaction",children:["Example 1: Using ",(0,a.jsx)(n.code,{children:"Transaction"})]}),"\n",(0,a.jsxs)(n.p,{children:["To facilitate transaction operations, ",(0,a.jsx)(n.code,{children:"gdb"})," provides a closure operation for transactions, implemented through the ",(0,a.jsx)(n.code,{children:"Transaction"})," method, which is defined as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"func (db DB) Transaction(ctx context.Context, f func(ctx context.Context, tx TX) error) (err error)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If the ",(0,a.jsx)(n.code,{children:"error"})," returned by the given closure method is ",(0,a.jsx)(n.code,{children:"nil"}),", the ",(0,a.jsx)(n.code,{children:"Commit"})," operation is automatically executed after the closure finishes execution; otherwise, it automatically performs a ",(0,a.jsx)(n.code,{children:"Rollback"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["If a ",(0,a.jsx)(n.code,{children:"panic"})," occurs within the closure operation, the transaction will also be rolled back."]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'func Register() error {\n    return g.DB().Transaction(ctx, func(ctx context.Context, tx gdb.TX) error {\n        var (\n            result sql.Result\n            err    error\n        )\n        // Insert basic user data\n        result, err = tx.Table("user").Insert(g.Map{\n            "name":  "john",\n            "score": 100,\n            //...\n        })\n        if err != nil {\n            return err\n        }\n        // Insert user detail data, utilizing the user uid from the previous insertion\n        result, err = tx.Table("user_detail").Insert(g.Map{\n            "uid":   result.LastInsertId(),\n            "phone": "18010576258",\n            //...\n        })\n        return err\n    })\n}\n'})}),"\n",(0,a.jsxs)(n.h2,{id:"example-2-using-tx-chaining-operations",children:["Example 2: Using ",(0,a.jsx)(n.code,{children:"TX"})," Chaining Operations"]}),"\n",(0,a.jsxs)(n.p,{children:["We can also switch the bound transaction object within chaining operations using the ",(0,a.jsx)(n.code,{children:"TX"})," method. Multiple chaining operations can bind to the same transaction object, executing the corresponding chaining operations within that transaction object."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'func Register() error {\n    var (\n        uid int64\n        err error\n    )\n    tx, err := g.DB().Begin()\n    if err != nil {\n        return err\n    }\n    // Validate the return value upon method exit,\n    // If successful, execute tx.Commit() to commit,\n    // Otherwise, execute tx.Rollback() to roll back.\n    defer func() {\n        if err != nil {\n            tx.Rollback()\n        } else {\n            tx.Commit()\n        }\n    }()\n    // Insert basic user data\n    uid, err = AddUserInfo(tx, g.Map{\n        "name":  "john",\n        "score": 100,\n        //...\n    })\n    if err != nil {\n        return err\n    }\n    // Insert user detail data, using the user uid from the previous insertion\n    err = AddUserDetail(tx, g.Map{\n        "uid":   uid,\n        "phone": "18010576259",\n        //...\n    })\n    return err\n}\n\nfunc AddUserInfo(tx gdb.TX, data g.Map) (int64, error) {\n    result, err := g.Model("user").TX(tx).Data(data).Insert()\n    if err != nil {\n        return 0, err\n    }\n    uid, err := result.LastInsertId()\n    if err != nil {\n        return 0, err\n    }\n    return uid, nil\n}\n\nfunc AddUserDetail(tx gdb.TX, data g.Map) error {\n    _, err := g.Model("user_detail").TX(tx).Data(data).Insert()\n    return err\n}\n'})})]})}function h(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return s},a:function(){return o}});var r=t(667294);let a={},i=r.createContext(a);function o(e){let n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);