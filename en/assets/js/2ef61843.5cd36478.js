"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["14886"],{727873:function(e,n,t){t.r(n),t.d(n,{metadata:()=>r,contentTitle:()=>a,default:()=>h,assets:()=>d,toc:()=>s,frontMatter:()=>c});var r=JSON.parse('{"id":"docs/\u7EC4\u4EF6\u5217\u8868/\u7F51\u7EDC\u7EC4\u4EF6/TCP\u7EC4\u4EF6/TCP\u7EC4\u4EF6-\u8FDE\u63A5\u5BF9\u8C61/TCP\u7EC4\u4EF6-\u8FDE\u63A5\u5BF9\u8C61","title":"TCP - Object","description":"This page introduces the usage of gtcp module and its TCP connection object provided by the GoFrame framework. It includes how to use gtcp.Conn for reliable TCP communication and handling data sending and receiving. The text also describes the timeout handling mechanism and demonstrates with simple examples how to use these features, showing how to flexibly perform network programming in the GoFrame environment.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u7EC4\u4EF6\u5217\u8868/\u7F51\u7EDC\u7EC4\u4EF6/TCP\u7EC4\u4EF6/TCP\u7EC4\u4EF6-\u8FDE\u63A5\u5BF9\u8C61/TCP\u7EC4\u4EF6-\u8FDE\u63A5\u5BF9\u8C61.md","sourceDirName":"docs/\u7EC4\u4EF6\u5217\u8868/\u7F51\u7EDC\u7EC4\u4EF6/TCP\u7EC4\u4EF6/TCP\u7EC4\u4EF6-\u8FDE\u63A5\u5BF9\u8C61","slug":"/docs/components/network-gtcp-conn","permalink":"/en/docs/components/network-gtcp-conn","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u7EC4\u4EF6\u5217\u8868/\u7F51\u7EDC\u7EC4\u4EF6/TCP\u7EC4\u4EF6/TCP\u7EC4\u4EF6-\u8FDE\u63A5\u5BF9\u8C61/TCP\u7EC4\u4EF6-\u8FDE\u63A5\u5BF9\u8C61.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732443619000,"sidebarPosition":0,"frontMatter":{"slug":"/docs/components/network-gtcp-conn","title":"TCP - Object","sidebar_position":0,"hide_title":true,"keywords":["GoFrame","GoFrame framework","gtcp","TCP communication","connection object","timeout handling","data writing","data reading","network programming","error retry"],"description":"This page introduces the usage of gtcp module and its TCP connection object provided by the GoFrame framework. It includes how to use gtcp.Conn for reliable TCP communication and handling data sending and receiving. The text also describes the timeout handling mechanism and demonstrates with simple examples how to use these features, showing how to flexibly perform network programming in the GoFrame environment."},"sidebar":"mainSidebar","previous":{"title":"TCP","permalink":"/en/docs/components/network-gtcp"},"next":{"title":"TCP Object - Package","permalink":"/en/docs/components/network-gtcp-conn-package"}}'),i=t("785893"),o=t("250065");let c={slug:"/docs/components/network-gtcp-conn",title:"TCP - Object",sidebar_position:0,hide_title:!0,keywords:["GoFrame","GoFrame framework","gtcp","TCP communication","connection object","timeout handling","data writing","data reading","network programming","error retry"],description:"This page introduces the usage of gtcp module and its TCP connection object provided by the GoFrame framework. It includes how to use gtcp.Conn for reliable TCP communication and handling data sending and receiving. The text also describes the timeout handling mechanism and demonstrates with simple examples how to use these features, showing how to flexibly perform network programming in the GoFrame environment."},a=void 0,d={},s=[{value:"Writing Operation",id:"writing-operation",level:2},{value:"Reading Operation",id:"reading-operation",level:2},{value:"Timeout Handling",id:"timeout-handling",level:2},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Example 1, Simple Usage",id:"example-1-simple-usage",level:3},{value:"Example 2, Echo Service",id:"example-2-echo-service",level:3},{value:"Example 3, HTTP Client",id:"example-3-http-client",level:3}];function l(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"gtcp"})," module provides an easy-to-use ",(0,i.jsx)(n.code,{children:"gtcp.Conn"})," link operation object."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'import "github.com/gogf/gf/v2/net/gtcp"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"API Documentation:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://pkg.go.dev/github.com/gogf/gf/v2/net/gtcp",children:"https://pkg.go.dev/github.com/gogf/gf/v2/net/gtcp"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"type Conn\n    func NewConn(addr string, timeout ...int) (*Conn, error)\n    func NewConnByNetConn(conn net.Conn) *Conn\n    func NewConnKeyCrt(addr, crtFile, keyFile string) (*Conn, error)\n    func NewConnTLS(addr string, tlsConfig *tls.Config) (*Conn, error)\n    func (c *Conn) Close() error\n    func (c *Conn) LocalAddr() net.Addr\n    func (c *Conn) Recv(length int, retry ...Retry) ([]byte, error)\n    func (c *Conn) RecvLine(retry ...Retry) ([]byte, error)\n    func (c *Conn) RecvWithTimeout(length int, timeout time.Duration, retry ...Retry) ([]byte, error)\n    func (c *Conn) RemoteAddr() net.Addr\n    func (c *Conn) Send(data []byte, retry ...Retry) error\n    func (c *Conn) SendRecv(data []byte, receive int, retry ...Retry) ([]byte, error)\n    func (c *Conn) SendRecvWithTimeout(data []byte, receive int, timeout time.Duration, retry ...Retry) ([]byte, error)\n    func (c *Conn) SendWithTimeout(data []byte, timeout time.Duration, retry ...Retry) error\n    func (c *Conn) SetDeadline(t time.Time) error\n    func (c *Conn) SetRecvBufferWait(bufferWaitDuration time.Duration)\n    func (c *Conn) SetRecvDeadline(t time.Time) error\n    func (c *Conn) SetSendDeadline(t time.Time) error\n"})}),"\n",(0,i.jsx)(n.h2,{id:"writing-operation",children:"Writing Operation"}),"\n",(0,i.jsxs)(n.p,{children:["The TCP communication writing operation is implemented by the ",(0,i.jsx)(n.code,{children:"Send"})," method, providing an error retry mechanism via the second optional parameter ",(0,i.jsx)(n.code,{children:"retry"}),". Note that the ",(0,i.jsx)(n.code,{children:"Send"})," method does not have any buffering mechanism, meaning that each call to the ",(0,i.jsx)(n.code,{children:"Send"})," method will immediately invoke the underlying TCP Write method to write data (buffering relies on the system's underlying implementation). Therefore, if you want to control output buffering, please handle it at the business layer."]}),"\n",(0,i.jsxs)(n.p,{children:["When performing TCP writes, reliable communication scenarios often involve a write and a read, i.e., starting ",(0,i.jsx)(n.code,{children:"Recv"})," to get the target's feedback result immediately after a successful ",(0,i.jsx)(n.code,{children:"Send"}),". Therefore, ",(0,i.jsx)(n.code,{children:"gtcp.Conn"})," also offers a convenient ",(0,i.jsx)(n.code,{children:"SendRecv"})," method."]}),"\n",(0,i.jsx)(n.h2,{id:"reading-operation",children:"Reading Operation"}),"\n",(0,i.jsxs)(n.p,{children:["The TCP communication reading operation is implemented by the ",(0,i.jsx)(n.code,{children:"Recv"})," method, which also provides an error retry mechanism via a second optional parameter ",(0,i.jsx)(n.code,{children:"retry"}),". The ",(0,i.jsx)(n.code,{children:"Recv"})," method offers built-in read buffer control, allowing you to specify the reading length (specified by the ",(0,i.jsx)(n.code,{children:"length"})," parameter). It will immediately return when the specified length of data has been read. If ",(0,i.jsx)(n.code,{children:"length < 0"}),", it will read all readable buffer data and return it. When ",(0,i.jsx)(n.code,{children:"length = 0"}),", it means to get the buffered data once and return immediately."]}),"\n",(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.code,{children:"Recv(-1)"})," can read all readable buffer data (with indefinite length, possible truncation if the sent data packet is too long), but be cautious of packet parsing issues, which can easily result in incomplete packets. In this case, the business layer needs to ensure data packet integrity based on the predetermined protocol structure. It is recommended to use the simple protocol introduced later via ",(0,i.jsx)(n.code,{children:"SendPkg"}),"/ ",(0,i.jsx)(n.code,{children:"RecvPkg"})," to send/receive message packets, as described in subsequent sections."]}),"\n",(0,i.jsx)(n.h2,{id:"timeout-handling",children:"Timeout Handling"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"gtcp.Conn"})," provides timeout handling for TCP communication data writing and reading, specified via the ",(0,i.jsx)(n.code,{children:"timeout"})," parameter in the method, which is straightforward and won't be elaborated further."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["Next, we'll look at how to use the ",(0,i.jsx)(n.code,{children:"gtcp.Conn"})," object through some examples."]}),"\n",(0,i.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(n.h3,{id:"example-1-simple-usage",children:"Example 1, Simple Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "time"\n    "github.com/gogf/gf/v2/net/gtcp"\n    "github.com/gogf/gf/v2/os/glog"\n    "github.com/gogf/gf/v2/util/gconv"\n)\n\nfunc main() {\n    // Server\n    go gtcp.NewServer("127.0.0.1:8999", func(conn *gtcp.Conn) {\n        defer conn.Close()\n        for {\n            data, err := conn.Recv(-1)\n            if len(data) > 0 {\n                  fmt.Println(string(data))\n            }\n            if err != nil {\n                break\n            }\n        }\n    }).Run()\n\n    time.Sleep(time.Second)\n\n    // Client\n    conn, err := gtcp.NewConn("127.0.0.1:8999")\n    if err != nil {\n        panic(err)\n    }\n    for i := 0; i < 10000; i++ {\n        if err := conn.Send([]byte(gconv.String(i))); err != nil {\n            glog.Error(err)\n        }\n        time.Sleep(time.Second)\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["On the ",(0,i.jsx)(n.code,{children:"Server"})," side, received client data is immediately printed to the terminal."]}),"\n",(0,i.jsxs)(n.li,{children:["On the ",(0,i.jsx)(n.code,{children:"Client"})," side, the same connection object is used to send an incrementing number to the server every second in a loop. This function also demonstrates that underlying ",(0,i.jsx)(n.code,{children:"Socket"})," communication does not use buffering; executing a ",(0,i.jsx)(n.code,{children:"Send"})," immediately sends data to the server. Therefore, the client needs to manage the buffered data to be sent locally."]}),"\n",(0,i.jsx)(n.li,{children:"Execution result After execution, you can see the server outputting the following information on the terminal:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"    2018-07-11 22:11:08.650 0\n    2018-07-11 22:11:09.651 1\n    2018-07-11 22:11:10.651 2\n    2018-07-11 22:11:11.651 3\n    2018-07-11 22:11:12.651 4\n    2018-07-11 22:11:13.651 5\n    2018-07-11 22:11:14.652 6\n    2018-07-11 22:11:15.652 7\n    2018-07-11 22:11:16.652 8\n    2018-07-11 22:11:17.652 9\n    2018-07-11 22:11:18.652 10\n    2018-07-11 22:11:19.653 11\n    ...\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-2-echo-service",children:"Example 2, Echo Service"}),"\n",(0,i.jsx)(n.p,{children:"Let's improve the previous echo service:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "time"\n    "github.com/gogf/gf/v2/net/gtcp"\n    "github.com/gogf/gf/v2/os/glog"\n    "github.com/gogf/gf/v2/os/gtime"\n)\n\nfunc main() {\n    // Server\n    go gtcp.NewServer("127.0.0.1:8999", func(conn *gtcp.Conn) {\n        defer conn.Close()\n        for {\n            data, err := conn.Recv(-1)\n            if len(data) > 0 {\n                if err := conn.Send(append([]byte("> "), data...)); err != nil {\n                  fmt.Println(err)\n                }\n            }\n            if err != nil {\n                break\n            }\n        }\n    }).Run()\n\n    time.Sleep(time.Second)\n\n    // Client\n    for {\n       if conn, err := gtcp.NewConn("127.0.0.1:8999"); err == nil {\n           if b, err := conn.SendRecv([]byte(gtime.Datetime()), -1); err == nil {\n               fmt.Println(string(b), conn.LocalAddr(), conn.RemoteAddr())\n           } else {\n               fmt.Println(err)\n           }\n           conn.Close()\n       } else {\n           glog.Error(err)\n       }\n       time.Sleep(time.Second)\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this example program, the ",(0,i.jsx)(n.code,{children:"Client"})," sends the current time information to the ",(0,i.jsx)(n.code,{children:"Server"})," every second, and the ",(0,i.jsx)(n.code,{children:"Server"})," returns the original data message upon reception. Upon receiving the server-side return message, the ",(0,i.jsx)(n.code,{children:"Client"})," immediately prints it to the terminal."]}),"\n",(0,i.jsx)(n.p,{children:"Execution results in output as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> 2018-07-19 23:25:43 127.0.0.1:34306 127.0.0.1:8999\n> 2018-07-19 23:25:44 127.0.0.1:34308 127.0.0.1:8999\n> 2018-07-19 23:25:45 127.0.0.1:34312 127.0.0.1:8999\n> 2018-07-19 23:25:46 127.0.0.1:34314 127.0.0.1:8999\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-3-http-client",children:"Example 3, HTTP Client"}),"\n",(0,i.jsxs)(n.p,{children:["In this example, we use the gtcp package to implement a simple HTTP client, reading and printing the ",(0,i.jsx)(n.code,{children:"header"})," and ",(0,i.jsx)(n.code,{children:"content"})," of the Baidu homepage."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "bytes"\n    "github.com/gogf/gf/v2/net/gtcp"\n    "github.com/gogf/gf/v2/util/gconv"\n)\n\nfunc main() {\n    conn, err := gtcp.NewConn("www.baidu.com:80")\n    if err != nil {\n        panic(err)\n    }\n    defer conn.Close()\n\n    if err := conn.Send([]byte("GET / HTTP/1.1\\r\\n\\r\\n")); err != nil {\n        panic(err)\n    }\n\n    header        := make([]byte, 0)\n    content       := make([]byte, 0)\n    contentLength := 0\n    for {\n        data, err := conn.RecvLine()\n        // Header reading, parsing text length\n        if len(data) > 0 {\n            array := bytes.Split(data, []byte(": "))\n            // Get page content length\n            if contentLength == 0 && len(array) == 2 && bytes.EqualFold([]byte("Content-Length"), array[0]) {\n                contentLength = gconv.Int(string(array[1][:len(array[1])-1]))           }\n            header = append(header, data...)\n            header = append(header, \'\\n\')\n        }\n        // Header reading complete, read text content\n        if contentLength > 0 && len(data) == 1 {\n            content, _ = conn.Recv(contentLength)\n            break\n        }\n        if err != nil {\n            fmt.Errorf("ERROR: %s\\n", err.Error())\n            break\n        }\n    }\n\n    if len(header) > 0 {\n        fmt.Println(string(header))\n    }\n    if len(content) > 0 {\n        fmt.Println(string(content))\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Execution results in output as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'HTTP/1.1 200 OK\nAccept-Ranges: bytes\nCache-Control: no-cache\nConnection: Keep-Alive\nContent-Length: 14615\nContent-Type: text/html\nDate: Sat, 21 Jul 2018 04:21:03 GMT\nEtag: "5b3c3650-3917"\nLast-Modified: Wed, 04 Jul 2018 02:52:00 GMT\nP3p: CP=" OTI DSP COR IVA OUR IND COM "\nPragma: no-cache\nServer: BWS/1.1\n...\n(truncated)\n'})})]})}function h(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return a},a:function(){return c}});var r=t(667294);let i={},o=r.createContext(i);function c(e){let n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);