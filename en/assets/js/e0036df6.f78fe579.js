"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["23421"],{411137:function(e,n,t){t.r(n),t.d(n,{metadata:()=>a,contentTitle:()=>s,default:()=>l,assets:()=>o,toc:()=>d,frontMatter:()=>r});var a=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u67E5\u8BE2\u7F13\u5B58","title":"ORM Model - Query Cache","description":"Performing query cache operations using the ORM in the GoFrame framework. It supports caching to optimize query results, suitable for scenarios with more reads and fewer writes. The article provides a detailed introduction to cache management and adaptation, especially how to implement distributed caching using Redis. It also provides sample code showing table structures and their caching effects, demonstrating query cache implementation and cache clearing functions.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u67E5\u8BE2\u7F13\u5B58.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C","slug":"/docs/core/gdb-chaining-query-cache","permalink":"/en/docs/core/gdb-chaining-query-cache","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u67E5\u8BE2\u7F13\u5B58.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732541616000,"sidebarPosition":10,"frontMatter":{"slug":"/docs/core/gdb-chaining-query-cache","title":"ORM Model - Query Cache","sidebar_position":10,"hide_title":true,"keywords":["GoFrame","ORM","query cache","chained operations","cache management","Redis","database","cache clearing","cache adaptation","table structure"],"description":"Performing query cache operations using the ORM in the GoFrame framework. It supports caching to optimize query results, suitable for scenarios with more reads and fewer writes. The article provides a detailed introduction to cache management and adaptation, especially how to implement distributed caching using Redis. It also provides sample code showing table structures and their caching effects, demonstrating query cache implementation and cache clearing functions."},"sidebar":"mainSidebar","previous":{"title":"ORM Model - Master/Slave","permalink":"/en/docs/core/gdb-chaining-master-slave"},"next":{"title":"ORM Model - Time Fields","permalink":"/en/docs/core/gdb-chaining-soft-time"}}'),c=t("785893"),i=t("250065");let r={slug:"/docs/core/gdb-chaining-query-cache",title:"ORM Model - Query Cache",sidebar_position:10,hide_title:!0,keywords:["GoFrame","ORM","query cache","chained operations","cache management","Redis","database","cache clearing","cache adaptation","table structure"],description:"Performing query cache operations using the ORM in the GoFrame framework. It supports caching to optimize query results, suitable for scenarios with more reads and fewer writes. The article provides a detailed introduction to cache management and adaptation, especially how to implement distributed caching using Redis. It also provides sample code showing table structures and their caching effects, demonstrating query cache implementation and cache clearing functions."},s=void 0,o={},d=[{value:"Query Cache",id:"query-cache",level:2},{value:"Cache Management",id:"cache-management",level:2},{value:"Cache Object",id:"cache-object",level:3},{value:"Cache Adaptation (Redis Caching)",id:"cache-adaptation-redis-caching",level:3},{value:"Management Methods",id:"management-methods",level:3},{value:"Usage Example",id:"usage-example",level:2},{value:"Table Structure",id:"table-structure",level:3},{value:"Sample Code",id:"sample-code",level:3}];function h(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.h2,{id:"query-cache",children:"Query Cache"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"gdb"})," supports caching query results, which is commonly used in scenarios involving more reads and fewer writes. It also allows for manual cache clearing. Note that query caching only supports chained operations and is not available within a transaction."]}),"\n",(0,c.jsx)(n.p,{children:"Related methods:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-go",children:"type CacheOption struct {\n    // Duration is the TTL for the cache.\n    // If the parameter `Duration` < 0, which means it clears the cache with given `Name`.\n    // If the parameter `Duration` = 0, which means it never expires.\n    // If the parameter `Duration` > 0, which means it expires after `Duration`.\n    Duration time.Duration\n\n    // Name is an optional unique name for the cache.\n    // The Name is used to bind a name to the cache, which means you can later control the cache\n    // like changing the `duration` or clearing the cache with specified Name.\n    Name string\n\n    // Force caches the query result whatever the result is nil or not.\n    // It is used to avoid Cache Penetration.\n    Force bool\n}\n\n// Cache sets the cache feature for the model. It caches the result of the sql, which means\n// if there's another same sql request, it just reads and returns the result from cache, it\n// but not committed and executed into the database.\n//\n// Note that, the cache feature is disabled if the model is performing select statement\n// on a transaction.\nfunc (m *Model) Cache(option CacheOption) *Model\n"})}),"\n",(0,c.jsx)(n.h2,{id:"cache-management",children:"Cache Management"}),"\n",(0,c.jsx)(n.h3,{id:"cache-object",children:"Cache Object"}),"\n",(0,c.jsxs)(n.p,{children:["By default, the ",(0,c.jsx)(n.code,{children:"ORM"})," object provides a cache management object, and this cache object type is ",(0,c.jsx)(n.code,{children:"*gcache.Cache"}),". This means it also supports all the features of ",(0,c.jsx)(n.code,{children:"*gcache.Cache"}),". You can obtain the cache object through the ",(0,c.jsx)(n.code,{children:"GetCache() *gcache.Cache"})," method and use the returned object to perform various custom cache operations, such as ",(0,c.jsx)(n.code,{children:"g.DB().GetCache().Keys()"}),"."]}),"\n",(0,c.jsx)(n.h3,{id:"cache-adaptation-redis-caching",children:"Cache Adaptation (Redis Caching)"}),"\n",(0,c.jsxs)(n.p,{children:["By default, the ",(0,c.jsx)(n.code,{children:"*gcache.Cache"})," cache object of ",(0,c.jsx)(n.code,{children:"ORM"})," provides single-process memory caching, which is highly efficient but can only be used in a single process. If the service is deployed on multiple nodes, caches between nodes may be inconsistent, so in most scenarios, we implement database query caching through a Redis server. The ",(0,c.jsx)(n.code,{children:"*gcache.Cache"})," object adopts an adapter design pattern, allowing easy switching from single-process memory caching to distributed Redis caching. Example use:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-go",children:"redisCache := gcache.NewAdapterRedis(g.Redis())\ng.DB().GetCache().SetAdapter(redisCache)\n"})}),"\n",(0,c.jsxs)(n.p,{children:["For more information, refer to: ",(0,c.jsx)(n.a,{href:"/en/docs/core/gcache-redis",children:"Caching - Redis"})]}),"\n",(0,c.jsx)(n.h3,{id:"management-methods",children:"Management Methods"}),"\n",(0,c.jsxs)(n.p,{children:["To simplify database query cache management, starting from version ",(0,c.jsx)(n.code,{children:"v2.2.0"}),", two cache management methods are provided:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-go",children:"// ClearCache removes cached sql result of certain table.\nfunc (c *Core) ClearCache(ctx context.Context, table string) (err error)\n\n// ClearCacheAll removes all cached sql result from cache\nfunc (c *Core) ClearCacheAll(ctx context.Context) (err error)\n"})}),"\n",(0,c.jsxs)(n.p,{children:["The methods are explained in the comments. These methods are mounted on the ",(0,c.jsx)(n.code,{children:"Core"})," object, and the underlying ",(0,c.jsx)(n.code,{children:"Core"})," object is already exposed through the ",(0,c.jsx)(n.code,{children:"DB"})," interface, allowing us to obtain the ",(0,c.jsx)(n.code,{children:"Core"})," object like this:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-go",children:"g.DB().GetCore()\n"})}),"\n",(0,c.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,c.jsx)(n.h3,{id:"table-structure",children:"Table Structure"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE `user` (\n  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `name` varchar(30) NOT NULL DEFAULT '' COMMENT 'Nickname',\n  `site` varchar(255) NOT NULL DEFAULT '' COMMENT 'Homepage',\n  PRIMARY KEY (`uid`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n"})}),"\n",(0,c.jsx)(n.h3,{id:"sample-code",children:"Sample Code"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "time"\n\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/os/gctx"\n)\n\nfunc main() {\n    var (\n        db  = g.DB()\n        ctx = gctx.New()\n    )\n\n    // Enable debug mode to record all executed SQL\n    db.SetDebug(true)\n\n    // Insert test data\n    _, err := g.Model("user").Ctx(ctx).Data(g.Map{\n        "name": "john",\n        "site": "https://goframe.org",\n    }).Insert()\n\n    // Perform the query twice and cache the result for 1 hour with an optional cache name\n    for i := 0; i < 2; i++ {\n        r, _ := g.Model("user").Ctx(ctx).Cache(gdb.CacheOption{\n            Duration: time.Hour,\n            Name:     "vip-user",\n            Force:    false,\n        }).Where("uid", 1).One()\n        g.Log().Debug(ctx, r.Map())\n    }\n\n    // Perform an update operation and clear the query cache with a specified name\n    _, err = g.Model("user").Ctx(ctx).Cache(gdb.CacheOption{\n        Duration: -1,\n        Name:     "vip-user",\n        Force:    false,\n    }).Data(gdb.Map{"name": "smith"}).Where("uid", 1).Update()\n    if err != nil {\n        g.Log().Fatal(ctx, err)\n    }\n\n    // Execute the query again enabling the query cache feature\n    r, _ := g.Model("user").Ctx(ctx).Cache(gdb.CacheOption{\n        Duration: time.Hour,\n        Name:     "vip-user",\n        Force:    false,\n    }).Where("uid", 1).One()\n    g.Log().Debug(ctx, r.Map())\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"The output after execution is (the test table data structure is for reference only):"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:'2022-02-08 17:36:19.817 [DEBU] {c0424c75f1c5d116d0df0f7197379412} {"name":"john","site":"https://goframe.org","uid":1}\n2022-02-08 17:36:19.817 [DEBU] {c0424c75f1c5d116d0df0f7197379412} {"name":"john","site":"https://goframe.org","uid":1}\n2022-02-08 17:36:19.817 [DEBU] {c0424c75f1c5d116d0df0f7197379412} [  0 ms] [default] [rows:1  ] UPDATE `user` SET `name`=\'smith\' WHERE `uid`=1\n2022-02-08 17:36:19.818 [DEBU] {c0424c75f1c5d116d0df0f7197379412} [  1 ms] [default] [rows:1  ] SELECT * FROM `user` WHERE `uid`=1 LIMIT 1\n2022-02-08 17:36:19.818 [DEBU] {c0424c75f1c5d116d0df0f7197379412} {"name":"smith","site":"https://goframe.org","uid":1}\n'})}),"\n",(0,c.jsx)(n.p,{children:"It can be observed that:"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["To demonstrate cache effects conveniently, data ",(0,c.jsx)(n.code,{children:"debug"})," feature is enabled, so any SQL operation will be output to the terminal."]}),"\n",(0,c.jsxs)(n.li,{children:["The ",(0,c.jsx)(n.code,{children:"One"})," method is executed twice for data querying. The first time an SQL query is executed, the second time it directly uses the cache without submitting the SQL to the database, hence only one query SQL is printed, and the results of both queries are consistent."]}),"\n",(0,c.jsxs)(n.li,{children:["Note that a custom name ",(0,c.jsx)(n.code,{children:"vip-user"})," is set for caching the query, facilitating subsequent cache clearing upon update. If cache clearing is not needed, a cache name does not need to be set."]}),"\n",(0,c.jsxs)(n.li,{children:["The cache with a specified name is cleared when the ",(0,c.jsx)(n.code,{children:"Update"})," operation is executed."]}),"\n",(0,c.jsx)(n.li,{children:"The query is executed again to re-cache the new data."}),"\n"]})]})}function l(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(h,{...e})}):h(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return s},a:function(){return r}});var a=t(667294);let c={},i=a.createContext(c);function r(e){let n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);