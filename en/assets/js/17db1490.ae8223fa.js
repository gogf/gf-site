"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["938810"],{444720:function(e,n,s){s.r(n),s.d(n,{metadata:()=>i,contentTitle:()=>a,default:()=>h,assets:()=>d,toc:()=>c,frontMatter:()=>o});var i=JSON.parse('{"id":"docs/WEB\u670D\u52A1\u5F00\u53D1/Session/Session-RegenerateId","title":"Session - RegenerateId","description":"Session ID regeneration functionality in the GoFrame framework, preventing session fixation attacks through RegenerateId and MustRegenerateId methods to enhance web application security. Detailed explanation of session fixation attack principles, risks, and prevention methods, with complete code examples and security recommendations.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/WEB\u670D\u52A1\u5F00\u53D1/Session/Session-RegenerateId.md","sourceDirName":"docs/WEB\u670D\u52A1\u5F00\u53D1/Session","slug":"/docs/web/session-regenerate-id","permalink":"/en/docs/web/session-regenerate-id","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/WEB\u670D\u52A1\u5F00\u53D1/Session/Session-RegenerateId.md","tags":[],"version":"current","lastUpdatedBy":"John Guo","lastUpdatedAt":1742194305000,"sidebarPosition":6000,"frontMatter":{"slug":"/docs/web/session-regenerate-id","title":"Session - RegenerateId","sidebar_position":6000,"hide_title":true,"keywords":["GoFrame","GoFrame Framework","Session Management","gsession","RegenerateId","Session Fixation","Session Security","User Authentication","Security Best Practices"],"description":"Session ID regeneration functionality in the GoFrame framework, preventing session fixation attacks through RegenerateId and MustRegenerateId methods to enhance web application security. Detailed explanation of session fixation attack principles, risks, and prevention methods, with complete code examples and security recommendations."},"sidebar":"mainSidebar","previous":{"title":"Session - Storage Interface","permalink":"/en/docs/web/session-storage"},"next":{"title":"Exception Handling","permalink":"/en/docs/web/panic-handling"}}'),t=s("785893"),r=s("250065");let o={slug:"/docs/web/session-regenerate-id",title:"Session - RegenerateId",sidebar_position:6e3,hide_title:!0,keywords:["GoFrame","GoFrame Framework","Session Management","gsession","RegenerateId","Session Fixation","Session Security","User Authentication","Security Best Practices"],description:"Session ID regeneration functionality in the GoFrame framework, preventing session fixation attacks through RegenerateId and MustRegenerateId methods to enhance web application security. Detailed explanation of session fixation attack principles, risks, and prevention methods, with complete code examples and security recommendations."},a=void 0,d={},c=[{value:"Introduction to Session Fixation Attacks",id:"introduction-to-session-fixation-attacks",level:2},{value:"Preventing Session Fixation Attacks",id:"preventing-session-fixation-attacks",level:2},{value:"<code>RegenerateId</code> Method",id:"regenerateid-method",level:2},{value:"Implementation Principle",id:"implementation-principle",level:3},{value:"<code>RegenerateId</code> Method",id:"regenerateid-method-1",level:3},{value:"<code>MustRegenerateId</code> Method",id:"mustregenerateid-method",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"Security Recommendations",id:"security-recommendations",level:3}];function l(e){let n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"introduction-to-session-fixation-attacks",children:"Introduction to Session Fixation Attacks"}),"\n",(0,t.jsx)(n.p,{children:"Session fixation attacks are a common web application security vulnerability where attackers control a user's session by setting the user's session identifier (Session ID). The basic process of this attack is as follows:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The attacker obtains a valid ",(0,t.jsx)(n.code,{children:"Session ID"})," (by visiting the target website or through other means)"]}),"\n",(0,t.jsxs)(n.li,{children:["The attacker induces the victim to use this ",(0,t.jsx)(n.code,{children:"Session ID"})," to access the target website (e.g., through specially crafted URLs, XSS attacks, etc.)"]}),"\n",(0,t.jsxs)(n.li,{children:["The victim logs into the website using this preset ",(0,t.jsx)(n.code,{children:"Session ID"})]}),"\n",(0,t.jsxs)(n.li,{children:["After successful login, the ",(0,t.jsx)(n.code,{children:"Session ID"})," is associated with the victim's account"]}),"\n",(0,t.jsxs)(n.li,{children:["The attacker uses the same ",(0,t.jsx)(n.code,{children:"Session ID"})," to access the website, thereby gaining the victim's identity and permissions"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The danger of this attack is that attackers can obtain a user's identity without cracking the user's password, allowing them to access sensitive information or perform unauthorized operations."}),"\n",(0,t.jsx)(n.h2,{id:"preventing-session-fixation-attacks",children:"Preventing Session Fixation Attacks"}),"\n",(0,t.jsxs)(n.p,{children:["The best practice for preventing session fixation attacks is to regenerate the ",(0,t.jsx)(n.code,{children:"Session ID"})," after a user successfully authenticates (logs in). This way, even if an attacker manages to make a user use a specific ",(0,t.jsx)(n.code,{children:"Session ID"}),", that ID will be replaced after successful login, rendering the attack ineffective."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"GoFrame"})," framework provides ",(0,t.jsx)(n.code,{children:"RegenerateId"})," and ",(0,t.jsx)(n.code,{children:"MustRegenerateId"})," methods to implement this security mechanism."]}),"\n",(0,t.jsxs)(n.h2,{id:"regenerateid-method",children:[(0,t.jsx)(n.code,{children:"RegenerateId"})," Method"]}),"\n",(0,t.jsxs)(n.p,{children:["In applications with higher security requirements, to prevent ",(0,t.jsx)(n.strong,{children:"session fixation attacks"}),", it's usually necessary to regenerate the ",(0,t.jsx)(n.code,{children:"Session ID"})," after a user successfully logs in. The ",(0,t.jsx)(n.code,{children:"GoFrame"})," framework provides ",(0,t.jsx)(n.code,{children:"RegenerateId"})," and ",(0,t.jsx)(n.code,{children:"MustRegenerateId"})," methods to implement this functionality."]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-principle",children:"Implementation Principle"}),"\n",(0,t.jsxs)(n.p,{children:["The implementation principle of the ",(0,t.jsx)(n.code,{children:"RegenerateId"})," method is as follows:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Generate a new ",(0,t.jsx)(n.code,{children:"Session ID"})]}),"\n",(0,t.jsxs)(n.li,{children:["Copy the current session data to the new ",(0,t.jsx)(n.code,{children:"Session ID"})]}),"\n",(0,t.jsxs)(n.li,{children:["Decide whether to delete the old session data based on the ",(0,t.jsx)(n.code,{children:"deleteOld"})," parameter"]}),"\n",(0,t.jsx)(n.li,{children:"Update the current session's ID to the newly generated ID"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This achieves seamless migration of session data while ensuring security."}),"\n",(0,t.jsxs)(n.h3,{id:"regenerateid-method-1",children:[(0,t.jsx)(n.code,{children:"RegenerateId"})," Method"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Description: The ",(0,t.jsx)(n.code,{children:"RegenerateId"})," method is used to regenerate a new ",(0,t.jsx)(n.code,{children:"Session ID"})," for the current session while preserving all data in the session. This is especially useful after a user successfully logs in, as it can prevent session fixation attacks."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"RegenerateId(deleteOld bool) (newId string, err error)\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Parameter Description:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"deleteOld"}),": Specifies whether to immediately delete the old session data","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"true"}),": The old session data will be deleted immediately"]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"false"}),": The old session data will be preserved and will expire automatically according to its TTL"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Return Values:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"newId"}),": The newly generated ",(0,t.jsx)(n.code,{children:"Session ID"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"err"}),": Possible errors that may occur during the operation"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"mustregenerateid-method",children:[(0,t.jsx)(n.code,{children:"MustRegenerateId"})," Method"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Description: The ",(0,t.jsx)(n.code,{children:"MustRegenerateId"})," method has the same functionality as ",(0,t.jsx)(n.code,{children:"RegenerateId"}),", but if an error occurs during the operation, it will directly ",(0,t.jsx)(n.code,{children:"panic"}),". This is very useful in scenarios where the ",(0,t.jsx)(n.code,{children:"Session ID"})," must be regenerated."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"MustRegenerateId(deleteOld bool) string\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Parameter Description:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"deleteOld"}),": Same meaning as the parameter in the ",(0,t.jsx)(n.code,{children:"RegenerateId"})," method"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Return Value:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The newly generated ",(0,t.jsx)(n.code,{children:"Session ID"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n	"github.com/gogf/gf/v2/frame/g"\n	"github.com/gogf/gf/v2/net/ghttp"\n	"github.com/gogf/gf/v2/os/gtime"\n)\n\nfunc main() {\n	s := g.Server()\n\n	// Mock login interface\n	s.BindHandler("/login", func(r *ghttp.Request) {\n		username := r.Get("username").String()\n		// password := r.Get("password").String()\n\n		// Assume username and password verification is done here\n		// password ...\n\n		// After verification, store user information in the Session\n		r.Session.MustSet("user", g.Map{\n			"username":   username,\n			"login_time": gtime.Now(),\n		})\n\n		// Important: Regenerate Session ID after successful login to prevent session fixation attacks\n		// Parameter true means to immediately delete the old session data\n		// The returned session id can be unused, the server will automatically return the latest session id through the header\n		_, err := r.Session.RegenerateId(true)\n		if err != nil {\n			r.Response.WriteJson(g.Map{\n				"code":    500,\n				"message": "Failed to regenerate Session ID",\n			})\n			return\n		}\n\n		r.Response.WriteJson(g.Map{\n			"code":    0,\n			"message": "Login successful",\n		})\n	})\n\n	// Get user information interface\n	// Note that you need to submit the session id through the header\n	s.BindHandler("/user/info", func(r *ghttp.Request) {\n		user := r.Session.MustGet("user")\n		if user == nil {\n			r.Response.WriteJson(g.Map{\n				"code":    403,\n				"message": "Not logged in or session expired",\n			})\n			return\n		}\n		r.Response.WriteJson(g.Map{\n			"code":    0,\n			"message": "Retrieved successfully",\n			"data":    user,\n		})\n	})\n\n	// Logout interface\n	s.BindHandler("/logout", func(r *ghttp.Request) {\n		// Clear all session data\n		_ = r.Session.RemoveAll()\n		r.Response.WriteJson(g.Map{\n			"code":    0,\n			"message": "Logout successful",\n		})\n	})\n\n	s.SetPort(8000)\n	s.Run()\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"security-recommendations",children:"Security Recommendations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Regenerate Session ID After Login"}),": Always call the ",(0,t.jsx)(n.code,{children:"RegenerateId"})," method to regenerate the ",(0,t.jsx)(n.code,{children:"Session ID"})," after a user successfully logs in. This is a basic practice to prevent session fixation attacks."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Regenerate Session ID After Sensitive Operations"}),": Consider regenerating the ",(0,t.jsx)(n.code,{children:"Session ID"})," after users perform sensitive operations such as password changes or permission changes."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Delete Old Session Data"}),": When regenerating the ",(0,t.jsx)(n.code,{children:"Session ID"}),", it is usually recommended to set the ",(0,t.jsx)(n.code,{children:"deleteOld"})," parameter to ",(0,t.jsx)(n.code,{children:"true"})," to immediately delete the old session data, preventing malicious use of session data."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use HTTPS"}),": Always use the ",(0,t.jsx)(n.code,{children:"HTTPS"})," protocol to transmit the ",(0,t.jsx)(n.code,{children:"Session ID"})," to prevent session information from being captured by network security tools or man-in-the-middle attacks."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Set Correct Cookie Attributes"}),": For cookies that store the ",(0,t.jsx)(n.code,{children:"Session ID"}),", set the ",(0,t.jsx)(n.code,{children:"HttpOnly"}),", ",(0,t.jsx)(n.code,{children:"Secure"}),", and ",(0,t.jsx)(n.code,{children:"SameSite"})," attributes to prevent ",(0,t.jsx)(n.code,{children:"XSS"})," attacks and ",(0,t.jsx)(n.code,{children:"CSRF"})," attacks."]}),"\n"]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},250065:function(e,n,s){s.d(n,{Z:function(){return a},a:function(){return o}});var i=s(667294);let t={},r=i.createContext(t);function o(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);