"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["132890"],{915598:function(e,n,r){r.r(n),r.d(n,{metadata:()=>t,contentTitle:()=>o,default:()=>u,assets:()=>c,toc:()=>l,frontMatter:()=>a});var t=JSON.parse('{"id":"community/\u793E\u533A\u6295\u7A3F/Go\u4E8B\u52A1\u5904\u7406\u6700\u4F73\u5B9E\u8DF5\uFF1A\u4FDD\u8BC1\u6570\u636E\u4E00\u81F4\u6027\u7684\u6B63\u786E\u65B9\u6CD5","title":"Go Transaction Processing Best Practices: The Right Way to Ensure Data Consistency","description":"An in-depth exploration of transaction processing best practices in Go, including basic transaction operations, isolation level selection, lock strategy optimization, modular design, and distributed transaction solutions. Through an e-commerce order system case study, learn how to build high-performance, reliable transaction processing modules that ensure data consistency and system stability","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/community/\u793E\u533A\u6295\u7A3F/Go\u4E8B\u52A1\u5904\u7406\u6700\u4F73\u5B9E\u8DF5\uFF1A\u4FDD\u8BC1\u6570\u636E\u4E00\u81F4\u6027\u7684\u6B63\u786E\u65B9\u6CD5.md","sourceDirName":"community/\u793E\u533A\u6295\u7A3F","slug":"/articles/database-transaction-practice","permalink":"/en/articles/database-transaction-practice","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/community/\u793E\u533A\u6295\u7A3F/Go\u4E8B\u52A1\u5904\u7406\u6700\u4F73\u5B9E\u8DF5\uFF1A\u4FDD\u8BC1\u6570\u636E\u4E00\u81F4\u6027\u7684\u6B63\u786E\u65B9\u6CD5.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1743397472000,"frontMatter":{"slug":"/articles/database-transaction-practice","title":"Go Transaction Processing Best Practices: The Right Way to Ensure Data Consistency","hide_title":true,"keywords":["GoFrame","Transaction Processing","Data Consistency","Isolation Levels","Optimistic Locking","Distributed Transactions","SAGA Pattern","Modular Design","Error Handling","Performance Optimization"],"description":"An in-depth exploration of transaction processing best practices in Go, including basic transaction operations, isolation level selection, lock strategy optimization, modular design, and distributed transaction solutions. Through an e-commerce order system case study, learn how to build high-performance, reliable transaction processing modules that ensure data consistency and system stability"},"sidebar":"communitySidebar","previous":{"title":"Golang Framework Comparison: GoFrame, Beego, Iris and Gin","permalink":"/en/articles/framework-comparison-goframe-beego-iris-gin"},"next":{"title":"How to Use Error Codes Gracefully in Go Development","permalink":"/en/articles/use-error-code-gracefully-in-golang"}}'),i=r("785893"),s=r("250065");let a={slug:"/articles/database-transaction-practice",title:"Go Transaction Processing Best Practices: The Right Way to Ensure Data Consistency",hide_title:!0,keywords:["GoFrame","Transaction Processing","Data Consistency","Isolation Levels","Optimistic Locking","Distributed Transactions","SAGA Pattern","Modular Design","Error Handling","Performance Optimization"],description:"An in-depth exploration of transaction processing best practices in Go, including basic transaction operations, isolation level selection, lock strategy optimization, modular design, and distributed transaction solutions. Through an e-commerce order system case study, learn how to build high-performance, reliable transaction processing modules that ensure data consistency and system stability"},o=void 0,c={},l=[{value:"1. Business Scenarios and Necessity of Transaction Processing",id:"1-business-scenarios-and-necessity-of-transaction-processing",level:2},{value:"1.1 Financial Transfer Systems",id:"11-financial-transfer-systems",level:3},{value:"1.2 E-commerce Order Processing",id:"12-e-commerce-order-processing",level:3},{value:"1.3 User Registration and Associated Data",id:"13-user-registration-and-associated-data",level:3},{value:"1.4 Multi-service Collaborative Operations",id:"14-multi-service-collaborative-operations",level:3},{value:"2. GoFrame Transaction Processing Basics",id:"2-goframe-transaction-processing-basics",level:2},{value:"2.1 Basic Usage of GoFrame Transactions",id:"21-basic-usage-of-goframe-transactions",level:3},{value:"2.1.1 Function Callback-based Transaction Processing",id:"211-function-callback-based-transaction-processing",level:4},{value:"2.1.2 Manual Transaction Start/Commit/Rollback",id:"212-manual-transaction-startcommitrollback",level:4},{value:"2.2 Advanced Features of GoFrame Transaction Processing",id:"22-advanced-features-of-goframe-transaction-processing",level:3},{value:"2.2.1 Safe Transaction Nesting",id:"221-safe-transaction-nesting",level:4},{value:"2.2.2 Specifying Transaction Isolation Level",id:"222-specifying-transaction-isolation-level",level:4},{value:"3. Case Study: E-commerce Order System Transaction Processing",id:"3-case-study-e-commerce-order-system-transaction-processing",level:2},{value:"3.1 Defining Models and Services",id:"31-defining-models-and-services",level:3},{value:"3.2 Implementing Service Logic with Transaction Processing",id:"32-implementing-service-logic-with-transaction-processing",level:3},{value:"3.2.1 Core Process",id:"321-core-process",level:4},{value:"3.2.2 Calculate Order Amount and Validate Inventory",id:"322-calculate-order-amount-and-validate-inventory",level:4},{value:"3.2.3 Validate User Balance",id:"323-validate-user-balance",level:4},{value:"3.2.4 Create Order Record",id:"324-create-order-record",level:4},{value:"3.2.5 Create Order Items and Update Inventory",id:"325-create-order-items-and-update-inventory",level:4},{value:"3.2.6 Deduct User Balance",id:"326-deduct-user-balance",level:4},{value:"4. Transaction Processing Considerations and Best Practices",id:"4-transaction-processing-considerations-and-best-practices",level:2},{value:"4.1 Controlling Transaction Scope and Duration",id:"41-controlling-transaction-scope-and-duration",level:3},{value:"4.2 Properly Handling Errors and Exceptions",id:"42-properly-handling-errors-and-exceptions",level:3},{value:"4.3 Database Transaction Performance Optimization",id:"43-database-transaction-performance-optimization",level:3},{value:"4.4 Transaction Processing Architectural Design",id:"44-transaction-processing-architectural-design",level:3},{value:"4.5 Multi-datasource and Multi-database Transactions",id:"45-multi-datasource-and-multi-database-transactions",level:3},{value:"5. Conclusion",id:"5-conclusion",level:2}];function d(e){let n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["When building enterprise-level applications, data consistency is fundamental to ensuring business logic correctness. When a business operation involves multiple database updates, if any step fails, we typically want to revert all changes\u2014this is the core concept of database transactions. This article will explore how to correctly implement transaction processing in the ",(0,i.jsx)(n.code,{children:"GoFrame"})," framework to ensure data consistency, providing practical examples and best practices."]}),"\n",(0,i.jsx)(n.h2,{id:"1-business-scenarios-and-necessity-of-transaction-processing",children:"1. Business Scenarios and Necessity of Transaction Processing"}),"\n",(0,i.jsx)(n.p,{children:"Transaction processing is a key mechanism for ensuring the atomicity, consistency, isolation, and durability (ACID) of database operations. Here are several typical business scenarios that require transaction processing to guarantee data consistency:"}),"\n",(0,i.jsx)(n.h3,{id:"11-financial-transfer-systems",children:"1.1 Financial Transfer Systems"}),"\n",(0,i.jsx)(n.p,{children:"The most classic transaction processing scenario is bank transfers, involving balance changes in at least two accounts:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Deducting an amount from account A"}),"\n",(0,i.jsx)(n.li,{children:"Adding an amount to account B"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These two operations must be executed as an atomic unit\u2014either both succeed or both fail. If only half is completed (for example, the deduction succeeds but the deposit fails), it will lead to lost funds or money created out of thin air, causing serious financial problems."}),"\n",(0,i.jsx)(n.h3,{id:"12-e-commerce-order-processing",children:"1.2 E-commerce Order Processing"}),"\n",(0,i.jsx)(n.p,{children:"Order creation in e-commerce platforms typically involves multiple related operations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Creating an order record"}),"\n",(0,i.jsx)(n.li,{children:"Updating product inventory"}),"\n",(0,i.jsx)(n.li,{children:"Creating payment records"}),"\n",(0,i.jsx)(n.li,{children:"Generating logistics information"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If any of these operations fail, the entire order process should be rolled back; otherwise, it may lead to overselling, inventory inconsistencies, or order status confusion."}),"\n",(0,i.jsx)(n.h3,{id:"13-user-registration-and-associated-data",children:"1.3 User Registration and Associated Data"}),"\n",(0,i.jsx)(n.p,{children:"The user registration process may involve operations across multiple tables:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Creating basic user information"}),"\n",(0,i.jsx)(n.li,{children:"Creating user preference settings"}),"\n",(0,i.jsx)(n.li,{children:"Initializing user wallet"}),"\n",(0,i.jsx)(n.li,{children:"Assigning default roles and permissions"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If any of these steps fail, the entire registration process should be rolled back to avoid incomplete user records."}),"\n",(0,i.jsx)(n.h3,{id:"14-multi-service-collaborative-operations",children:"1.4 Multi-service Collaborative Operations"}),"\n",(0,i.jsx)(n.p,{children:"In microservice architectures, a business operation may involve data changes across multiple services:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Updating user status in the user service"}),"\n",(0,i.jsx)(n.li,{children:"Creating a new order in the order service"}),"\n",(0,i.jsx)(n.li,{children:"Reducing inventory in the inventory service"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This kind of cross-service data consistency is a more complex issue, typically requiring distributed transaction solutions."}),"\n",(0,i.jsx)(n.h2,{id:"2-goframe-transaction-processing-basics",children:"2. GoFrame Transaction Processing Basics"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"GoFrame"})," framework provides a concise yet powerful transaction processing API, offering higher-level abstractions on top of standard database transactions, making transaction processing simpler and safer."]}),"\n",(0,i.jsx)(n.h3,{id:"21-basic-usage-of-goframe-transactions",children:"2.1 Basic Usage of GoFrame Transactions"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ORM"})," component of ",(0,i.jsx)(n.code,{children:"GoFrame"})," provides two ways of transaction processing:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Function callback-based transaction processing (recommended)"}),"\n",(0,i.jsx)(n.li,{children:"Manual transaction start/commit/rollback"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"211-function-callback-based-transaction-processing",children:"2.1.1 Function Callback-based Transaction Processing"}),"\n",(0,i.jsxs)(n.p,{children:["This is the recommended transaction processing method in ",(0,i.jsx)(n.code,{children:"GoFrame"}),", which automatically handles commit and rollback operations, reducing the possibility of errors:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Using the Transaction method for transaction operations\nif err := g.DB().Transaction(ctx, func(ctx context.Context, tx *gdb.TX) error {\n    // Execute transaction operations here\n\n    // For example, deduct an amount from account A\n    _, err := tx.Ctx(ctx).Model("accounts").\n        Where("id", 1).\n        Decrement("balance", 100)\n    if err != nil {\n        return err  // Returning an error will automatically trigger a rollback\n    }\n    \n    // Add an amount to account B\n    _, err = tx.Ctx(ctx).Model("accounts").\n        Where("id", 2).\n        Increment("balance", 100)\n    if err != nil {\n        return err  // Returning an error will automatically trigger a rollback\n    }\n    \n    // Returning nil indicates success and will automatically commit the transaction\n    return nil\n}); err != nil {\n    // Handle transaction error\n    return err\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"212-manual-transaction-startcommitrollback",children:"2.1.2 Manual Transaction Start/Commit/Rollback"}),"\n",(0,i.jsx)(n.p,{children:"For more fine-grained control, you can also manually manage transactions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Begin transaction\ntx, err := g.DB().Begin(ctx)\nif err != nil {\n    return err\n}\n\n// Ensure proper error handling at the end of the function\ndefer func() {\n    if err != nil {\n        tx.Rollback()\n    }\n}()\n\n// Execute transaction operations\n_, err = tx.Ctx(ctx).Model("accounts").\n    Where("id", 1).\n    Decrement("balance", 100)\nif err != nil {\n    return err\n}\n\n_, err = tx.Ctx(ctx).Model("accounts").\n    Where("id", 2).\n    Increment("balance", 100)\nif err != nil {\n    return err\n}\n\n// Commit transaction\nreturn tx.Commit()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"22-advanced-features-of-goframe-transaction-processing",children:"2.2 Advanced Features of GoFrame Transaction Processing"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ORM"})," component of ",(0,i.jsx)(n.code,{children:"GoFrame"})," provides advanced transaction processing features, such as transaction nesting and specifying transaction isolation levels."]}),"\n",(0,i.jsx)(n.h4,{id:"221-safe-transaction-nesting",children:"2.2.1 Safe Transaction Nesting"}),"\n",(0,i.jsxs)(n.p,{children:["In ",(0,i.jsx)(n.code,{children:"GoFrame"}),", transactions can be safely nested, with inner transactions automatically reusing the connection of the outer transaction:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// Outer transaction\ng.DB().Transaction(ctx, func(ctx context.Context, tx *gdb.TX) error {\n    // Operation 1\n    \n    // Nested transaction, automatically reuses the connection of the outer transaction\n    g.DB().Transaction(ctx, func(ctx context.Context, tx2 *gdb.TX) error {\n        // Operation 2\n        return nil\n    })\n    \n    // Operation 3\n    return nil\n})\n"})}),"\n",(0,i.jsx)(n.h4,{id:"222-specifying-transaction-isolation-level",children:"2.2.2 Specifying Transaction Isolation Level"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"GoFrame"})," supports setting the isolation level of transactions:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// Set isolation level to serializable\ng.DB().TransactionWithOptions(\n	ctx, \n	gdb.TransactionOptions{\n        IsolationLevel: sql.LevelSerializable,\n    }, \n	func(ctx context.Context, tx *gdb.TX) error {\n		// Transaction operations...\n		return nil\n	},\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"3-case-study-e-commerce-order-system-transaction-processing",children:"3. Case Study: E-commerce Order System Transaction Processing"}),"\n",(0,i.jsxs)(n.p,{children:["Let's demonstrate how to correctly implement transaction processing in ",(0,i.jsx)(n.code,{children:"GoFrame"})," through an e-commerce order system example. Assume we have the following data tables:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Orders table\nCREATE TABLE `orders` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'Order ID',\n  `user_id` bigint NOT NULL COMMENT 'User ID',\n  `total_amount` decimal(10,2) NOT NULL COMMENT 'Total order amount',\n  `status` varchar(20) NOT NULL COMMENT 'Order status',\n  `created_at` datetime NOT NULL COMMENT 'Creation time',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='Main orders table';\n\n-- Order items table\nCREATE TABLE `order_items` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'Order item ID',\n  `order_id` bigint NOT NULL COMMENT 'Order ID',\n  `product_id` bigint NOT NULL COMMENT 'Product ID',\n  `quantity` int NOT NULL COMMENT 'Purchase quantity',\n  `price` decimal(10,2) NOT NULL COMMENT 'Product unit price',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='Order items table';\n\n-- Products table\nCREATE TABLE `products` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'Product ID',\n  `name` varchar(100) NOT NULL COMMENT 'Product name',\n  `price` decimal(10,2) NOT NULL COMMENT 'Product price',\n  `stock` int NOT NULL COMMENT 'Inventory quantity',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='Products table';\n\n-- Users table\nCREATE TABLE `users` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'User ID',\n  `name` varchar(50) NOT NULL COMMENT 'Username',\n  `balance` decimal(10,2) NOT NULL COMMENT 'Account balance',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='Users table';\n"})}),"\n",(0,i.jsx)(n.h3,{id:"31-defining-models-and-services",children:"3.1 Defining Models and Services"}),"\n",(0,i.jsx)(n.p,{children:"First, we define the necessary models and service interfaces (showing only core code):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// entity/orders.go - Order model\ntype Order struct {\n    Id          int64       // Order ID\n    UserId      int64       // User ID\n    TotalAmount float64     // Total order amount\n    Status      string      // Order status\n    CreatedAt   *gtime.Time // Creation time\n}\n\n// entity/order_items.go - Order item model\ntype OrderItem struct {\n    Id        int64   // Order item ID\n    OrderId   int64   // Order ID\n    ProductId int64   // Product ID\n    Quantity  int     // Purchase quantity\n    Price     float64 // Product unit price\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// internal/logic/order/order.go\n\n// OrderItemInput Order input model\ntype OrderItemInput struct {\n    ProductId int64 // Product ID\n    Quantity  int   // Purchase quantity\n}\n\n// OrderService Order service interface\ntype OrderService interface {\n    // Create order\n    CreateOrder(\n		ctx context.Context, userId int64, items []model.OrderItemInput,\n	) (orderId int64, err error)\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"32-implementing-service-logic-with-transaction-processing",children:"3.2 Implementing Service Logic with Transaction Processing"}),"\n",(0,i.jsx)(n.p,{children:"Below is the service implementation for creating an order with complete transaction processing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// internal/logic/order/order.go\ntype orderService struct{\n	db *gdb.DB\n}\n\n// Create order method implementation\nfunc (s *orderService) CreateOrder(\n	ctx context.Context, userId int64, items []model.OrderItemInput,\n) (orderId int64, err error) {\n    // Validation logic outside the transaction\n    // ...code for validating user existence omitted...\n\n    // Use transaction processing for the entire order creation process\n    err = s.db.Transaction(ctx, func(ctx context.Context, tx *gdb.TX) error {\n        // Core transaction logic will be implemented in sections below\n        return s.executeOrderTransaction(ctx, userId, items, &orderId)\n    })\n    \n    return orderId, err\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"We break down the transaction logic into multiple steps, each implementing a core function:"}),"\n",(0,i.jsx)(n.h4,{id:"321-core-process",children:"3.2.1 Core Process"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// Execute the core logic of the order transaction\nfunc (s *orderService) executeOrderTransaction(\n	ctx context.Context, userId int64, items []model.OrderItemInput, orderId int64,\n) error {\n    // 1. Calculate order amount and validate inventory\n    totalAmount, err := s.calculateTotalAndValidateStock(ctx, items)\n    if err != nil {\n        return err\n    }\n    \n    // 2. Validate user balance\n    if err := s.validateUserBalance(ctx, userId, totalAmount); err != nil {\n        return err\n    }\n    \n    // 3. Create order record\n    orderId, err := s.createOrderRecord(ctx, userId, totalAmount)\n    if err != nil {\n        return err\n    }\n\n    // 4. Create order items and update inventory\n    if err := s.createOrderItemsAndUpdateStock(ctx, orderId, items); err != nil {\n        return err\n    }\n    \n    // 5. Deduct user balance\n    if err := s.deductUserBalance(ctx, userId, totalAmount); err != nil {\n        return err\n    }\n    \n    return nil\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"322-calculate-order-amount-and-validate-inventory",children:"3.2.2 Calculate Order Amount and Validate Inventory"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Calculate order amount and validate inventory\nfunc (s *orderService) calculateTotalAndValidateStock(\n	ctx context.Context, items []model.OrderItemInput,\n) (float64, error) {\n    var totalAmount float64 = 0\n    for _, item := range items {\n        // Check product inventory\n        productStock, err := s.db.Ctx(ctx).Model("products").\n            Where("id", item.ProductId).\n            Value("stock")\n        if err != nil {\n            return 0, err\n        }\n        if productStock.Int() < item.Quantity {\n            return 0, gerror.Newf("insufficient stock for product: %d", item.ProductId)\n        }\n        \n        // Get product price and accumulate amount\n        productPrice, err := s.db.Ctx(ctx).Model("products").\n            Where("id", item.ProductId).\n            Value("price")\n        if err != nil {\n            return 0, err\n        }\n        totalAmount += productPrice.Float64() * float64(item.Quantity)\n    }\n    \n    return totalAmount, nil\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"323-validate-user-balance",children:"3.2.3 Validate User Balance"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Validate user balance\nfunc (s *orderService) validateUserBalance(\n	ctx context.Context, userId int64, totalAmount float64,\n) error {\n    userBalance, err := s.db.Ctx(ctx).Model("users").\n        Where("id", userId).\n        Value("balance")\n    if err != nil {\n        return err\n    }\n    if userBalance.Float64() < totalAmount {\n        return gerror.New("insufficient balance")\n    }\n    return nil\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"324-create-order-record",children:"3.2.4 Create Order Record"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Create order record\nfunc (s *orderService) createOrderRecord(\n	ctx context.Context, userId int64, totalAmount float64,\n) (int64, error) {\n    orderId, err := s.db.Ctx(ctx).Model("orders").\n        Data(g.Map{\n            "user_id":      userId,\n            "total_amount": totalAmount,\n            "status":      "pending",\n            "created_at":   gtime.Now(),\n        }).\n        InsertAndGetId()\n    if err != nil {\n        return 0, err\n    }\n    return orderId, nil\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"325-create-order-items-and-update-inventory",children:"3.2.5 Create Order Items and Update Inventory"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Create order items and update inventory\nfunc (s *orderService) createOrderItemsAndUpdateStock(\n	ctx context.Context, orderId int64, items []model.OrderItemInput,\n) error {\n    for _, item := range items {\n        // Get product price\n        productPrice, err := s.db.Ctx(ctx).Model("products").\n            Where("id", item.ProductId).\n            Value("price")\n        if err != nil {\n            return err\n        }\n        // Create order item\n        _, err = s.db.Ctx(ctx).Model("order_items").\n            Data(g.Map{\n                "order_id":   orderId,\n                "product_id": item.ProductId,\n                "quantity":   item.Quantity,\n                "price":      productPrice.Float64(),\n            }).\n            Insert()\n        if err != nil {\n            return err\n        }\n        // Update product inventory\n        _, err = s.db.Ctx(ctx).Model("products").\n            Where("id", item.ProductId).\n            Decrement("stock", item.Quantity)\n        if err != nil {\n            return err\n        }\n    }\n    \n    return nil\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"326-deduct-user-balance",children:"3.2.6 Deduct User Balance"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Deduct user balance\nfunc (s *orderService) deductUserBalance(\n	ctx context.Context, userId int64, totalAmount float64,\n) error {\n    _, err := s.db.Ctx(ctx).Model("users").\n        Where("id", userId).\n        Decrement("balance", totalAmount)\n    return err\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The above code completes the following transaction operations:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Calculate order amount and validate inventory"}),"\n",(0,i.jsx)(n.li,{children:"Validate user balance"}),"\n",(0,i.jsx)(n.li,{children:"Create main order record"}),"\n",(0,i.jsx)(n.li,{children:"Create order items and update product inventory"}),"\n",(0,i.jsx)(n.li,{children:"Deduct user balance"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If any of these steps fail, the entire order creation process will be rolled back, ensuring data consistency."}),"\n",(0,i.jsx)(n.h2,{id:"4-transaction-processing-considerations-and-best-practices",children:"4. Transaction Processing Considerations and Best Practices"}),"\n",(0,i.jsxs)(n.p,{children:["Overreliance on transactions can lead to performance issues, deadlocks, and increased application complexity. Below are some fundamental principles and best practices to consider when using transactions in ",(0,i.jsx)(n.code,{children:"GoFrame"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"41-controlling-transaction-scope-and-duration",children:"4.1 Controlling Transaction Scope and Duration"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Minimize transaction scope"}),": Only include database operations that must be executed as atomic units in transactions. Don't include external service requests, HTTP calls, or unnecessary redundant operations."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Keep transactions concise"}),": Transactions should be short and focused, as longer transactions increase lock duration and affect concurrency."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// Good practice: Only perform necessary database operations within transactions\ng.DB().Transaction(ctx, func(ctx context.Context, tx *gdb.TX) error {\n	// Preparation work (such as parameter validation, data preparation) should be done outside the transaction\n	\n	// Only execute necessary database operations within the transaction\n	return nil\n})\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"42-properly-handling-errors-and-exceptions",children:"4.2 Properly Handling Errors and Exceptions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Always check errors"}),": Check for errors after each database operation and return errors to trigger rollbacks when errors occur."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Avoid panics whenever possible"}),": Uncaught ",(0,i.jsx)(n.code,{children:"panic"}),"s in transactions can lead to connection leaks or database locks being held. In function callback-based transactions, ",(0,i.jsx)(n.code,{children:"GoFrame"})," automatically handles ",(0,i.jsx)(n.code,{children:"panic"}),"s and rolls back transactions, but in manual transaction mode, use ",(0,i.jsx)(n.code,{children:"defer"})," and ",(0,i.jsx)(n.code,{children:"recover"})," to ensure proper cleanup."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// Proper error and panic handling in manual transactions\ntx, err := g.DB().Begin(ctx)\nif err != nil {\n	return err\n}\n\n// Use defer to ensure transaction connections are always properly handled\ndefer func() {\n	if p := recover(); p != nil {\n		tx.Rollback()\n		panic(p) // Optional re-throw or handle panic\n	} else if err != nil {\n		tx.Rollback()\n	}\n}()\n\n// Execute transaction operations\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"43-database-transaction-performance-optimization",children:"4.3 Database Transaction Performance Optimization"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Choose appropriate isolation levels"}),": Select isolation levels based on business requirements; higher isolation levels affect concurrent performance."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Isolation Level"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Description"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Characteristics"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Application Scenarios"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"READ UNCOMMITTED"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Lowest isolation level"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"No locks, dirty read issues"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Report queries with low data consistency requirements"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"READ COMMITTED"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Medium isolation level"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Prevents dirty reads, non-repeatable reads and phantom reads exist"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"General transaction processing"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"REPEATABLE READ"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"MySQL default isolation level"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Prevents dirty reads and non-repeatable reads, phantom reads exist"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Business requiring consistent reads"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"SERIALIZABLE"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Highest isolation level"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Complete serialization, prevents all concurrency issues"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Financial and high-security requirement scenarios"})]})]})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Avoid long transactions"}),": Long transactions not only hold database locks but can also cause record issues. Consider splitting a large transaction into multiple smaller ones, or use distributed transactions."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Optimize lock strategies"}),": Proper lock strategies can significantly improve transaction concurrency performance."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use optimistic locking"}),": In scenarios with low conflict probability, use version numbers or timestamps for optimistic lock control to avoid long-term locking."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Optimistic locking example\nfunc UpdateWithOptimisticLock(ctx context.Context, id int, data g.Map) error {\n	// Query current version\n	version, err := g.DB().Ctx(ctx).\n		Model("products").\n		Where("id", id).\n		Value("version")\n	if err != nil {\n		return err\n	}\n	\n	// Use version number condition for updating\n	data["version"] = version.Int() + 1\n	result, err := g.DB().Ctx(ctx).\n		Model("products").\n		Where("id", id).\n		Where("version", version.Int()).\n		Data(data).\n		Update()\n	if err != nil {\n		return err\n	}\n	\n	// Check if update was successful\n	if result.RowsAffected() == 0 {\n		return gerror.New("data has been modified by another user, please refresh and try again")\n	}\n	return nil\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Fine-grained lock granularity"}),": Lock the smallest possible range of data, use row locks instead of table locks, and minimize lock duration as much as possible."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Logical query order"}),": When accessing multiple tables in a transaction, maintain a consistent access order to reduce deadlock risks."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"44-transaction-processing-architectural-design",children:"4.4 Transaction Processing Architectural Design"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Layered design"}),": Centralize transaction logic in the service layer, rather than dispersing it across multiple controllers or application components."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// Implement transaction logic in the service layer\n// internal/logic/order/order.go\nfunc (s *orderService) CreateOrder(ctx context.Context, input *model.CreateOrderInput) error {\n	return s.db.Transaction(ctx, func(ctx context.Context, tx *gdb.TX) error {\n		// ... Complete transaction logic\n		return nil\n	})\n}\n\n// Call the service in the controller\n// internal/controller/order/order.go\nfunc (c *orderController) Create(ctx context.Context, req *v1.CreateOrderReq)(res *v1.CreateOrderRes, err error) {\n	// Call the service containing transaction logic\n	if err := c.service.CreateOrder(ctx, &model.CreateOrderInput{\n		// ... Parameter binding\n	}); err != nil {\n		// ... Error handling\n	}\n	// ... Response handling\n}\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Addressing distributed transactions"}),": When transactions need to span microservices or databases, consider using reliable message queues, event-driven patterns, or the ",(0,i.jsx)(n.code,{children:"SAGA"})," pattern."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Using transaction nesting judiciously"}),": Complex transaction nesting can lead to code maintenance difficulties and logical confusion. In ",(0,i.jsx)(n.code,{children:"GoFrame"}),', inner nested transactions automatically reuse the connection of the outer transaction (called "virtual nesting"), not creating true nested transactions. While this mechanism is technically safe, clear transaction boundaries and responsibility divisions should still be maintained.']}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"45-multi-datasource-and-multi-database-transactions",children:"4.5 Multi-datasource and Multi-database Transactions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Resource localization principle"}),": Try to ensure related data is in the same database to facilitate local transactions."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"For necessary cross-database scenarios"}),": In cases requiring cross-database transactions, consider:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Distributed transaction coordinators (",(0,i.jsx)(n.code,{children:"XA"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Compensating transactions (",(0,i.jsx)(n.code,{children:"SAGA"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Message-based eventual consistency solutions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// A simplified message-driven cross-database transaction example\n\n// 1. First phase of business operation\nfunc createOrderFirstPhase(ctx context.Context, input *model.OrderInput) (int64, error) {\n	var orderId int64\n	err := g.DB("db1").Transaction(ctx, func(ctx context.Context, tx *gdb.TX) error {\n		// Create order record\n		result, err := tx.Insert("orders", g.Map{/*...*/})\n		if err != nil {\n			return err\n		}\n		orderId, err = result.LastInsertId()\n		if err != nil {\n			return err\n		}\n		\n		// Send message to trigger next phase\n		return mqClient.Send("order_created", &message.OrderCreated{\n			OrderId: orderId,\n			// Other data...\n		})\n	})\n	return orderId, err\n}\n\n// 2. Listen for messages to process the next phase\nfunc handleOrderCreated(msg *message.OrderCreated) error {\n	return g.DB("db2").Transaction(ctx, func(ctx context.Context, tx *gdb.TX) error {\n		// Process inventory and other database operations\n		\n		// If successful, can also send messages for the next step\n		return nil \n	})\n}\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"5-conclusion",children:"5. Conclusion"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"GoFrame"})," framework provides flexible and powerful transaction processing capabilities, enabling developers to ensure data consistency while avoiding common pitfalls. By following the best practices in this article, you will be able to better utilize transactions in practical applications and build robust applications with high data consistency guarantees."]}),"\n",(0,i.jsx)(n.p,{children:"Remember, good transaction design should achieve balance in the following aspects:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Appropriate scope"}),": Only include necessary operations in transactions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compact duration"}),": Reduce transaction duration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Correct isolation level"}),": Choose based on business scenarios"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robust error handling"}),": Always check and handle errors"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Clear layered design"}),": Centralize transaction logic in the service layer"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Through proper transaction handling, your application will be able to find an appropriate balance between concurrency, scalability, and data security."})]})}function u(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},250065:function(e,n,r){r.d(n,{Z:function(){return o},a:function(){return a}});var t=r(667294);let i={},s=t.createContext(i);function a(e){let n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);