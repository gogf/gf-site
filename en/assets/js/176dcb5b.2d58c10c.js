"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["1698"],{634275:function(e,n,t){t.r(n),t.d(n,{metadata:()=>a,contentTitle:()=>l,default:()=>u,assets:()=>o,toc:()=>c,frontMatter:()=>s});var a=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u4E8B\u52A1\u5904\u7406/ORM\u4E8B\u52A1\u5904\u7406-\u9694\u79BB\u7EA7\u522B","title":"ORM Transactions - Isolation Levels","description":"A comprehensive guide to GoFrame ORM transaction isolation levels, including basic concepts, characteristics of different isolation levels, advantages and application scenarios, as well as code examples and practical use cases in GoFrame.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u4E8B\u52A1\u5904\u7406/ORM\u4E8B\u52A1\u5904\u7406-\u9694\u79BB\u7EA7\u522B.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u4E8B\u52A1\u5904\u7406","slug":"/docs/core/gdb-transaction-isolation-level","permalink":"/en/docs/core/gdb-transaction-isolation-level","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u4E8B\u52A1\u5904\u7406/ORM\u4E8B\u52A1\u5904\u7406-\u9694\u79BB\u7EA7\u522B.md","tags":[],"version":"current","lastUpdatedBy":"John Guo","lastUpdatedAt":1742194305000,"sidebarPosition":5000,"frontMatter":{"slug":"/docs/core/gdb-transaction-isolation-level","title":"ORM Transactions - Isolation Levels","sidebar_position":5000,"hide_title":true,"keywords":["Transaction","Isolation Level","ORM","Database","Dirty Read","Non-repeatable Read","Phantom Read","Read Uncommitted","Read Committed","Repeatable Read","Serializable"],"description":"A comprehensive guide to GoFrame ORM transaction isolation levels, including basic concepts, characteristics of different isolation levels, advantages and application scenarios, as well as code examples and practical use cases in GoFrame."},"sidebar":"mainSidebar","previous":{"title":"ORM Transactions - Propagation","permalink":"/en/docs/core/gdb-transaction-propagation"},"next":{"title":"ORM Transactions - Read-Only Mode","permalink":"/en/docs/core/gdb-transaction-readonly"}}'),i=t("785893"),r=t("250065");let s={slug:"/docs/core/gdb-transaction-isolation-level",title:"ORM Transactions - Isolation Levels",sidebar_position:5e3,hide_title:!0,keywords:["Transaction","Isolation Level","ORM","Database","Dirty Read","Non-repeatable Read","Phantom Read","Read Uncommitted","Read Committed","Repeatable Read","Serializable"],description:"A comprehensive guide to GoFrame ORM transaction isolation levels, including basic concepts, characteristics of different isolation levels, advantages and application scenarios, as well as code examples and practical use cases in GoFrame."},l=void 0,o={},c=[{value:"Basic Concepts",id:"basic-concepts",level:2},{value:"Types of Isolation Levels",id:"types-of-isolation-levels",level:2},{value:"Advantages and Application Scenarios",id:"advantages-and-application-scenarios",level:2},{value:"Read Uncommitted",id:"read-uncommitted",level:3},{value:"Read Committed",id:"read-committed",level:3},{value:"Repeatable Read",id:"repeatable-read",level:3},{value:"Serializable",id:"serializable",level:3},{value:"Using Transaction Isolation Levels in GoFrame",id:"using-transaction-isolation-levels-in-goframe",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Examples Using Different Isolation Levels",id:"examples-using-different-isolation-levels",level:3},{value:"Read Committed",id:"read-committed-1",level:4},{value:"Repeatable Read",id:"repeatable-read-1",level:4},{value:"Serializable",id:"serializable-1",level:4},{value:"Using Transaction Closure Functions",id:"using-transaction-closure-functions",level:3},{value:"Practical Application Examples",id:"practical-application-examples",level:2},{value:"Example 1: Bank Transfer (Repeatable Read)",id:"example-1-bank-transfer-repeatable-read",level:3},{value:"Example 2: Inventory Management (Read Committed)",id:"example-2-inventory-management-read-committed",level:3},{value:"Example 3: Concurrent Data Analysis (Read Uncommitted)",id:"example-3-concurrent-data-analysis-read-uncommitted",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){let n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Transaction isolation level is an important feature of database transaction processing that defines the degree to which one transaction may be affected by other concurrent transactions. The ",(0,i.jsx)(n.code,{children:"GoFrame ORM"})," component supports standard ",(0,i.jsx)(n.code,{children:"SQL"})," transaction isolation levels, allowing developers to choose appropriate isolation levels based on application requirements."]}),"\n",(0,i.jsx)(n.h2,{id:"basic-concepts",children:"Basic Concepts"}),"\n",(0,i.jsx)(n.p,{children:"Transaction isolation levels primarily address the following issues that may occur during concurrent transaction execution:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dirty Read"}),": A transaction reads data that has been modified by another transaction that has not yet been committed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Non-repeatable Read"}),": Within the same transaction, multiple reads of the same data return different results."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phantom Read"}),": Within the same transaction, multiple executions of the same query return different data sets (row count changes)."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"types-of-isolation-levels",children:"Types of Isolation Levels"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"GoFrame ORM"})," supports the following standard transaction isolation levels:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Isolation Level"}),(0,i.jsx)(n.th,{children:"Dirty Read"}),(0,i.jsx)(n.th,{children:"Non-repeatable Read"}),(0,i.jsx)(n.th,{children:"Phantom Read"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Read Uncommitted"}),(0,i.jsx)(n.td,{children:"Possible"}),(0,i.jsx)(n.td,{children:"Possible"}),(0,i.jsx)(n.td,{children:"Possible"}),(0,i.jsx)(n.td,{children:"Lowest isolation level, allows reading uncommitted data changes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Read Committed"}),(0,i.jsx)(n.td,{children:"Not possible"}),(0,i.jsx)(n.td,{children:"Possible"}),(0,i.jsx)(n.td,{children:"Possible"}),(0,i.jsx)(n.td,{children:"Only allows reading data that has been committed"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Repeatable Read"}),(0,i.jsx)(n.td,{children:"Not possible"}),(0,i.jsx)(n.td,{children:"Not possible"}),(0,i.jsx)(n.td,{children:"Possible"}),(0,i.jsx)(n.td,{children:"MySQL's default level, ensures consistent data reads within the same transaction"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Serializable"}),(0,i.jsx)(n.td,{children:"Not possible"}),(0,i.jsx)(n.td,{children:"Not possible"}),(0,i.jsx)(n.td,{children:"Not possible"}),(0,i.jsx)(n.td,{children:"Highest isolation level, completely serialized execution"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"advantages-and-application-scenarios",children:"Advantages and Application Scenarios"}),"\n",(0,i.jsx)(n.p,{children:"Different isolation levels are suitable for different application scenarios:"}),"\n",(0,i.jsx)(n.h3,{id:"read-uncommitted",children:"Read Uncommitted"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Best performance, no lock overhead"}),"\n",(0,i.jsx)(n.li,{children:"Highest concurrency"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Application Scenarios"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Scenarios with extremely low data consistency requirements"}),"\n",(0,i.jsx)(n.li,{children:"Read-only statistical analysis that allows for some imprecise data"}),"\n",(0,i.jsx)(n.li,{children:"High-performance requirements where data inconsistency can be tolerated"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"read-committed",children:"Read Committed"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Avoids dirty read issues"}),"\n",(0,i.jsx)(n.li,{children:"Good concurrent performance"}),"\n",(0,i.jsx)(n.li,{children:"Default level for most databases"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Application Scenarios"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Scenarios that need to avoid dirty reads but can accept non-repeatable reads"}),"\n",(0,i.jsx)(n.li,{children:"Read-heavy applications"}),"\n",(0,i.jsx)(n.li,{children:"Scenarios with moderate consistency requirements but also concerned with performance"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"repeatable-read",children:"Repeatable Read"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Avoids dirty reads and non-repeatable reads"}),"\n",(0,i.jsx)(n.li,{children:"MySQL's default isolation level"}),"\n",(0,i.jsx)(n.li,{children:"Ensures data read consistency within the same transaction"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Application Scenarios"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Scenarios requiring multiple consistent reads within a transaction"}),"\n",(0,i.jsx)(n.li,{children:"Financial applications"}),"\n",(0,i.jsx)(n.li,{children:"Business logic with higher data consistency requirements"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"serializable",children:"Serializable"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Completely avoids concurrency issues"}),"\n",(0,i.jsx)(n.li,{children:"Provides the highest level of data consistency guarantee"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Application Scenarios"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Critical business operations with extremely high data consistency requirements"}),"\n",(0,i.jsx)(n.li,{children:"Core financial transactions such as bank transfers"}),"\n",(0,i.jsx)(n.li,{children:"Scenarios where data integrity is more important than performance"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"using-transaction-isolation-levels-in-goframe",children:"Using Transaction Isolation Levels in GoFrame"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"GoFrame ORM"})," supports setting transaction isolation levels through the ",(0,i.jsx)(n.code,{children:"TxOptions"})," struct. Here are examples using different isolation levels:"]}),"\n",(0,i.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Start a transaction with a specific isolation level\ntx, err := db.BeginWithOptions(ctx, gdb.TxOptions{\n    Isolation: sql.LevelReadCommitted,\n})\nif err != nil {\n    // Handle error\n    return\n}\n// Ensure the transaction will eventually be committed or rolled back\ndefer func() {\n    if err := recover(); err != nil {\n        tx.Rollback()\n        panic(err)\n    }\n}()\n\n// Execute transaction operations\n_, err = tx.Insert(ctx, "user", g.Map{"name": "john"})\n// SQL: INSERT INTO user(name) VALUES(\'john\')\n\n// Commit the transaction\nif err = tx.Commit(); err != nil {\n    // Handle error\n    tx.Rollback()\n    return\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"examples-using-different-isolation-levels",children:"Examples Using Different Isolation Levels"}),"\n",(0,i.jsx)(n.h4,{id:"read-committed-1",children:"Read Committed"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Use Read Committed isolation level\ntx, err := db.BeginWithOptions(ctx, gdb.TxOptions{\n    Isolation: sql.LevelReadCommitted,\n})\nif err != nil {\n    return\n}\ndefer tx.Rollback()\n\n// Query user balance\nbalance, err := tx.Model("account").Where("user_id", 1).Value("balance")\n// SQL: SELECT balance FROM account WHERE user_id=1\n\n// Update balance\n_, err = tx.Model("account").Where("user_id", 1).Update(g.Map{"balance": balance.Int() + 100})\n// SQL: UPDATE account SET balance=balance+100 WHERE user_id=1\n\nif err = tx.Commit(); err != nil {\n    return\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"repeatable-read-1",children:"Repeatable Read"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Use Repeatable Read isolation level (MySQL default)\ntx, err := db.BeginWithOptions(ctx, gdb.TxOptions{\n    Isolation: sql.LevelRepeatableRead,\n})\nif err != nil {\n    return\n}\ndefer tx.Rollback()\n\n// First query for user data\nuser1, err := tx.Model("user").Where("id", 1).One()\n// SQL: SELECT * FROM user WHERE id=1\n\n// ... other operations\n\n// Second query for the same user data\n// With Repeatable Read, even if other transactions have modified this data,\n// the result here will be the same as the first query\nuser2, err := tx.Model("user").Where("id", 1).One()\n// SQL: SELECT * FROM user WHERE id=1\n\nif err = tx.Commit(); err != nil {\n    return\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"serializable-1",children:"Serializable"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Use Serializable isolation level\ntx, err := db.BeginWithOptions(ctx, gdb.TxOptions{\n    Isolation: sql.LevelSerializable,\n})\nif err != nil {\n    return\n}\ndefer tx.Rollback()\n\n// Query all users matching the condition\nusers, err := tx.Model("user").Where("status", "active").All()\n// SQL: SELECT * FROM user WHERE status=\'active\'\n\n// At the Serializable level, other transactions cannot simultaneously modify or add records\n// that match this condition, ensuring query result consistency during transaction execution\n\nif err = tx.Commit(); err != nil {\n    return\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"using-transaction-closure-functions",children:"Using Transaction Closure Functions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"GoFrame ORM"})," also provides convenient transaction closure functions that can specify isolation levels:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'err := db.TransactionWithOptions(ctx, gdb.TxOptions{\n    Isolation: sql.LevelSerializable,\n}, func(ctx context.Context, tx gdb.TX) error {\n    // Execute transaction operations\n    _, err := tx.Insert("user", g.Map{"name": "john"})\n    if err != nil {\n        return err\n    }\n    \n    // All operations will be automatically committed if no error is returned\n    // or rolled back if an error is returned\n    return nil\n})\n'})}),"\n",(0,i.jsx)(n.h2,{id:"practical-application-examples",children:"Practical Application Examples"}),"\n",(0,i.jsx)(n.h3,{id:"example-1-bank-transfer-repeatable-read",children:"Example 1: Bank Transfer (Repeatable Read)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    _ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n    "context"\n    "database/sql"\n    "fmt"\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/frame/g"\n)\n\nfunc main() {\n    ctx := context.Background()\n    db := g.DB()\n    \n    // Transfer money from account A to account B\n    err := db.TransactionWithOptions(ctx, gdb.TxOptions{\n        Isolation: sql.LevelRepeatableRead, // Use Repeatable Read for financial transactions\n    }, func(ctx context.Context, tx gdb.TX) error {\n        // Get account A balance\n        balanceA, err := tx.Model("account").Where("id", 1).Value("balance")\n        if err != nil {\n            return err\n        }\n        \n        // Check if account A has sufficient funds\n        if balanceA.Int() < 100 {\n            return fmt.Errorf("insufficient funds")\n        }\n        \n        // Deduct from account A\n        _, err = tx.Model("account").Where("id", 1).Update(g.Map{\n            "balance": gdb.Raw("balance - 100"),\n        })\n        if err != nil {\n            return err\n        }\n        \n        // Add to account B\n        _, err = tx.Model("account").Where("id", 2).Update(g.Map{\n            "balance": gdb.Raw("balance + 100"),\n        })\n        if err != nil {\n            return err\n        }\n        \n        // Record the transaction\n        _, err = tx.Insert("transaction_log", g.Map{\n            "from_account": 1,\n            "to_account": 2,\n            "amount": 100,\n            "time": gdb.Raw("NOW()"),\n        })\n        \n        return err\n    })\n    \n    if err != nil {\n        fmt.Println("Transfer failed:", err)\n        return\n    }\n    \n    fmt.Println("Transfer completed successfully")\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"example-2-inventory-management-read-committed",children:"Example 2: Inventory Management (Read Committed)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    _ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n    "context"\n    "database/sql"\n    "fmt"\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/frame/g"\n)\n\nfunc main() {\n    ctx := context.Background()\n    db := g.DB()\n    \n    // Process an order\n    err := db.TransactionWithOptions(ctx, gdb.TxOptions{\n        Isolation: sql.LevelReadCommitted, // Use Read Committed for inventory management\n    }, func(ctx context.Context, tx gdb.TX) error {\n        // Check product inventory\n        inventory, err := tx.Model("product").Where("id", 101).Value("inventory")\n        if err != nil {\n            return err\n        }\n        \n        // Check if inventory is sufficient\n        if inventory.Int() < 1 {\n            return fmt.Errorf("product out of stock")\n        }\n        \n        // Reduce inventory\n        _, err = tx.Model("product").Where("id", 101).Update(g.Map{\n            "inventory": gdb.Raw("inventory - 1"),\n            "sales": gdb.Raw("sales + 1"),\n        })\n        if err != nil {\n            return err\n        }\n        \n        // Create order\n        _, err = tx.Insert("order", g.Map{\n            "product_id": 101,\n            "user_id": 1001,\n            "quantity": 1,\n            "status": "created",\n            "create_time": gdb.Raw("NOW()"),\n        })\n        \n        return err\n    })\n    \n    if err != nil {\n        fmt.Println("Order processing failed:", err)\n        return\n    }\n    \n    fmt.Println("Order processed successfully")\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"example-3-concurrent-data-analysis-read-uncommitted",children:"Example 3: Concurrent Data Analysis (Read Uncommitted)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    _ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n    "context"\n    "database/sql"\n    "fmt"\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/frame/g"\n)\n\nfunc main() {\n    ctx := context.Background()\n    db := g.DB()\n    \n    // Generate statistical report\n    err := db.TransactionWithOptions(ctx, gdb.TxOptions{\n        Isolation: sql.LevelReadUncommitted, // Use Read Uncommitted for statistical analysis\n    }, func(ctx context.Context, tx gdb.TX) error {\n        // Get total sales\n        sales, err := tx.Model("product").Sum("sales")\n        if err != nil {\n            return err\n        }\n        \n        // Get average price\n        avgPrice, err := tx.Model("product").Avg("price")\n        if err != nil {\n            return err\n        }\n        \n        // Get product count\n        count, err := tx.Model("product").Count()\n        if err != nil {\n            return err\n        }\n        \n        // Save report\n        _, err = tx.Insert("sales_report", g.Map{\n            "total_sales": sales,\n            "avg_price": avgPrice,\n            "product_count": count,\n            "create_time": gdb.Raw("NOW()"),\n        })\n        \n        return err\n    })\n    \n    if err != nil {\n        fmt.Println("Report generation failed:", err)\n        return\n    }\n    \n    fmt.Println("Report generated successfully")\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"Choosing the right transaction isolation level is a balance between data consistency and performance. In real-world applications, it's recommended to select an appropriate isolation level based on specific business scenario requirements:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'For general web applications, "Read Committed" is usually a good choice'}),"\n",(0,i.jsx)(n.li,{children:'For financial and order processing, "Repeatable Read" provides better data consistency guarantees'}),"\n",(0,i.jsx)(n.li,{children:'For extremely important financial transactions, "Serializable" can be considered, but be aware of the performance impact'}),"\n"]})]})}function u(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return l},a:function(){return s}});var a=t(667294);let i={},r=a.createContext(i);function s(e){let n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);