"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["51116"],{739009:function(e,n,c){c.r(n),c.d(n,{metadata:()=>t,contentTitle:()=>a,default:()=>d,assets:()=>s,toc:()=>l,frontMatter:()=>o});var t=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u7F13\u5B58\u7BA1\u7406/\u7F13\u5B58\u7BA1\u7406-\u5185\u5B58\u7F13\u5B58","title":"Caching - In-Memory","description":"Using in-memory caching with the GoFrame framework for efficient cache management, including basic usage, expiration control, the use of GetOrSetFunc functions, and LRU cache eviction control. Through example code, it demonstrates how to set caches, retrieve cache values, and perform concurrency control, aiming to help users optimize program performance.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u7F13\u5B58\u7BA1\u7406/\u7F13\u5B58\u7BA1\u7406-\u5185\u5B58\u7F13\u5B58.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u7F13\u5B58\u7BA1\u7406","slug":"/docs/core/gcache-memory","permalink":"/en/docs/core/gcache-memory","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u7F13\u5B58\u7BA1\u7406/\u7F13\u5B58\u7BA1\u7406-\u5185\u5B58\u7F13\u5B58.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732440306000,"sidebarPosition":1,"frontMatter":{"slug":"/docs/core/gcache-memory","title":"Caching - In-Memory","sidebar_position":1,"hide_title":true,"keywords":["GoFrame","GoFrame Framework","Cache Management","In-Memory Cache","Efficient Caching","gcache","Go Language","Performance Optimization","LRU Eviction","Concurrency Control"],"description":"Using in-memory caching with the GoFrame framework for efficient cache management, including basic usage, expiration control, the use of GetOrSetFunc functions, and LRU cache eviction control. Through example code, it demonstrates how to set caches, retrieve cache values, and perform concurrency control, aiming to help users optimize program performance."},"sidebar":"mainSidebar","previous":{"title":"Caching - Interface","permalink":"/en/docs/core/gcache-interface"},"next":{"title":"Caching - Redis","permalink":"/en/docs/core/gcache-redis"}}'),r=c("785893"),i=c("250065");let o={slug:"/docs/core/gcache-memory",title:"Caching - In-Memory",sidebar_position:1,hide_title:!0,keywords:["GoFrame","GoFrame Framework","Cache Management","In-Memory Cache","Efficient Caching","gcache","Go Language","Performance Optimization","LRU Eviction","Concurrency Control"],description:"Using in-memory caching with the GoFrame framework for efficient cache management, including basic usage, expiration control, the use of GetOrSetFunc functions, and LRU cache eviction control. Through example code, it demonstrates how to set caches, retrieve cache values, and perform concurrency control, aiming to help users optimize program performance."},a=void 0,s={},l=[{value:"Usage Example",id:"usage-example",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Expiration Control",id:"expiration-control",level:3},{value:"<code>GetOrSetFunc*</code>",id:"getorsetfunc",level:3},{value:"<code>LRU</code> Cache Eviction Control",id:"lru-cache-eviction-control",level:3},{value:"Performance Testing",id:"performance-testing",level:2},{value:"Test Environment",id:"test-environment",level:3},{value:"Test Results",id:"test-results",level:3}];function h(e){let n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The caching component by default provides a high-speed in-memory cache, with operation efficiency at the ",(0,r.jsx)(n.code,{children:"ns"})," nanosecond level of CPU performance loss."]}),"\n",(0,r.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,r.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "github.com/gogf/gf/v2/os/gcache"\n    "github.com/gogf/gf/v2/os/gctx"\n)\n\nfunc main() {\n    // Create a cache object,\n    // but you can also conveniently use the gcache package methods directly\n    var (\n        ctx   = gctx.New()\n        cache = gcache.New()\n    )\n\n    // Set cache, no expiration\n    err := cache.Set(ctx, "k1", "v1", 0)\n    if err != nil {\n        panic(err)\n    }\n\n    // Get cache value\n    value, err := cache.Get(ctx, "k1")\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(value)\n\n    // Get cache size\n    size, err := cache.Size(ctx)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(size)\n\n    // Check if a specific key name exists in the cache\n    b, err := cache.Contains(ctx, "k1")\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(b)\n\n    // Remove and return the deleted key-value\n    removedValue, err := cache.Remove(ctx, "k1")\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(removedValue)\n\n    // Close the cache object to allow GC to reclaim resources\n    if err = cache.Close(ctx); err != nil {\n        panic(err)\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"After execution, the output is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"v1\n1\ntrue\nv1\n"})}),"\n",(0,r.jsx)(n.h3,{id:"expiration-control",children:"Expiration Control"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "github.com/gogf/gf/v2/os/gcache"\n    "github.com/gogf/gf/v2/os/gctx"\n    "time"\n)\n\nfunc main() {\n    var (\n        ctx = gctx.New()\n    )\n    // Write when the key name does not exist, set expiration time to 1000 milliseconds\n    _, err := gcache.SetIfNotExist(ctx, "k1", "v1", time.Second)\n    if err != nil {\n        panic(err)\n    }\n\n    // Print current list of key names\n    keys, err := gcache.Keys(ctx)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(keys)\n\n    // Print current list of key-values\n    values, err := gcache.Values(ctx)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(values)\n\n    // Get a specific key value, write if it does not exist, and return the key value\n    value, err := gcache.GetOrSet(ctx, "k2", "v2", 0)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(value)\n\n    // Print current key-value pairs\n    data1, err := gcache.Data(ctx)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(data1)\n\n    // Wait for 1 second, so k1:v1 expires automatically\n    time.Sleep(time.Second)\n\n    // Print current key-value pairs again, and find that k1:v1 has expired, leaving only k2:v2\n    data2, err := gcache.Data(ctx)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(data2)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"After execution, the output is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"[k1]\n[v1]\nv2\nmap[k1:v1 k2:v2]\nmap[k2:v2]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"getorsetfunc",children:(0,r.jsx)(n.code,{children:"GetOrSetFunc*"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GetOrSetFunc"})," retrieves a cache value, and if the cache does not exist, executes the specified ",(0,r.jsx)(n.code,{children:"f func(context.Context) (interface{}, error)"}),", caches the result of the ",(0,r.jsx)(n.code,{children:"f"})," method, and returns that result."]}),"\n",(0,r.jsxs)(n.p,{children:["It is important to note that ",(0,r.jsx)(n.code,{children:"GetOrSetFunc"}),"'s cache method parameter ",(0,r.jsx)(n.code,{children:"f"})," is executed ",(0,r.jsx)(n.strong,{children:"outside of the cache's lock mechanism"}),", so ",(0,r.jsx)(n.code,{children:"GetOrSetFunc"})," can be nested within ",(0,r.jsx)(n.code,{children:"f"}),". However, if ",(0,r.jsx)(n.code,{children:"f"})," is computationally intensive, it may be executed multiple times under high concurrency (only the result from the first executed ",(0,r.jsx)(n.code,{children:"f"})," can be successfully cached, the rest will be discarded). On the other hand, ",(0,r.jsx)(n.code,{children:"GetOrSetFuncLock"}),"'s cache method ",(0,r.jsx)(n.code,{children:"f"})," is executed ",(0,r.jsx)(n.strong,{children:"within the cache's lock mechanism"}),", ensuring that ",(0,r.jsx)(n.code,{children:"f"})," is executed only once when the cache item does not exist, but the cache write lock duration depends on the execution time of the ",(0,r.jsx)(n.code,{children:"f"})," method."]}),"\n",(0,r.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "github.com/gogf/gf/v2/os/gcache"\n    "github.com/gogf/gf/v2/os/gctx"\n    "time"\n)\n\nfunc main() {\n    var (\n        ch    = make(chan struct{}, 0)\n        ctx   = gctx.New()\n        key   = `key`\n        value = `value`\n    )\n    for i := 0; i < 10; i++ {\n        go func(index int) {\n            <-ch\n            _, err := gcache.GetOrSetFuncLock(ctx, key, func(ctx context.Context) (interface{}, error) {\n                fmt.Println(index, "entered")\n                return value, nil\n            }, 0)\n            if err != nil {\n                panic(err)\n            }\n        }(i)\n    }\n    close(ch)\n    time.Sleep(time.Second)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"After execution, the terminal outputs (random, but only one message is output):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"9 entered\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can see that when multiple ",(0,r.jsx)(n.code,{children:"goroutine"}),"s concurrently call the ",(0,r.jsx)(n.code,{children:"GetOrSetFuncLock"})," method, due to its concurrent safety control, only one ",(0,r.jsx)(n.code,{children:"goroutine"}),"'s value-generation function executes successfully, and once successful, other ",(0,r.jsx)(n.code,{children:"goroutine"}),"s immediately return with the data without executing their corresponding value-generation functions."]}),"\n",(0,r.jsxs)(n.h3,{id:"lru-cache-eviction-control",children:[(0,r.jsx)(n.code,{children:"LRU"})," Cache Eviction Control"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "github.com/gogf/gf/v2/os/gcache"\n    "github.com/gogf/gf/v2/os/gctx"\n    "time"\n)\n\nfunc main() {\n    var (\n        ctx   = gctx.New()\n        cache = gcache.New(2) // Set LRU eviction count\n    )\n\n    // Add 10 elements, no expiration\n    for i := 0; i < 10; i++ {\n        if err := cache.Set(ctx, i, i, 0); err != nil {\n            panic(err)\n        }\n    }\n    size, err := cache.Size(ctx)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(size)\n\n    keys, err := cache.Keys(ctx)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(keys)\n\n    // Read key name 1 to ensure that this key name is preferentially retained\n    value, err := cache.Get(ctx, 1)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(value)\n\n    // After waiting for some time (checked once per second by default),\n    // elements will be evicted in order from oldest to newest\n    time.Sleep(3 * time.Second)\n    size, err = cache.Size(ctx)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(size)\n\n    keys, err = cache.Keys(ctx)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(keys)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"After execution, the output is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-10",children:"[2 3 5 6 7 0 1 4 8 9]\n1\n2\n[1 9]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"performance-testing",children:"Performance Testing"}),"\n",(0,r.jsx)(n.h3,{id:"test-environment",children:"Test Environment"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"CPU: Intel(R) Core(TM) i5-4460  CPU @ 3.20GHz\nMEM: 8GB\nSYS: Ubuntu 16.04 amd64\n"})}),"\n",(0,r.jsx)(n.h3,{id:"test-results",children:"Test Results"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'john@john-B85M:~/Workspace/Go/GOPATH/src/github.com/gogf/gf/v2/os/gcache$ go test *.go -bench=".*" -benchmem\ngoos: linux\ngoarch: amd64\nBenchmark_CacheSet-4                       2000000        897 ns/op      249 B/op        4 allocs/op\nBenchmark_CacheGet-4                       5000000        202 ns/op       49 B/op        1 allocs/op\nBenchmark_CacheRemove-4                   50000000       35.7 ns/op        0 B/op        0 allocs/op\nBenchmark_CacheLruSet-4                    2000000        880 ns/op      399 B/op        4 allocs/op\nBenchmark_CacheLruGet-4                    3000000        212 ns/op       33 B/op        1 allocs/op\nBenchmark_CacheLruRemove-4                50000000       35.9 ns/op        0 B/op        0 allocs/op\nBenchmark_InterfaceMapWithLockSet-4        3000000        477 ns/op       73 B/op        2 allocs/op\nBenchmark_InterfaceMapWithLockGet-4       10000000        149 ns/op        0 B/op        0 allocs/op\nBenchmark_InterfaceMapWithLockRemove-4    50000000       39.8 ns/op        0 B/op        0 allocs/op\nBenchmark_IntMapWithLockWithLockSet-4      5000000        304 ns/op       53 B/op        0 allocs/op\nBenchmark_IntMapWithLockGet-4             20000000        164 ns/op        0 B/op        0 allocs/op\nBenchmark_IntMapWithLockRemove-4          50000000       33.1 ns/op        0 B/op        0 allocs/op\nPASS\nok   command-line-arguments 47.503s\n'})})]})}function d(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},250065:function(e,n,c){c.d(n,{Z:function(){return a},a:function(){return o}});var t=c(667294);let r={},i=t.createContext(r);function o(e){let n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);