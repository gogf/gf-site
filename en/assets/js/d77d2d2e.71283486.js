"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["37825"],{824410:function(e,i,n){n.r(i),n.d(i,{metadata:()=>t,contentTitle:()=>o,default:()=>h,assets:()=>c,toc:()=>d,frontMatter:()=>a});var t=JSON.parse('{"id":"docs/\u6846\u67B6\u8BBE\u8BA1/\u5DE5\u7A0B\u5F00\u53D1\u8BBE\u8BA1/\u4EE3\u7801\u5206\u5C42\u8BBE\u8BA1","title":"Code Layering","description":"The code layering design of the GoFrame framework, including the MVC design pattern and the 3-tier architecture design. The MVC design pattern is suitable for business scenarios requiring server-side rendered pages, while the 3-tier architecture design emphasizes the idea of high cohesion and low coupling by separating the business logic layer from the data access layer, improving the project\'s maintainability and flexibility.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6846\u67B6\u8BBE\u8BA1/\u5DE5\u7A0B\u5F00\u53D1\u8BBE\u8BA1/\u4EE3\u7801\u5206\u5C42\u8BBE\u8BA1.md","sourceDirName":"docs/\u6846\u67B6\u8BBE\u8BA1/\u5DE5\u7A0B\u5F00\u53D1\u8BBE\u8BA1","slug":"/docs/design/project-layer","permalink":"/en/docs/design/project-layer","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6846\u67B6\u8BBE\u8BA1/\u5DE5\u7A0B\u5F00\u53D1\u8BBE\u8BA1/\u4EE3\u7801\u5206\u5C42\u8BBE\u8BA1.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732541616000,"sidebarPosition":0,"frontMatter":{"slug":"/docs/design/project-layer","title":"Code Layering","sidebar_position":0,"hide_title":true,"keywords":["GoFrame Framework","Code Layering Design","MVC Design Pattern","3-Tier Architecture","Business Logic Layer","Data Access Layer","Presentation Layer UI","Model Definition Layer","Software Architecture","Decoupling"],"description":"The code layering design of the GoFrame framework, including the MVC design pattern and the 3-tier architecture design. The MVC design pattern is suitable for business scenarios requiring server-side rendered pages, while the 3-tier architecture design emphasizes the idea of high cohesion and low coupling by separating the business logic layer from the data access layer, improving the project\'s maintainability and flexibility."},"sidebar":"mainSidebar","previous":{"title":"Engineering Design \uD83D\uDD25","permalink":"/en/docs/design/project"},"next":{"title":"Project Structure\uD83D\uDD25","permalink":"/en/docs/design/project-structure"}}'),r=n("785893"),s=n("250065");let a={slug:"/docs/design/project-layer",title:"Code Layering",sidebar_position:0,hide_title:!0,keywords:["GoFrame Framework","Code Layering Design","MVC Design Pattern","3-Tier Architecture","Business Logic Layer","Data Access Layer","Presentation Layer UI","Model Definition Layer","Software Architecture","Decoupling"],description:"The code layering design of the GoFrame framework, including the MVC design pattern and the 3-tier architecture design. The MVC design pattern is suitable for business scenarios requiring server-side rendered pages, while the 3-tier architecture design emphasizes the idea of high cohesion and low coupling by separating the business logic layer from the data access layer, improving the project's maintainability and flexibility."},o=void 0,c={},d=[{value:"1. Introduction",id:"1-introduction",level:2},{value:"2. <code>MVC</code> Design Pattern",id:"2-mvc-design-pattern",level:2},{value:"Brief Introduction",id:"brief-introduction",level:3},{value:"Pain Points",id:"pain-points",level:3},{value:"3. <code>3-Tier Architecture</code>",id:"3-3-tier-architecture",level:2},{value:"Presentation Layer - <code>UI</code>",id:"presentation-layer---ui",level:3},{value:"Business Logic Layer - <code>BLL</code>",id:"business-logic-layer---bll",level:3},{value:"Data Access Layer - <code>DAL</code>",id:"data-access-layer---dal",level:3},{value:"Model Definition Layer - <code>Model</code>",id:"model-definition-layer---model",level:3},{value:"Comparison between 3-Tier Architecture and <code>MVC</code>",id:"comparison-between-3-tier-architecture-and-mvc",level:3},{value:"4. Further Understanding",id:"4-further-understanding",level:2}];function l(e){let i={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.admonition,{type:"tip",children:(0,r.jsx)(i.p,{children:"The significance of code layering lies in further decoupling program logic, designing data flow and dependency relationships between layers as a unidirectional link, making the system architecture more flexible and extensible."})}),"\n",(0,r.jsx)(i.h2,{id:"1-introduction",children:"1. Introduction"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"GoFrame"}),", as a fully engineered foundational development framework, has its unique framework design concepts. In this chapter, we introduce its code layering design. In the server-side business code layering design pattern, we most commonly see the ",(0,r.jsx)(i.code,{children:"MVC"})," design pattern and the 3-tier architecture design pattern (",(0,r.jsx)(i.code,{children:"3-Tier Architecture"}),")."]}),"\n",(0,r.jsxs)(i.h2,{id:"2-mvc-design-pattern",children:["2. ",(0,r.jsx)(i.code,{children:"MVC"})," Design Pattern"]}),"\n",(0,r.jsxs)(i.p,{children:["Let's first review the classic ",(0,r.jsx)(i.code,{children:"MVC"})," design pattern."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.img,{alt:"MVC Design Pattern",src:n(435298).Z+"",width:"300",height:"248"})}),"\n",(0,r.jsx)(i.p,{children:"Figure 1. MVC Design Pattern"}),"\n",(0,r.jsx)(i.h3,{id:"brief-introduction",children:"Brief Introduction"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"M"})," stands for Model, indicating the encapsulation of business rules. Among the three components of ",(0,r.jsx)(i.code,{children:"MVC"}),", the model carries out most of the processing tasks. The data returned by the model is neutral and unrelated to the data format, meaning a model can serve multiple views. Since code applied to the model only needs to be written once and can be reused by multiple views, it reduces code duplication."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"V"})," stands for View, the interface that users see and interact with. For example, a web page composed of ",(0,r.jsx)(i.code,{children:"HTML"})," elements or a software client interface. One of the merits of ",(0,r.jsx)(i.code,{children:"MVC"})," is that it can handle many different views for applications. Actually, no real processing occurs in the view; it merely serves as an output data way and allows manipulation by users."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"C"})," stands for Controller, which accepts user input and calls models and views to fulfill user needs. The controller itself neither outputs anything nor performs any processing. It only receives requests and decides which model component to call for handling the request, then determines which view to use to display the returned data."]}),"\n",(0,r.jsxs)(i.p,{children:["This design pattern is fairly simple and suitable for business scenarios where server-side rendered pages are required and is also friendly for ",(0,r.jsx)(i.code,{children:"SEO"}),". However, with the rise of the ",(0,r.jsx)(i.code,{children:"MVVM"})," development pattern and the rapid advancement of front-end technology, particularly projects with front-end frameworks like ",(0,r.jsx)(i.code,{children:"Vue"}),", ",(0,r.jsx)(i.code,{children:"React"}),", and ",(0,r.jsx)(i.code,{children:"Angular"}),", the use scenarios for the server-side ",(0,r.jsx)(i.code,{children:"MVC"})," design pattern have become less frequent."]}),"\n",(0,r.jsx)(i.h3,{id:"pain-points",children:"Pain Points"}),"\n",(0,r.jsxs)(i.p,{children:["For business scenarios where the business logic isn't particularly complex, ",(0,r.jsx)(i.code,{children:"MVC"})," can still manage quite well. However, as the business logic becomes large and complex, the increasing maintenance cost issue with the ",(0,r.jsx)(i.code,{children:"MVC"})," design pattern becomes more evident. Especially with the development of microservice architectures in internet projects, the ",(0,r.jsx)(i.code,{children:"MVC"})," design pattern has become more and more impractical in most internet project development. The main reasons for this are:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Further separation of view presentation and data operation methods, especially with the development of mobile ends and ",(0,r.jsx)(i.code,{children:"MVVM"})," frameworks on the front end, in most scenarios, server-side rendered ",(0,r.jsx)(i.code,{children:"View"})," is no longer needed."]}),"\n",(0,r.jsxs)(i.li,{children:["The code layering design pattern of ",(0,r.jsx)(i.code,{children:"MVC"})," is actually relatively coarse-grained:","\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["The ",(0,r.jsx)(i.code,{children:"Model"})," layer's code both maintains the data and encapsulates the business logic. As business logic becomes more complex, this layer's function logic becomes bloated and difficult to maintain."]}),"\n",(0,r.jsxs)(i.li,{children:["For team management, the boundary of responsibilities between ",(0,r.jsx)(i.code,{children:"Controller"})," and ",(0,r.jsx)(i.code,{children:"Model"})," is vague, placing a high demand on developers to write good code. The concept may seem simple, but adapting to the industrial-level software production is challenging."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.h2,{id:"3-3-tier-architecture",children:["3. ",(0,r.jsx)(i.code,{children:"3-Tier Architecture"})]}),"\n",(0,r.jsx)(i.p,{children:'The GoFrame framework recommends the 3-tier architecture design pattern for code layering (3-Tier Architecture), but with some modifications in specific implementations. 3-tier architecture design effectively embodies the design philosophy of software design being "high cohesion, low coupling."'}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.img,{src:n(789452).Z+"",width:"294",height:"300"})}),"\n",(0,r.jsx)(i.p,{children:"Figure 2. 3-Tier Architecture Design Pattern"}),"\n",(0,r.jsx)(i.p,{children:"The traditional 3-tier architecture design, as shown above, divides project code into three layers, each with its distinct responsibility boundary. However, in most scenarios, we often see the following layered structure, where the data structure model is further extracted for unified maintenance."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.img,{alt:"3-Tier Architecture Design Model",src:n(162755).Z+"",width:"810",height:"830"})}),"\n",(0,r.jsx)(i.p,{children:"Figure 3. Common 3-Tier Architecture Design Model"}),"\n",(0,r.jsxs)(i.h3,{id:"presentation-layer---ui",children:["Presentation Layer - ",(0,r.jsx)(i.code,{children:"UI"})]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"User Interface"})," is at the top layer of the architecture, directly interacting with users, mainly being ",(0,r.jsx)(i.code,{children:"WEB"})," pages in ",(0,r.jsx)(i.code,{children:"B/S"}),", or ",(0,r.jsx)(i.code,{children:"API"})," interfaces. The primary function of the presentation layer is to implement data input and output for the system. During this process, data can be transferred to the ",(0,r.jsx)(i.code,{children:"BLL"})," for processing without needing logical decision-making operations, and processed results are fed back to the presentation layer. In other words, the presentation layer realizes user interface/API interface functions, communicates user requirements, and uses ",(0,r.jsx)(i.code,{children:"BLL"})," or ",(0,r.jsx)(i.code,{children:"Model"})," for debugging to ensure user experience."]}),"\n",(0,r.jsxs)(i.h3,{id:"business-logic-layer---bll",children:["Business Logic Layer - ",(0,r.jsx)(i.code,{children:"BLL"})]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.code,{children:"Business Logic Layer"})," is responsible for making logical judgment and execution on specific issues. After receiving user instructions from the presentation layer ",(0,r.jsx)(i.code,{children:"UI"}),", it connects to the data access layer ",(0,r.jsx)(i.code,{children:"DAL"}),". The business logic layer in the three-tier architecture is positioned between the presentation and data layers and bridges both. It facilitates data connection and instruction transmission between the three tiers, enabling logic processing on received data to achieve functions like data creation, deletion, updating, and lookup, and feeds results back to the presentation layer ",(0,r.jsx)(i.code,{children:"UI"})," to realize software functionality."]}),"\n",(0,r.jsxs)(i.h3,{id:"data-access-layer---dal",children:["Data Access Layer - ",(0,r.jsx)(i.code,{children:"DAL"})]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.code,{children:"Data Access Layer"})," is the main control system for the database, performing operations such as data creation, deletion, updating, and lookup, and feeding back operation results to the business logic layer ",(0,r.jsx)(i.code,{children:"BLL"}),". During actual operation, the data access layer lacks logical judgment capability. To ensure rigorous code writing and improve code readability, developers typically encapsulate general data capabilities (e.g., via ",(0,r.jsx)(i.code,{children:"ORM"})," components) in this layer to ensure the data access layer ",(0,r.jsx)(i.code,{children:"DAL"}),"'s data processing functionality."]}),"\n",(0,r.jsxs)(i.h3,{id:"model-definition-layer---model",children:["Model Definition Layer - ",(0,r.jsx)(i.code,{children:"Model"})]}),"\n",(0,r.jsxs)(i.p,{children:["Model definition is often represented by ",(0,r.jsx)(i.code,{children:"Entity"})," objects, mainly used for database table mapping objects. During the practical development of information system software, object instances must be established, using object entity methods to represent relational database tables, assisting software development in controlling various system functions. Establishing entity libraries further facilitates parameter transmission across structural layers, enhancing the readability of the code. Essentially, the entity library mainly serves the presentation layer, business logic layer, and data access layer, transmitting data parameters between the three layers and strengthening the simplicity of data representation."]}),"\n",(0,r.jsxs)(i.p,{children:["It is important to distinguish that the ",(0,r.jsx)(i.code,{children:"Model"})," here is significantly different from the ",(0,r.jsx)(i.code,{children:"Model"})," in the ",(0,r.jsx)(i.code,{children:"MVC"})," design pattern, with completely different responsibilities."]}),"\n",(0,r.jsxs)(i.h3,{id:"comparison-between-3-tier-architecture-and-mvc",children:["Comparison between 3-Tier Architecture and ",(0,r.jsx)(i.code,{children:"MVC"})]}),"\n",(0,r.jsxs)(i.p,{children:["As ",(0,r.jsx)(i.code,{children:"MVC"})," is also a three-tier structure, some might generally categorize ",(0,r.jsx)(i.code,{children:"MVC"})," within the 3-tier architecture design. At face value, this may not seem problematic. However, there are distinctions between the two."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.img,{src:n(209904).Z+"",width:"944",height:"450"})}),"\n",(0,r.jsx)(i.p,{children:"Figure 4. Comparison between 3-Tier Architecture and MVC"}),"\n",(0,r.jsxs)(i.p,{children:["As can be seen, in the 3-tier architecture design, the ",(0,r.jsx)(i.code,{children:"UI"})," presentation layer is equivalent to the ",(0,r.jsx)(i.code,{children:"View"})," and ",(0,r.jsx)(i.code,{children:"Controller"})," layers in ",(0,r.jsx)(i.code,{children:"MVC"}),". Originally, in ",(0,r.jsx)(i.code,{children:"MVC"}),', the logic for these two layers should be relatively "lightweight," so merging them into one layer for unified management is understandable. An essential point is that ',(0,r.jsx)(i.code,{children:"Model"})," in ",(0,r.jsx)(i.code,{children:"MVC"})," is split into ",(0,r.jsx)(i.code,{children:"BLL"})," and ",(0,r.jsx)(i.code,{children:"DAL"}),", separating business logic from data access and decoupling the originally bloated ",(0,r.jsx)(i.code,{children:"Model"}),", beneficial for better project maintenance."]}),"\n",(0,r.jsx)(i.admonition,{type:"tip",children:(0,r.jsx)(i.p,{children:"The evolution of software architecture, especially of internet software architecture, is essentially a process of continuously decoupling business logic."})}),"\n",(0,r.jsx)(i.h2,{id:"4-further-understanding",children:"4. Further Understanding"}),"\n",(0,r.jsxs)(i.p,{children:["The concept of code layering is the most fundamental aspect of engineering design. We need to implement the layering idea into practice, specifically refer to: ",(0,r.jsx)(i.a,{href:"/en/docs/design/project-structure",children:"Project Structure\uD83D\uDD25"})]})]})}function h(e={}){let{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},209904:function(e,i,n){n.d(i,{Z:function(){return t}});let t=n.p+"assets/images/2c6cfc087687cca60b1f4d23b78705c4-6b51765a470f370a3c34306767a9ddd0.png"},789452:function(e,i,n){n.d(i,{Z:function(){return t}});let t=n.p+"assets/images/8b93ee429f05737e03dfc58bdfe04905-122d111b673649b5057ffe4bf32ebce1.png"},435298:function(e,i,n){n.d(i,{Z:function(){return t}});let t=n.p+"assets/images/d90094b0f7ec2edb2220ffc0204a1c2d-1efdaa18912ff6cc969a06bd8e8b7018.png"},162755:function(e,i,n){n.d(i,{Z:function(){return t}});let t=n.p+"assets/images/fe9aea78ab05dc6db3b34d021a05ee76-339d0c671d939b6cf6c9569158f0dafb.png"},250065:function(e,i,n){n.d(i,{Z:function(){return o},a:function(){return a}});var t=n(667294);let r={},s=t.createContext(r);function a(e){let i=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);