"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["23854"],{879956:function(e,n,t){t.r(n),t.d(n,{metadata:()=>r,contentTitle:()=>i,default:()=>l,assets:()=>a,toc:()=>p,frontMatter:()=>c});var r=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-Map\u8F6C\u6362","title":"Type Conversion - Map","description":"Use the gconv.Map method in the GoFrame framework for type conversion, including converting any map or struct/*struct type to a map[string]interface{} type. It supports property tags and custom tags, and can achieve recursive conversion through the MapDeep method to parse out the detailed structure of nested objects, suitable for multi-layer data processing.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-Map\u8F6C\u6362.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362","slug":"/docs/core/gconv-map","permalink":"/en/docs/core/gconv-map","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-Map\u8F6C\u6362.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732440306000,"sidebarPosition":1,"frontMatter":{"slug":"/docs/core/gconv-map","title":"Type Conversion - Map","sidebar_position":1,"hide_title":true,"keywords":["GoFrame","Type Conversion","Map Conversion","GoFrame Framework","Property Tags","Recursive Conversion","Custom Tags","MapDeep","struct Conversion","gconv"],"description":"Use the gconv.Map method in the GoFrame framework for type conversion, including converting any map or struct/*struct type to a map[string]interface{} type. It supports property tags and custom tags, and can achieve recursive conversion through the MapDeep method to parse out the detailed structure of nested objects, suitable for multi-layer data processing."},"sidebar":"mainSidebar","previous":{"title":"Type Conversion - Types","permalink":"/en/docs/core/gconv-basic"},"next":{"title":"Type Conversion - Struct","permalink":"/en/docs/core/gconv-struct"}}'),s=t("785893"),o=t("250065");let c={slug:"/docs/core/gconv-map",title:"Type Conversion - Map",sidebar_position:1,hide_title:!0,keywords:["GoFrame","Type Conversion","Map Conversion","GoFrame Framework","Property Tags","Recursive Conversion","Custom Tags","MapDeep","struct Conversion","gconv"],description:"Use the gconv.Map method in the GoFrame framework for type conversion, including converting any map or struct/*struct type to a map[string]interface{} type. It supports property tags and custom tags, and can achieve recursive conversion through the MapDeep method to parse out the detailed structure of nested objects, suitable for multi-layer data processing."},i=void 0,a={},p=[{value:"Basic Example",id:"basic-example",level:2},{value:"Property Tags",id:"property-tags",level:2},{value:"Custom Tags",id:"custom-tags",level:2},{value:"Recursive Conversion",id:"recursive-conversion",level:2}];function d(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"gconv.Map"})," supports converting any ",(0,s.jsx)(n.code,{children:"map"})," or ",(0,s.jsx)(n.code,{children:"struct"}),"/ ",(0,s.jsx)(n.code,{children:"*struct"})," type to the commonly used ",(0,s.jsx)(n.code,{children:"map[string]interface{}"})," type. When the conversion parameter is of type ",(0,s.jsx)(n.code,{children:"struct"}),"/ ",(0,s.jsx)(n.code,{children:"*struct"}),", it automatically recognizes the ",(0,s.jsx)(n.code,{children:"c/gconv/json"})," tags of ",(0,s.jsx)(n.code,{children:"struct"}),", and you can specify custom conversion tags and the priority of multiple tag parsing via the second parameter ",(0,s.jsx)(n.code,{children:"tags"})," of the ",(0,s.jsx)(n.code,{children:"Map"})," method. If the conversion fails, it returns ",(0,s.jsx)(n.code,{children:"nil"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["Property Tags: When converting ",(0,s.jsx)(n.code,{children:"struct"}),"/ ",(0,s.jsx)(n.code,{children:"*struct"})," types, it supports ",(0,s.jsx)(n.code,{children:"c/gconv/json"})," property tags, as well as ",(0,s.jsx)(n.code,{children:"-"})," and ",(0,s.jsx)(n.code,{children:"omitempty"})," tag properties. When using the ",(0,s.jsx)(n.code,{children:"-"})," tag property, it means that the property will not be converted. When using the ",(0,s.jsx)(n.code,{children:"omitempty"})," tag property, it means that the conversion will not be performed when the property is empty (nil pointer, number ",(0,s.jsx)(n.code,{children:"0"}),", string ",(0,s.jsx)(n.code,{children:'""'}),", empty array ",(0,s.jsx)(n.code,{children:"[]"}),", etc.). Please refer to the examples below for details."]})}),"\n",(0,s.jsx)(n.p,{children:"Common conversion methods:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func Map(value interface{}, tags ...string) map[string]interface{}\nfunc MapDeep(value interface{}, tags ...string) map[string]interface{}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Among them, ",(0,s.jsx)(n.code,{children:"MapDeep"})," supports recursive conversion, which will recursively convert the ",(0,s.jsx)(n.code,{children:"struct"}),"/ ",(0,s.jsx)(n.code,{children:"*struct"})," objects within the properties."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["For more map-related conversion methods, please refer to the interface documentation: ",(0,s.jsx)(n.a,{href:"https://pkg.go.dev/github.com/gogf/gf/v2/util/gconv",children:"https://pkg.go.dev/github.com/gogf/gf/v2/util/gconv"})]})}),"\n",(0,s.jsx)(n.h2,{id:"basic-example",children:"Basic Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/util/gconv"\n)\n\nfunc main() {\n    type User struct {\n        Uid  int    `c:"uid"`\n        Name string `c:"name"`\n    }\n    // Object\n    g.Dump(gconv.Map(User{\n        Uid:  1,\n        Name: "john",\n    }))\n    // Object pointer\n    g.Dump(gconv.Map(&User{\n        Uid:  1,\n        Name: "john",\n    }))\n\n    // Any map type\n    g.Dump(gconv.Map(map[int]int{\n        100: 10000,\n    }))\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"After execution, the terminal outputs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n    "name": "john",\n    "uid": 1,\n}\n\n{\n    "name": "john",\n    "uid": 1,\n}\n\n{\n    "100": 10000,\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"property-tags",children:"Property Tags"}),"\n",(0,s.jsxs)(n.p,{children:["We can customize the ",(0,s.jsx)(n.code,{children:"map"})," key name after conversion via the ",(0,s.jsx)(n.code,{children:"c/gconv/json"})," tag. When multiple tags exist, the priority is determined by the order of ",(0,s.jsx)(n.code,{children:"gconv/c/json"})," tags."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/util/gconv"\n)\n\nfunc main() {\n    type User struct {\n        Uid      int\n        Name     string `c:"-"`\n        NickName string `c:"nickname, omitempty"`\n        Pass1    string `c:"password1"`\n        Pass2    string `c:"password2"`\n    }\n    user := User{\n        Uid:   100,\n        Name:  "john",\n        Pass1: "123",\n        Pass2: "456",\n    }\n    g.Dump(gconv.Map(user))\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"After execution, the terminal outputs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n    "Uid": 100,\n    "password1": "123",\n    "password2": "456",\n    "nickname": "",\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"custom-tags",children:"Custom Tags"}),"\n",(0,s.jsxs)(n.p,{children:["Besides, we can also customize the tag names of ",(0,s.jsx)(n.code,{children:"struct"})," properties and specify the tag priority during ",(0,s.jsx)(n.code,{children:"map"})," conversion via the second parameter."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/util/gconv"\n)\n\nfunc main() {\n    type User struct {\n        Id   int    `c:"uid"`\n        Name string `my-tag:"nick-name" c:"name"`\n    }\n    user := &User{\n        Id:   1,\n        Name: "john",\n    }\n    g.Dump(gconv.Map(user, "my-tag"))\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"After execution, the output result is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n    "nick-name": "john",\n    "uid": 1,\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"recursive-conversion",children:"Recursive Conversion"}),"\n",(0,s.jsxs)(n.p,{children:["When the parameter is of ",(0,s.jsx)(n.code,{children:"map"}),"/ ",(0,s.jsx)(n.code,{children:"struct"}),"/ ",(0,s.jsx)(n.code,{children:"*struct"})," type, if the key value/property is an object (or an object pointer) and is not an ",(0,s.jsx)(n.code,{children:"embedded"})," struct without any alias tags bound, the ",(0,s.jsx)(n.code,{children:"Map"})," method will convert the object as a key-value in the result. We can use the ",(0,s.jsx)(n.code,{children:"MapDeep"})," method to recursively convert sub-objects of the parameters, i.e., converting properties to ",(0,s.jsx)(n.code,{children:"map"})," type as well. Let's look at an example."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/util/gconv"\n    "reflect"\n)\n\nfunc main() {\n    type Base struct {\n        Id   int    `c:"id"`\n        Date string `c:"date"`\n    }\n    type User struct {\n        UserBase Base   `c:"base"`\n        Passport string `c:"passport"`\n        Password string `c:"password"`\n        Nickname string `c:"nickname"`\n    }\n    user := &User{\n        UserBase: Base{\n            Id:   1,\n            Date: "2019-10-01",\n        },\n        Passport: "john",\n        Password: "123456",\n        Nickname: "JohnGuo",\n    }\n    m1 := gconv.Map(user)\n    m2 := gconv.MapDeep(user)\n    g.Dump(m1, m2)\n    fmt.Println(reflect.TypeOf(m1["base"]))\n    fmt.Println(reflect.TypeOf(m2["base"]))\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"After execution, the terminal output is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n    "base":     {\n        Id:   1,\n        Date: "2019-10-01",\n    },\n    "passport": "john",\n    "password": "123456",\n    "nickname": "JohnGuo",\n}\n{\n    "base":     {\n        "id":   1,\n        "date": "2019-10-01",\n    },\n    "passport": "john",\n    "password": "123456",\n    "nickname": "JohnGuo",\n}\nmain.Base\nmap[string]interface {}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Can you see the difference?"})]})}function l(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return i},a:function(){return c}});var r=t(667294);let s={},o=r.createContext(s);function c(e){let n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);