"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["68184"],{223891:function(e,n,t){t.r(n),t.d(n,{metadata:()=>o,contentTitle:()=>a,default:()=>h,assets:()=>c,toc:()=>d,frontMatter:()=>i});var o=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u9AD8\u7EA7\u7279\u6027/ORM\u9AD8\u7EA7\u7279\u6027-SQL\u6355\u83B7","title":"ORM Senior - SQL Capture","description":"Advanced ORM features in the GoFrame framework, focusing on SQL capture and translation functions. Through CatchSQL and ToSQL methods, it is possible to capture or estimate SQL operations before executing SQL statements, and implement operation recording and debugging in conjunction with context objects. These features help developers efficiently debug and test database operations.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u9AD8\u7EA7\u7279\u6027/ORM\u9AD8\u7EA7\u7279\u6027-SQL\u6355\u83B7.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u9AD8\u7EA7\u7279\u6027","slug":"/docs/core/gdb-senior-catch-sql","permalink":"/en/docs/core/gdb-senior-catch-sql","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u9AD8\u7EA7\u7279\u6027/ORM\u9AD8\u7EA7\u7279\u6027-SQL\u6355\u83B7.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732440306000,"sidebarPosition":1,"frontMatter":{"slug":"/docs/core/gdb-senior-catch-sql","title":"ORM Senior - SQL Capture","sidebar_position":1,"hide_title":true,"keywords":["GoFrame","CatchSQL","ToSQL","SQL Capture","SQL Translation","ORM Feature","Go Language","Database Operation","SQL Debugging","Context Object"],"description":"Advanced ORM features in the GoFrame framework, focusing on SQL capture and translation functions. Through CatchSQL and ToSQL methods, it is possible to capture or estimate SQL operations before executing SQL statements, and implement operation recording and debugging in conjunction with context objects. These features help developers efficiently debug and test database operations."},"sidebar":"mainSidebar","previous":{"title":"ORM Senior - RawSQL","permalink":"/en/docs/core/gdb-senior-raw-sql"},"next":{"title":"ORM Senior - Debug Mode","permalink":"/en/docs/core/gdb-senior-debugging"}}'),r=t("785893"),s=t("250065");let i={slug:"/docs/core/gdb-senior-catch-sql",title:"ORM Senior - SQL Capture",sidebar_position:1,hide_title:!0,keywords:["GoFrame","CatchSQL","ToSQL","SQL Capture","SQL Translation","ORM Feature","Go Language","Database Operation","SQL Debugging","Context Object"],description:"Advanced ORM features in the GoFrame framework, focusing on SQL capture and translation functions. Through CatchSQL and ToSQL methods, it is possible to capture or estimate SQL operations before executing SQL statements, and implement operation recording and debugging in conjunction with context objects. These features help developers efficiently debug and test database operations."},a=void 0,c={},d=[{value:"<code>CatchSQL</code>",id:"catchsql",level:2},{value:"<code>ToSQL</code>",id:"tosql",level:2}];function l(e){let n={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["Please note that the principle of SQL capture in the framework is that any ",(0,r.jsx)(n.strong,{children:"SQL statement template"})," generated by SQL operations, along with ",(0,r.jsx)(n.strong,{children:"SQL execution parameters"}),", is intercepted by the framework before being submitted to the underlying database engine and automatically formatted into a human-readable string by the framework component for ",(0,r.jsx)(n.strong,{children:"reference and debugging purposes only"})," and is not the complete SQL statement submitted to the underlying database engine. The captured SQL statements are identical to the SQL statements output when the ORM component is in debugging mode, as they are generated by the same component."]})}),"\n",(0,r.jsx)(n.h2,{id:"catchsql",children:(0,r.jsx)(n.code,{children:"CatchSQL"})}),"\n",(0,r.jsxs)(n.p,{children:["We can use the ",(0,r.jsx)(n.code,{children:"gdb.CatchSQL"})," method to capture the list of ",(0,r.jsx)(n.code,{children:"SQL"})," executed within a specified range. The method is defined as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"// CatchSQL catches and returns all sql statements that are EXECUTED in given closure function.\n// Be caution that, all the following sql statements should use the context object passing by function `f`.\nfunc CatchSQL(ctx context.Context, f func(ctx context.Context) error) (sqlArray []string, err error)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["As you can see, this method uses a closure function to execute ",(0,r.jsx)(n.code,{children:"SQL"})," statements. All ",(0,r.jsx)(n.code,{children:"SQL"})," operations executed within the closure function will be recorded and returned as a ",(0,r.jsx)(n.code,{children:"[]string"})," type. Note that the ",(0,r.jsx)(n.code,{children:"SQL"})," operations executed within the closure should pass the ",(0,r.jsx)(n.code,{children:"ctx"})," context object, otherwise the statements corresponding to the ",(0,r.jsx)(n.code,{children:"SQL"})," operations cannot be recorded. Here is an example:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"user.sql"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE `user` (\n    `id`          int(10) unsigned NOT NULL AUTO_INCREMENT,\n    `passport`    varchar(45) NULL,\n    `password`    char(32) NULL,\n    `nickname`    varchar(45) NULL,\n    `create_time` timestamp(6) NULL,\n    PRIMARY KEY (id)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"main.go"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "context"\n\n    _ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/os/gctx"\n    "github.com/gogf/gf/v2/os/gtime"\n)\n\ntype User struct {\n    Id         int\n    Passport   string\n    Password   string\n    Nickname   string\n    CreateTime *gtime.Time\n}\n\nfunc initUser(ctx context.Context) error {\n    _, err := g.Model("user").Ctx(ctx).Data(User{\n        Id:       1,\n        Passport: "john",\n        Password: "12345678",\n        Nickname: "John",\n    }).Insert()\n    return err\n}\n\nfunc main() {\n    var ctx = gctx.New()\n    sqlArray, err := gdb.CatchSQL(ctx, func(ctx context.Context) error {\n        return initUser(ctx)\n    })\n    if err != nil {\n        panic(err)\n    }\n    g.Dump(sqlArray)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"After execution, the terminal outputs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"[\n    \"SHOW FULL COLUMNS FROM `user`\",\n    \"INSERT INTO `user`(`id`,`passport`,`password`,`nickname`,`created_at`,`updated_at`) VALUES(1,'john','12345678','John','2023-12-19 21:43:57','2023-12-19 21:43:57') \",\n]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tosql",children:(0,r.jsx)(n.code,{children:"ToSQL"})}),"\n",(0,r.jsxs)(n.p,{children:["We can use ",(0,r.jsx)(n.code,{children:"gdb.ToSQL"})," to convert a given ",(0,r.jsx)(n.code,{children:"SQL"})," operation into an ",(0,r.jsx)(n.code,{children:"SQL"})," statement without actually executing it. The method is defined as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"// ToSQL formats and returns the last one of sql statements in given closure function\n// WITHOUT TRULY EXECUTING IT.\n// Be caution that, all the following sql statements should use the context object passing by function `f`.\nfunc ToSQL(ctx context.Context, f func(ctx context.Context) error) (sql string, err error)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["As you can see, this method estimates ",(0,r.jsx)(n.code,{children:"SQL"})," statements through a closure function. All ",(0,r.jsx)(n.code,{children:"SQL"})," operations within the closure function will be estimated, but only the last ",(0,r.jsx)(n.code,{children:"SQL"})," statement will be returned as a ",(0,r.jsx)(n.code,{children:"string"})," type. Note that the ",(0,r.jsx)(n.code,{children:"SQL"})," operations within the closure should pass the ",(0,r.jsx)(n.code,{children:"ctx"})," context object, otherwise the statements corresponding to the ",(0,r.jsx)(n.code,{children:"SQL"})," operations cannot be recorded. Here is an example:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"user.sql"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE `user` (\n    `id`          int(10) unsigned NOT NULL AUTO_INCREMENT,\n    `passport`    varchar(45) NULL,\n    `password`    char(32) NULL,\n    `nickname`    varchar(45) NULL,\n    `create_time` timestamp(6) NULL,\n    PRIMARY KEY (id)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"main.go"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "context"\n\n    _ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/os/gctx"\n    "github.com/gogf/gf/v2/os/gtime"\n)\n\ntype User struct {\n    Id         int\n    Passport   string\n    Password   string\n    Nickname   string\n    CreateTime *gtime.Time\n}\n\nfunc initUser(ctx context.Context) error {\n    _, err := g.Model("user").Ctx(ctx).Data(User{\n        Id:       1,\n        Passport: "john",\n        Password: "12345678",\n        Nickname: "John",\n    }).Insert()\n    return err\n}\n\nfunc main() {\n    var ctx = gctx.New()\n    sql, err := gdb.ToSQL(ctx, func(ctx context.Context) error {\n        return initUser(ctx)\n    })\n    if err != nil {\n        panic(err)\n    }\n    g.Dump(sql)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"After execution, the terminal outputs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\"INSERT INTO `user`(`id`,`passport`,`password`,`nickname`,`created_at`,`updated_at`) VALUES(1,'john','12345678','John','2023-12-19 21:49:21','2023-12-19 21:49:21') \"\n"})})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return a},a:function(){return i}});var o=t(667294);let r={},s=o.createContext(r);function i(e){let n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);