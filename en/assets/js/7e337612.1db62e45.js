"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["70429"],{737262:function(e,s,i){i.r(s),i.d(s,{metadata:()=>t,contentTitle:()=>c,default:()=>h,assets:()=>r,toc:()=>d,frontMatter:()=>a});var t=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u60B2\u89C2\u9501 & \u4E50\u89C2\u9501","title":"ORM Model - Lock","description":"How to implement pessimistic and optimistic locks through chaining operations in the GoFrame framework. Pessimistic locks are used to lock data during each access to prevent conflicts, commonly in high concurrency scenarios; while optimistic locks use a versioning mechanism to check data updates, suitable for scenarios with more reads and fewer writes. This document provides a detailed analysis of applicable scenarios, implementation methods, and the advantages and disadvantages of locking mechanisms to help developers optimize database performance.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u60B2\u89C2\u9501 & \u4E50\u89C2\u9501.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C","slug":"/docs/core/gdb-chaining-locks","permalink":"/en/docs/core/gdb-chaining-locks","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u60B2\u89C2\u9501 & \u4E50\u89C2\u9501.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732440306000,"sidebarPosition":15,"frontMatter":{"slug":"/docs/core/gdb-chaining-locks","title":"ORM Model - Lock","sidebar_position":15,"hide_title":true,"keywords":["Pessimistic Lock","Optimistic Lock","GoFrame","GoFrame Framework","Chaining Operations","SQL","Shared Lock","FOR UPDATE","LOCK IN SHARE MODE","Transaction"],"description":"How to implement pessimistic and optimistic locks through chaining operations in the GoFrame framework. Pessimistic locks are used to lock data during each access to prevent conflicts, commonly in high concurrency scenarios; while optimistic locks use a versioning mechanism to check data updates, suitable for scenarios with more reads and fewer writes. This document provides a detailed analysis of applicable scenarios, implementation methods, and the advantages and disadvantages of locking mechanisms to help developers optimize database performance."},"sidebar":"mainSidebar","previous":{"title":"ORM Model - Handler","permalink":"/en/docs/core/gdb-chaining-handler"},"next":{"title":"ORM - Method Ops (Native)","permalink":"/en/docs/core/gdb-funcs"}}'),o=i("785893"),n=i("250065");let a={slug:"/docs/core/gdb-chaining-locks",title:"ORM Model - Lock",sidebar_position:15,hide_title:!0,keywords:["Pessimistic Lock","Optimistic Lock","GoFrame","GoFrame Framework","Chaining Operations","SQL","Shared Lock","FOR UPDATE","LOCK IN SHARE MODE","Transaction"],description:"How to implement pessimistic and optimistic locks through chaining operations in the GoFrame framework. Pessimistic locks are used to lock data during each access to prevent conflicts, commonly in high concurrency scenarios; while optimistic locks use a versioning mechanism to check data updates, suitable for scenarios with more reads and fewer writes. This document provides a detailed analysis of applicable scenarios, implementation methods, and the advantages and disadvantages of locking mechanisms to help developers optimize database performance."},c=void 0,r={},d=[{value:"Using Pessimistic Locks",id:"using-pessimistic-locks",level:3},{value:"Using Optimistic Locks",id:"using-optimistic-locks",level:3},{value:"Summary of Locking Mechanisms",id:"summary-of-locking-mechanisms",level:3}];function l(e){let s={code:"code",h3:"h3",p:"p",pre:"pre",...(0,n.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"Pessimistic Lock"}),", as the name suggests, is very pessimistic, assuming that others will modify the data each time it is accessed, so it locks the data each time. This results in a block if someone else wants to access the data until they get the lock. Many traditional relational databases use this locking mechanism, such as row locks, table locks, read locks, and write locks, all of which lock before performing operations."]}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"Optimistic Lock"}),", as the name suggests, is very optimistic, assuming that others will not modify the data each time it is accessed, so it does not lock. However, it checks if others have updated the data during this period when updating, which can be implemented using mechanisms like versioning. Optimistic locks are suitable for applications with more reads, which can improve throughput."]}),"\n",(0,o.jsx)(s.h3,{id:"using-pessimistic-locks",children:"Using Pessimistic Locks"}),"\n",(0,o.jsx)(s.p,{children:"Related methods:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-go",children:"func (m *Model) LockUpdate() *Model\nfunc (m *Model) LockShared() *Model\n"})}),"\n",(0,o.jsxs)(s.p,{children:["The ",(0,o.jsx)(s.code,{children:"gdb"}),' module\'s chaining operations provide two methods to help you implement "pessimistic locks" in ',(0,o.jsx)(s.code,{children:"SQL"})," statements. You can use the ",(0,o.jsx)(s.code,{children:"LockShared"}),' method in queries to carry a "shared lock" when executing statements. A shared lock prevents the selected rows from being modified until the transaction is committed:']}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-go",children:'g.Model("users").Ctx(ctx).Where("votes>?", 100).LockShared().All();\n'})}),"\n",(0,o.jsx)(s.p,{children:"The above query is equivalent to the following SQL statement:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-sql",children:"SELECT * FROM `users` WHERE `votes` > 100 LOCK IN SHARE MODE\n"})}),"\n",(0,o.jsxs)(s.p,{children:["You can also use the ",(0,o.jsx)(s.code,{children:"LockUpdate"})," method. This method is used to create a ",(0,o.jsx)(s.code,{children:"FOR UPDATE"})," lock, preventing selected rows from being modified or deleted by other shared locks:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-go",children:'g.Model("users").Ctx(ctx).Where("votes>?", 100).LockUpdate().All();\n'})}),"\n",(0,o.jsx)(s.p,{children:"The above query is equivalent to the following SQL statement:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-sql",children:"SELECT * FROM `users` WHERE `votes` > 100 FOR UPDATE\n"})}),"\n",(0,o.jsxs)(s.p,{children:["Both ",(0,o.jsx)(s.code,{children:"FOR UPDATE"})," and ",(0,o.jsx)(s.code,{children:"LOCK IN SHARE MODE"})," are used to ensure that the selected records cannot be updated by other transactions (locked). The difference is that ",(0,o.jsx)(s.code,{children:"LOCK IN SHARE MODE"})," will not block other transactions from reading the value of the locked row, while ",(0,o.jsx)(s.code,{children:"FOR UPDATE"})," will block other locking reads of the locked row (non-locking reads can still read these records; both ",(0,o.jsx)(s.code,{children:"LOCK IN SHARE MODE"})," and ",(0,o.jsx)(s.code,{children:"FOR UPDATE"})," are locking reads)."]}),"\n",(0,o.jsxs)(s.p,{children:["This might be a bit abstract, so let's take a counter example: read a value in one statement, then update it in another. Using ",(0,o.jsx)(s.code,{children:"LOCK IN SHARE MODE"})," allows two transactions to read the same initial value, so after executing the two transactions, the final value of the counter is ",(0,o.jsx)(s.code,{children:"+1"}),"; however, if using ",(0,o.jsx)(s.code,{children:"FOR UPDATE"}),", it will lock the second transaction's read of the record value until the first transaction is completed, making the counter's final result ",(0,o.jsx)(s.code,{children:"+2"}),"."]}),"\n",(0,o.jsx)(s.h3,{id:"using-optimistic-locks",children:"Using Optimistic Locks"}),"\n",(0,o.jsxs)(s.p,{children:["Optimistic locks are mostly implemented based on a data version (",(0,o.jsx)(s.code,{children:"Version"}),') recording mechanism. What is a data version? It adds a version identifier to the data, usually by adding a "version" field to the database table in the version-based database table solution.']}),"\n",(0,o.jsx)(s.p,{children:"When reading data, the version number is also read, and when updating, the version number is incremented. At this time, the submitted data's version information is compared with the current version of the corresponding record in the database table. If the submitted data version number is greater than the current version number in the database table, the update is allowed; otherwise, it is considered outdated data."}),"\n",(0,o.jsx)(s.h3,{id:"summary-of-locking-mechanisms",children:"Summary of Locking Mechanisms"}),"\n",(0,o.jsx)(s.p,{children:"Each type of lock has its advantages and disadvantages. One cannot claim one is better than the other. Optimistic locks are suitable for scenarios with fewer writes, i.e., when conflicts rarely occur, thus eliminating the overhead of locks and increasing the system's overall throughput. However, if conflicts occur frequently, the upper-level application will keep retrying, which reduces performance, so using pessimistic locks is more appropriate in such cases."})]})}function h(e={}){let{wrapper:s}={...(0,n.a)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},250065:function(e,s,i){i.d(s,{Z:function(){return c},a:function(){return a}});var t=i(667294);let o={},n=t.createContext(o);function a(e){let s=t.useContext(n);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(n.Provider,{value:s},e.children)}}}]);