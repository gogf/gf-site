"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["65397"],{989557:function(e,n,s){s.r(n),s.d(n,{metadata:()=>t,contentTitle:()=>o,default:()=>h,assets:()=>c,toc:()=>l,frontMatter:()=>r});var t=JSON.parse('{"id":"docs/\u7EC4\u4EF6\u5217\u8868/\u7F16\u7801\u89E3\u7801/\u901A\u7528\u7F16\u89E3\u7801-gjson/\u901A\u7528\u7F16\u89E3\u7801-\u5C42\u7EA7\u8BBF\u95EE","title":"General Codec - Nested Visiting","description":"Using gjson for hierarchical access in the GoFrame framework, accessing unknown data structures through flexible hierarchical separators. Includes setting custom separator characters and handling cases where key names themselves contain hierarchical symbols. Additionally, discusses the impact of modifying reference type variables in Go language and its effect on underlying data.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u7EC4\u4EF6\u5217\u8868/\u7F16\u7801\u89E3\u7801/\u901A\u7528\u7F16\u89E3\u7801-gjson/\u901A\u7528\u7F16\u89E3\u7801-\u5C42\u7EA7\u8BBF\u95EE.md","sourceDirName":"docs/\u7EC4\u4EF6\u5217\u8868/\u7F16\u7801\u89E3\u7801/\u901A\u7528\u7F16\u89E3\u7801-gjson","slug":"/docs/components/encoding-gjson-nested-visiting","permalink":"/en/docs/components/encoding-gjson-nested-visiting","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u7EC4\u4EF6\u5217\u8868/\u7F16\u7801\u89E3\u7801/\u901A\u7528\u7F16\u89E3\u7801-gjson/\u901A\u7528\u7F16\u89E3\u7801-\u5C42\u7EA7\u8BBF\u95EE.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732443619000,"sidebarPosition":1,"frontMatter":{"slug":"/docs/components/encoding-gjson-nested-visiting","title":"General Codec - Nested Visiting","sidebar_position":1,"hide_title":true,"keywords":["GoFrame","GoFrame Framework","gjson","Data Hierarchical Access","JSON Decoding","Go Language","Encoding","Hierarchical Separator","Conflict Detection","Performance Optimization"],"description":"Using gjson for hierarchical access in the GoFrame framework, accessing unknown data structures through flexible hierarchical separators. Includes setting custom separator characters and handling cases where key names themselves contain hierarchical symbols. Additionally, discusses the impact of modifying reference type variables in Go language and its effect on underlying data."},"sidebar":"mainSidebar","previous":{"title":"General Codec - Creation","permalink":"/en/docs/components/encoding-gjson-creation"},"next":{"title":"General Codec - Struct","permalink":"/en/docs/components/encoding-gjson-struct-converting"}}'),i=s("785893"),a=s("250065");let r={slug:"/docs/components/encoding-gjson-nested-visiting",title:"General Codec - Nested Visiting",sidebar_position:1,hide_title:!0,keywords:["GoFrame","GoFrame Framework","gjson","Data Hierarchical Access","JSON Decoding","Go Language","Encoding","Hierarchical Separator","Conflict Detection","Performance Optimization"],description:"Using gjson for hierarchical access in the GoFrame framework, accessing unknown data structures through flexible hierarchical separators. Includes setting custom separator characters and handling cases where key names themselves contain hierarchical symbols. Additionally, discusses the impact of modifying reference type variables in Go language and its effect on underlying data."},o=void 0,c={},l=[{value:"Nested Visiting",id:"nested-visiting",level:2},{value:"Example 1, Basic Usage",id:"example-1-basic-usage",level:3},{value:"Example 2, Custom Hierarchical Separator",id:"example-2-custom-hierarchical-separator",level:3},{value:"Example 3, Handling the Case Where Key Names Themselves Contain Hierarchical Symbols &quot;.&quot;",id:"example-3-handling-the-case-where-key-names-themselves-contain-hierarchical-symbols-",level:3},{value:"Precautions",id:"precautions",level:2}];function d(e){let n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"nested-visiting",children:"Nested Visiting"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"gjson"}),' supports hierarchical retrieval access to data content, with the default hierarchical separator being ".". This feature makes it very convenient for developers to flexibly access unknown data structures.']}),"\n",(0,i.jsx)(n.h3,{id:"example-1-basic-usage",children:"Example 1, Basic Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func main() {\n    data :=\n        `{\n    "users" : {\n        "count" : 2,\n        "list"  : [\n            {"name" : "Ming", "score" : 60},\n            {"name" : "John", "score" : 99.5}\n        ]\n    }\n}`\n    if j, err := gjson.DecodeToJson(data); err != nil {\n        panic(err)\n    } else {\n        fmt.Println("John Score:", j.Get("users.list.1.score"))\n    }\n    // Output:\n    // John Score: 99.5\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, the ",(0,i.jsx)(n.code,{children:"gjson.Json"})," object can retrieve the corresponding variable information through very flexible hierarchical filtering functions ( ",(0,i.jsx)(n.code,{children:'j.GetFloat32("users.list.1.score")'}),")."]}),"\n",(0,i.jsx)(n.h3,{id:"example-2-custom-hierarchical-separator",children:"Example 2, Custom Hierarchical Separator"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func main() {\n    data :=\n        `{\n    "users" : {\n        "count" : 2,\n        "list"  : [\n            {"name" : "Ming", "score" : 60},\n            {"name" : "John", "score" : 99.5}\n        ]\n    }\n}`\n    if j, err := gjson.DecodeToJson(data); err != nil {\n        panic(err)\n    } else {\n        j.SetSplitChar(\'#\')\n        fmt.Println("John Score:", j.Get("users#list#1#score"))\n    }\n    // Output:\n    // John Score: 99.5\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, we can set our custom separator using the ",(0,i.jsx)(n.code,{children:"SetSplitChar"})," method."]}),"\n",(0,i.jsx)(n.h3,{id:"example-3-handling-the-case-where-key-names-themselves-contain-hierarchical-symbols-",children:'Example 3, Handling the Case Where Key Names Themselves Contain Hierarchical Symbols "."'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func main() {\n    data :=\n        `{\n        "users" : {\n            "count" : 100\n        },\n        "users.count" : 101\n    }`\n    if j, err := gjson.DecodeToJson(data); err != nil {\n        glog.Error(gctx.New(), err)\n    } else {\n        j.SetViolenceCheck(true)\n        fmt.Println("Users Count:", j.Get("users.count"))\n    }\n    // Output:\n    // Users Count: 101\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The result printed after running is ",(0,i.jsx)(n.code,{children:"101"}),'. When the key name contains ".", we can set conflict detection through ',(0,i.jsx)(n.code,{children:"SetViolenceCheck"}),", and the retrieval priority will follow: key name->hierarchical, so there won't be ambiguity. However, when the conflict detection switch is on, the retrieval efficiency will be lower, and it is off by default."]}),"\n",(0,i.jsx)(n.h2,{id:"precautions",children:"Precautions"}),"\n",(0,i.jsxs)(n.p,{children:["As everyone knows, in ",(0,i.jsx)(n.code,{children:"Golang"}),", the ",(0,i.jsx)(n.code,{children:"map/slice"}),' type is actually a "reference type" (also known as a "pointer type"), so when you modify the key-value/index items of this type of variable, it will also modify its corresponding underlying data.']}),"\n",(0,i.jsxs)(n.p,{children:["For efficiency, the ",(0,i.jsx)(n.code,{children:"gjson"})," package does not make value copies for the data type when some retrieval methods return ",(0,i.jsx)(n.code,{children:"map/slice"}),", so when you modify the returned data, it will also modify the underlying data of ",(0,i.jsx)(n.code,{children:"gjson"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func main() {\n    jsonContent := `{"map":{"key":"value"}, "slice":[59,90]}`\n    j, _ := gjson.LoadJson(jsonContent)\n    m := j.Get("map")\n    mMap := m.Map()\n    fmt.Println(mMap)\n\n    // Change the key-value pair.\n    mMap["key"] = "john"\n\n    // It changes the underlying key-value pair.\n    fmt.Println(j.Get("map").Map())\n\n    s := j.Get("slice")\n    sArray := s.Array()\n    fmt.Println(sArray)\n\n    // Change the value of specified index.\n    sArray[0] = 100\n\n    // It changes the underlying slice.\n    fmt.Println(j.Get("slice").Array())\n\n    // output:\n    // map[key:value]\n    // map[key:john]\n    // [59 90]\n    // [100 90]\n}\n'})})]})}function h(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},250065:function(e,n,s){s.d(n,{Z:function(){return o},a:function(){return r}});var t=s(667294);let i={},a=t.createContext(i);function r(e){let n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);