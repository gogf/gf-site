"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["90012"],{403101:function(e,n,t){t.r(n),t.d(n,{metadata:()=>r,contentTitle:()=>a,default:()=>u,assets:()=>d,toc:()=>l,frontMatter:()=>o});var r=JSON.parse('{"id":"quick/\u5FEB\u901F\u5F00\u59CB/\u4F7F\u7528\u89C4\u8303\u8DEF\u7531","title":"Standard Routing","description":"Use standard routing in the GoFrame framework to simplify route registration, focusing on business logic. Standardize route registration by defining request and response data structures, and manage routes using an object-oriented approach to enhance code maintainability. Provides complete sample code and execution results to guide readers in applying it to real projects.","source":"@site/i18n/en/docusaurus-plugin-content-docs/version-2.8.x/quick/\u5FEB\u901F\u5F00\u59CB/\u4F7F\u7528\u89C4\u8303\u8DEF\u7531.md","sourceDirName":"quick/\u5FEB\u901F\u5F00\u59CB","slug":"/quick/strict-router","permalink":"/en/2.8.x/quick/strict-router","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/versioned_docs/version-2.8.x/quick/\u5FEB\u901F\u5F00\u59CB/\u4F7F\u7528\u89C4\u8303\u8DEF\u7531.md","tags":[],"version":"2.8.x","lastUpdatedBy":"John Guo","lastUpdatedAt":1742194305000,"sidebarPosition":5,"frontMatter":{"slug":"/quick/strict-router","title":"Standard Routing","hide_title":true,"sidebar_position":5,"keywords":["GoFrame","GoFrame framework","standard routing","route registration","data structure","route object management","Go language","web server","HTTP methods","route callbacks"],"description":"Use standard routing in the GoFrame framework to simplify route registration, focusing on business logic. Standardize route registration by defining request and response data structures, and manage routes using an object-oriented approach to enhance code maintainability. Provides complete sample code and execution results to guide readers in applying it to real projects."},"sidebar":"quickSidebar","previous":{"title":"Parameters Structure","permalink":"/en/2.8.x/quick/request-struct"},"next":{"title":"Using Middleware","permalink":"/en/2.8.x/quick/middleware"}}'),i=t("785893"),s=t("250065");let o={slug:"/quick/strict-router",title:"Standard Routing",hide_title:!0,sidebar_position:5,keywords:["GoFrame","GoFrame framework","standard routing","route registration","data structure","route object management","Go language","web server","HTTP methods","route callbacks"],description:"Use standard routing in the GoFrame framework to simplify route registration, focusing on business logic. Standardize route registration by defining request and response data structures, and manage routes using an object-oriented approach to enhance code maintainability. Provides complete sample code and execution results to guide readers in applying it to real projects."},a=void 0,d={},l=[{value:"Defining Request/Response Types",id:"defining-requestresponse-types",level:2},{value:"Object-Oriented Route Handlers",id:"object-oriented-route-handlers",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"Testing the API",id:"testing-the-api",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function c(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"GoFrame"})," framework provides a standardized routing approach that simplifies route registration and lets developers focus on business logic. We call this ",(0,i.jsx)(n.strong,{children:"Standard Routing"})," - a more intuitive and maintainable way to handle HTTP endpoints."]}),"\n",(0,i.jsx)(n.h2,{id:"defining-requestresponse-types",children:"Defining Request/Response Types"}),"\n",(0,i.jsx)(n.p,{children:"Standard routing uses structured types for both requests and responses. This approach enables parameter validation, documentation generation, and future extensibility:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type HelloReq struct {\n    g.Meta `path:"/" method:"get"`\n    Name   string `v:"required" dc:"User\'s name"`\n    Age    int    `v:"required" dc:"User\'s age"`\n}\ntype HelloRes struct {}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Key components:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The request struct embeds ",(0,i.jsx)(n.code,{children:"g.Meta"})," with routing metadata tags:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"path"}),": The URL path to register"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"method"}),": The HTTP method to handle (GET, POST, etc.)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Field tags provide additional functionality:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"v"}),': Validation rules (short for "valid"). Here, ',(0,i.jsx)(n.code,{children:'v:"required"'})," marks fields as mandatory"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dc"}),': Documentation comments (short for "description") for API docs']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"For a complete reference of available tags and validation rules, check out the relevant chapters in our development manual. For now, just focus on understanding their basic purpose."})}),"\n",(0,i.jsx)(n.h2,{id:"object-oriented-route-handlers",children:"Object-Oriented Route Handlers"}),"\n",(0,i.jsx)(n.p,{children:"For better maintainability, especially in larger APIs, we use an object-oriented approach instead of registering routes one by one. Here's how it works:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type Hello struct{}\n\nfunc (Hello) Say(ctx context.Context, req *HelloReq) (res *HelloRes, err error) {\n    r := g.RequestFromCtx(ctx)\n    r.Response.Writef(\n        "Hello %s! Your Age is %d",\n        req.Name,\n        req.Age,\n    )\n    return\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Benefits of this approach:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Routes are organized into logical groups via handler objects"}),"\n",(0,i.jsxs)(n.li,{children:["Method signatures are more idiomatic and business-focused compared to raw ",(0,i.jsx)(n.code,{children:"func(*ghttp.Request)"})," handlers"]}),"\n",(0,i.jsxs)(n.li,{children:["The original request object is still accessible via ",(0,i.jsx)(n.code,{children:"g.RequestFromCtx"})," when needed"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,i.jsx)(n.p,{children:"Here's how we'd rewrite our web server using standard routing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",metastring:'title="main.go"',children:'package main\n\nimport (\n    "context"\n\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/net/ghttp"\n)\n\ntype HelloReq struct {\n    g.Meta `path:"/" method:"get"`\n    Name   string `v:"required" dc:"User\'s name"`\n    Age    int    `v:"required" dc:"User\'s age"`\n}\ntype HelloRes struct{}\n\ntype Hello struct{}\n\nfunc (Hello) Say(ctx context.Context, req *HelloReq) (res *HelloRes, err error) {\n    r := g.RequestFromCtx(ctx)\n    r.Response.Writef(\n        "Hello %s! Your Age is %d",\n        req.Name,\n        req.Age,\n    )\n    return\n}\n\nfunc main() {\n    s := g.Server()\n    s.Group("/", func(group *ghttp.RouterGroup) {\n        group.Bind(\n            new(Hello),\n        )\n    })\n    s.SetPort(8000)\n    s.Run()\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Key points:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"s.Group"}),' creates a route group with a common prefix ("',(0,i.jsx)(n.code,{children:"/"}),'" in this case)']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"group.Bind"})," registers all public methods of our handler object automatically, using struct metadata to configure routes"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"testing-the-api",children:"Testing the API"}),"\n",(0,i.jsxs)(n.p,{children:["Let's test with valid parameters at ",(0,i.jsx)(n.a,{href:"http://127.0.0.1:8000/?name=john&age=18",children:"http://127.0.0.1:8000/?name=john&age=18"}),":"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img.png",src:t(696140).Z+"",width:"1024",height:"226"})}),"\n",(0,i.jsxs)(n.p,{children:["When we try an invalid request at ",(0,i.jsx)(n.a,{href:"http://127.0.0.1:8000/",children:"http://127.0.0.1:8000/"}),", we get no output. This is because the validation failed before reaching our handler - the server rejected the request due to missing required parameters."]}),"\n",(0,i.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,i.jsx)(n.p,{children:"While we've improved our routing structure, we still need better control over error handling. For example, how can we:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Capture and customize validation error messages?"}),"\n",(0,i.jsx)(n.li,{children:"Format error responses consistently?"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We'll tackle these questions in the next chapter."})]})}function u(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},696140:function(e,n,t){t.d(n,{Z:function(){return r}});let r=t.p+"assets/images/img-0c2fc34c17e9ca5ab24ca490b332cc85.png"},250065:function(e,n,t){t.d(n,{Z:function(){return a},a:function(){return o}});var r=t(667294);let i={},s=r.createContext(i);function o(e){let n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);