"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["70643"],{388531:function(n,e,i){i.r(e),i.d(e,{metadata:()=>t,contentTitle:()=>c,default:()=>g,assets:()=>d,toc:()=>s,frontMatter:()=>a});var t=JSON.parse('{"id":"docs/\u7EC4\u4EF6\u5217\u8868/\u7F16\u7801\u89E3\u7801/\u4E8C\u8FDB\u5236\u7F16\u89E3\u7801-gbinary","title":"Binary","description":"The gbinary package in the GoFrame framework provides encoding and decoding functionality for converting between binary data and various data types. It is widely used in network communication and data file operations. It supports precise bit processing for integer data and offers a range of encoding and decoding interfaces to ensure efficient data conversion across different types and platforms.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u7EC4\u4EF6\u5217\u8868/\u7F16\u7801\u89E3\u7801/\u4E8C\u8FDB\u5236\u7F16\u89E3\u7801-gbinary.md","sourceDirName":"docs/\u7EC4\u4EF6\u5217\u8868/\u7F16\u7801\u89E3\u7801","slug":"/docs/components/encoding-gbinary","permalink":"/en/docs/components/encoding-gbinary","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u7EC4\u4EF6\u5217\u8868/\u7F16\u7801\u89E3\u7801/\u4E8C\u8FDB\u5236\u7F16\u89E3\u7801-gbinary.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732443619000,"sidebarPosition":1,"frontMatter":{"slug":"/docs/components/encoding-gbinary","title":"Binary","sidebar_position":1,"hide_title":true,"keywords":["GoFrame","GoFrame Framework","gbinary","binary encoding/decoding","data conversion","network communication","data encoding","decoding","integer processing","bit manipulation"],"description":"The gbinary package in the GoFrame framework provides encoding and decoding functionality for converting between binary data and various data types. It is widely used in network communication and data file operations. It supports precise bit processing for integer data and offers a range of encoding and decoding interfaces to ensure efficient data conversion across different types and platforms."},"sidebar":"mainSidebar","previous":{"title":"General Codec - FAQ","permalink":"/en/docs/components/encoding-gjson-faq"},"next":{"title":"BASE64","permalink":"/en/docs/components/encoding-gbase64"}}'),o=i("785893"),r=i("250065");let a={slug:"/docs/components/encoding-gbinary",title:"Binary",sidebar_position:1,hide_title:!0,keywords:["GoFrame","GoFrame Framework","gbinary","binary encoding/decoding","data conversion","network communication","data encoding","decoding","integer processing","bit manipulation"],description:"The gbinary package in the GoFrame framework provides encoding and decoding functionality for converting between binary data and various data types. It is widely used in network communication and data file operations. It supports precise bit processing for integer data and offers a range of encoding and decoding interfaces to ensure efficient data conversion across different types and platforms."},c=void 0,d={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Usage Example",id:"usage-example",level:2}];function l(n){let e={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"GoFrame"})," framework provides an independent binary data operation package ",(0,o.jsx)(e.code,{children:"gbinary"}),", which is mainly used for mutual conversion between various data types and ",(0,o.jsx)(e.code,{children:"[]byte"})," binary types; it also provides precise bit processing functions for integer data. It is commonly used for data encoding/decoding during network communication and data file operations."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Usage"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'import "github.com/gogf/gf/v2/encoding/gbinary"\n'})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Interface Documentation"}),":"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.a,{href:"https://pkg.go.dev/github.com/gogf/gf/v2/encoding/gbinary",children:"https://pkg.go.dev/github.com/gogf/gf/v2/encoding/gbinary"})}),"\n",(0,o.jsx)(e.p,{children:"The interface documentation for binary data structure conversion processing is as follows:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:"func Encode(vs ...interface{}) ([]byte, error)\nfunc EncodeInt(i int) []byte\nfunc EncodeInt8(i int8) []byte\nfunc EncodeInt16(i int16) []byte\nfunc EncodeInt32(i int32) []byte\nfunc EncodeInt64(i int64) []byte\nfunc EncodeUint(i uint) []byte\nfunc EncodeUint8(i uint8) []byte\nfunc EncodeUint16(i uint16) []byte\nfunc EncodeUint32(i uint32) []byte\nfunc EncodeUint64(i uint64) []byte\nfunc EncodeBool(b bool) []byte\nfunc EncodeFloat32(f float32) []byte\nfunc EncodeFloat64(f float64) []byte\nfunc EncodeString(s string) []byte\n\nfunc Decode(b []byte, vs ...interface{}) error\nfunc DecodeToInt(b []byte) int\nfunc DecodeToInt8(b []byte) int8\nfunc DecodeToInt16(b []byte) int16\nfunc DecodeToInt32(b []byte) int32\nfunc DecodeToInt64(b []byte) int64\nfunc DecodeToUint(b []byte) uint\nfunc DecodeToUint8(b []byte) uint8\nfunc DecodeToUint16(b []byte) uint16\nfunc DecodeToUint32(b []byte) uint32\nfunc DecodeToUint64(b []byte) uint64\nfunc DecodeToBool(b []byte) bool\nfunc DecodeToFloat32(b []byte) float32\nfunc DecodeToFloat64(b []byte) float64\nfunc DecodeToString(b []byte) string\n"})}),"\n",(0,o.jsx)(e.p,{children:"The interface documentation for bit-level processing support is as follows:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:"func EncodeBits(bits []Bit, i int, l int) []Bit\nfunc EncodeBitsWithUint(bits []Bit, ui uint, l int) []Bit\nfunc EncodeBitsToBytes(bits []Bit) []byte\nfunc DecodeBits(bits []Bit) uint\nfunc DecodeBitsToUint(bits []Bit) uint\nfunc DecodeBytesToBits(bs []byte) []Bit\n"})}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"Bit"})," type represents a binary digit (0 or 1), defined as follows:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:"type Bit int8\n"})}),"\n",(0,o.jsx)(e.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,o.jsx)(e.p,{children:"Let's look at a comprehensive example of binary operations, demonstrating most binary conversion operations."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "github.com/gogf/gf/v2/encoding/gbinary"\n    "github.com/gogf/gf/v2/os/gctx"\n    "github.com/gogf/gf/v2/os/glog"\n)\n\nfunc main() {\n    // Use gbinary.Encode to perform binary packing on basic data types\n    if buffer := gbinary.Encode(18, 300, 1.01); buffer != nil {\n        // glog.Error(err)\n    } else {\n        fmt.Println(buffer)\n    }\n\n    // Use gbinary.Decode for integer binary unpacking. Note that the second and subsequent parameters are pointers to fixed-length integer variables.\n    // Examples include: int8/16/32/64, uint8/16/32/64, float32/64\n    // 1.01 here defaults to float64 type (on a 64-bit system)\n    if buffer := gbinary.Encode(18, 300, 1.01); buffer != nil {\n        // glog.Error(err)\n    } else {\n        var i1 int8\n        var i2 int16\n        var f3 float64\n        if err := gbinary.Decode(buffer, &i1, &i2, &f3); err != nil {\n            glog.Error(gctx.New(), err)\n        } else {\n            fmt.Println(i1, i2, f3)\n        }\n    }\n\n    // Encode/Decode int, automatically recognize variable length\n    fmt.Println(gbinary.DecodeToInt(gbinary.EncodeInt(1)))\n    fmt.Println(gbinary.DecodeToInt(gbinary.EncodeInt(300)))\n    fmt.Println(gbinary.DecodeToInt(gbinary.EncodeInt(70000)))\n    fmt.Println(gbinary.DecodeToInt(gbinary.EncodeInt(2000000000)))\n    fmt.Println(gbinary.DecodeToInt(gbinary.EncodeInt(500000000000)))\n\n    // Encode/Decode uint, automatically recognize variable length\n    fmt.Println(gbinary.DecodeToUint(gbinary.EncodeUint(1)))\n    fmt.Println(gbinary.DecodeToUint(gbinary.EncodeUint(300)))\n    fmt.Println(gbinary.DecodeToUint(gbinary.EncodeUint(70000)))\n    fmt.Println(gbinary.DecodeToUint(gbinary.EncodeUint(2000000000)))\n    fmt.Println(gbinary.DecodeToUint(gbinary.EncodeUint(500000000000)))\n\n    // Encode/Decode int8/16/32/64\n    fmt.Println(gbinary.DecodeToInt8(gbinary.EncodeInt8(int8(100))))\n    fmt.Println(gbinary.DecodeToInt16(gbinary.EncodeInt16(int16(100))))\n    fmt.Println(gbinary.DecodeToInt32(gbinary.EncodeInt32(int32(100))))\n    fmt.Println(gbinary.DecodeToInt64(gbinary.EncodeInt64(int64(100))))\n\n    // Encode/Decode uint8/16/32/64\n    fmt.Println(gbinary.DecodeToUint8(gbinary.EncodeUint8(uint8(100))))\n    fmt.Println(gbinary.DecodeToUint16(gbinary.EncodeUint16(uint16(100))))\n    fmt.Println(gbinary.DecodeToUint32(gbinary.EncodeUint32(uint32(100))))\n    fmt.Println(gbinary.DecodeToUint64(gbinary.EncodeUint64(uint64(100))))\n\n    // Encode/Decode string\n    fmt.Println(gbinary.DecodeToString(gbinary.EncodeString("I\'m string!")))\n}\n'})}),"\n",(0,o.jsx)(e.p,{children:"The result of the above program execution is:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"[18 44 1 41 92 143 194 245 40 240 63]\n18 300 1.01\n1\n300\n70000\n2000000000\n500000000000\n1\n300\n70000\n2000000000\n500000000000\n100\n100\n100\n100\n100\n100\n100\n100\nI'm string!\n"})}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.strong,{children:"Encoding"})}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"gbinary.Encode"})," method is a very powerful and flexible method that can convert all basic types to binary type (",(0,o.jsx)(e.code,{children:"[]byte"}),"). Inside the ",(0,o.jsx)(e.code,{children:"gbinary.Encode"})," method, the variable length is calculated automatically, using the smallest binary length to store the binary value of the variable. For example, for an ",(0,o.jsx)(e.code,{children:"int"})," type variable with a value of ",(0,o.jsx)(e.code,{children:"1"}),", ",(0,o.jsx)(e.code,{children:"gbinary.Encode"})," will use only ",(0,o.jsx)(e.code,{children:"1"})," byte to store it, while a variable with a value of ",(0,o.jsx)(e.code,{children:"300"})," will use ",(0,o.jsx)(e.code,{children:"2"})," bytes to store it, minimizing the storage space of the binary result. Therefore, when parsing, pay great attention to the length of ",(0,o.jsx)(e.code,{children:"[]byte"}),". It is recommended to use fixed-length basic types like ",(0,o.jsx)(e.code,{children:"int8/16/32/64"})," when encoding/decoding binary to ensure the correct variable form is used during parsing, reducing the chance of errors."]}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"gbinary"})," package also provides a series of ",(0,o.jsx)(e.code,{children:"gbinary.Encode*"})," methods for converting basic data types to binary. In particular, ",(0,o.jsx)(e.code,{children:"gbinary.EncodeInt/gbinary.EncodeUint"})," internally recognizes the variable value size and returns a variable-length ",(0,o.jsx)(e.code,{children:"[]byte"})," value, with a length range of ",(0,o.jsx)(e.code,{children:"1/2/4/8"}),"."]}),"\n",(0,o.jsxs)(e.ol,{start:"2",children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.strong,{children:"Decoding"})}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["In binary type parsing operations, the length of the binary (",(0,o.jsx)(e.code,{children:"[]byte"})," length) is crucial. Only with the correct length can correct parsing be executed. Therefore, the length of the variables given to ",(0,o.jsx)(e.code,{children:"gbinary.Decode"})," must be of a specific length type, such as ",(0,o.jsx)(e.code,{children:"int8/16/32/64"}),", ",(0,o.jsx)(e.code,{children:"uint8/16/32/64"}),", or ",(0,o.jsx)(e.code,{children:"float32/64"}),". If the second variable address given corresponds to the ",(0,o.jsx)(e.code,{children:"int/uint"})," variable type, which has an indeterminate length, parsing will fail."]}),"\n",(0,o.jsxs)(e.p,{children:["Furthermore, the ",(0,o.jsx)(e.code,{children:"gbinary"})," package also provides a series of ",(0,o.jsx)(e.code,{children:"gbinary.DecodeTo*"})," methods for converting binary to specific data types. Importantly, the ",(0,o.jsx)(e.code,{children:"gbinary.DecodeToInt/gbinary.DecodeToUint"})," methods automatically recognize and parse the binary length, supporting binary parameter lengths in the range of ",(0,o.jsx)(e.code,{children:"1-8"}),"."]})]})}function g(n={}){let{wrapper:e}={...(0,r.a)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(l,{...n})}):l(n)}},250065:function(n,e,i){i.d(e,{Z:function(){return c},a:function(){return a}});var t=i(667294);let o={},r=t.createContext(o);function a(n){let e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);