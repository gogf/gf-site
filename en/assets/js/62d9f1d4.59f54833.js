"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["66261"],{88742:function(e,n,a){a.r(n),a.d(n,{metadata:()=>i,contentTitle:()=>d,default:()=>h,assets:()=>l,toc:()=>o,frontMatter:()=>t});var i=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u5206\u5E93\u5206\u8868/ORM\u5206\u5E93\u5206\u8868-\u5206\u8868\u7279\u6027","title":"ORM Sharding - Table Sharding","description":"GoFrame ORM Table Sharding provides a simple and efficient table partitioning feature, supporting custom sharding rules to easily handle large data volume scenarios.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u5206\u5E93\u5206\u8868/ORM\u5206\u5E93\u5206\u8868-\u5206\u8868\u7279\u6027.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u5206\u5E93\u5206\u8868","slug":"/docs/core/gdb-sharding-table","permalink":"/en/docs/core/gdb-sharding-table","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u5206\u5E93\u5206\u8868/ORM\u5206\u5E93\u5206\u8868-\u5206\u8868\u7279\u6027.md","tags":[],"version":"current","lastUpdatedBy":"John Guo","lastUpdatedAt":1742194305000,"sidebarPosition":1000,"frontMatter":{"slug":"/docs/core/gdb-sharding-table","title":"ORM Sharding - Table Sharding","sidebar_position":1000,"hide_title":true,"keywords":["Table Sharding","Horizontal Sharding","Table Partitioning","sharding","table sharding"],"description":"GoFrame ORM Table Sharding provides a simple and efficient table partitioning feature, supporting custom sharding rules to easily handle large data volume scenarios."},"sidebar":"mainSidebar","previous":{"title":"ORM - Sharding","permalink":"/en/docs/core/gdb-sharding"},"next":{"title":"ORM Sharding - Database Sharding","permalink":"/en/docs/core/gdb-sharding-schema"}}'),r=a("785893"),s=a("250065");let t={slug:"/docs/core/gdb-sharding-table",title:"ORM Sharding - Table Sharding",sidebar_position:1e3,hide_title:!0,keywords:["Table Sharding","Horizontal Sharding","Table Partitioning","sharding","table sharding"],description:"GoFrame ORM Table Sharding provides a simple and efficient table partitioning feature, supporting custom sharding rules to easily handle large data volume scenarios."},d=void 0,l={},o=[{value:"Basic Introduction",id:"basic-introduction",level:2},{value:"Advantages of Table Sharding",id:"advantages-of-table-sharding",level:2},{value:"Application Scenarios",id:"application-scenarios",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Sharding Configuration",id:"sharding-configuration",level:3},{value:"Default Sharding Rule",id:"default-sharding-rule",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Basic CRUD Operations",id:"basic-crud-operations",level:3},{value:"Custom Sharding Rules",id:"custom-sharding-rules",level:3},{value:"Important Considerations",id:"important-considerations",level:2},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Using <code>Hook</code> for Dynamic Table Sharding",id:"using-hook-for-dynamic-table-sharding",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"basic-introduction",children:"Basic Introduction"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ORM"})," Table Sharding is a data partitioning solution provided by ",(0,r.jsx)(n.code,{children:"GoFrame ORM"})," that allows developers to distribute data from a logical table across multiple physical tables. Table sharding is an effective approach to address issues with large table data volumes. By distributing data across different tables, query performance and system scalability can be significantly improved."]}),"\n",(0,r.jsx)(n.h2,{id:"advantages-of-table-sharding",children:"Advantages of Table Sharding"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Improved Query Performance"}),": Reduces single table data volume, decreases index depth, and improves query efficiency"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimized Write Performance"}),": Distributes write pressure, reduces lock contention, and increases concurrent write capacity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simplified Maintenance"}),": Facilitates data backup, recovery, and archiving by shard"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Overcomes Single Table Data Limitations"}),": Avoids database single table data volume limits"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Increased Availability"}),": Failure of a single shard does not affect the entire system"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"application-scenarios",children:"Application Scenarios"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Large-Scale User Systems"}),": Sharding by user ID to handle massive user data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Order Systems"}),": Sharding by order ID or time to process high-concurrency order writes and queries"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logging Systems"}),": Sharding by time for easier log storage and cleanup"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"IoT Data"}),": Sharding by device ID or time to handle massive sensor data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Social Media"}),": Sharding by user ID to handle large volumes of user-generated social data"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GoFrame ORM"})," provides simple and easy-to-use table sharding APIs through the ",(0,r.jsx)(n.code,{children:"Sharding"})," and ",(0,r.jsx)(n.code,{children:"ShardingValue"})," methods."]}),"\n",(0,r.jsx)(n.h3,{id:"sharding-configuration",children:"Sharding Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Create sharding configuration\nshardingConfig := gdb.ShardingConfig{\n    Table: gdb.ShardingTableConfig{\n        Enable: true,      // Enable table sharding\n        Prefix: "user_",   // Table prefix\n        Rule: &gdb.DefaultShardingRule{\n            TableCount: 4, // Number of sharded tables\n        },\n    },\n}\n\n// Use sharding configuration and sharding value\nmodel := db.Model("user").\n    Sharding(shardingConfig).\n    ShardingValue(10001) // Sharding value, used to calculate which table the data routes to, typically the primary key ID value\n'})}),"\n",(0,r.jsx)(n.h3,{id:"default-sharding-rule",children:"Default Sharding Rule"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GoFrame ORM"})," includes a built-in default sharding rule ",(0,r.jsx)(n.code,{children:"DefaultShardingRule"}),", which determines the table name based on the hash modulo of the sharding value:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Default sharding rule implementation\nfunc (r *DefaultShardingRule) TableName(ctx context.Context, config ShardingTableConfig, value any) (string, error) {\n    if r.TableCount == 0 {\n        return "", gerror.NewCode(\n            gcode.CodeInvalidParameter, "table count should not be 0 using DefaultShardingRule when table sharding enabled",\n        )\n    }\n    hashValue, err := getHashValue(value)\n    if err != nil {\n        return "", err\n    }\n    tableIndex := hashValue % uint64(r.TableCount)\n    return fmt.Sprintf("%s%d", config.Prefix, tableIndex), nil\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,r.jsxs)(n.p,{children:["First, using ",(0,r.jsx)(n.code,{children:"MySQL"})," database as an example, we need to create the corresponding database table structure. For table sharding examples, we need to create multiple physical tables with the same structure:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE `user_0` (\n  `id` int(11) NOT NULL,\n  `name` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\nCREATE TABLE `user_1` (\n  `id` int(11) NOT NULL,\n  `name` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\nCREATE TABLE `user_2` (\n  `id` int(11) NOT NULL,\n  `name` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\nCREATE TABLE `user_3` (\n  `id` int(11) NOT NULL,\n  `name` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"basic-crud-operations",children:"Basic CRUD Operations"}),"\n",(0,r.jsxs)(n.p,{children:["The following example demonstrates how to perform basic ",(0,r.jsx)(n.code,{children:"CRUD"})," operations in a sharded table environment:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    _ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/frame/g"\n)\n\n// User structure\ntype User struct {\n    Id   int    `json:"id"`\n    Name string `json:"name"`\n}\n\nfunc main() {\n    // Create sharding configuration\n    shardingConfig := gdb.ShardingConfig{\n        Table: gdb.ShardingTableConfig{\n            Enable: true,    // Enable table sharding\n            Prefix: "user_", // Table prefix\n            Rule: &gdb.DefaultShardingRule{\n                TableCount: 4, // Number of sharded tables\n            },\n        },\n    }\n\n    // Prepare test data\n    user := User{\n        Id:   1,\n        Name: "John",\n    }\n\n    // Create sharded model\n    db := g.DB()\n    db.SetDebug(true)\n    model := db.Model("user").\n        Sharding(shardingConfig).\n        ShardingValue(user.Id) // Use user ID as sharding value\n\n    // Insert data\n    _, err := model.Data(user).Insert()\n    if err != nil {\n        panic(err)\n    }\n    // INSERT INTO `user_1`(`id`,`name`) VALUES(1,\'John\')\n\n    // Query data\n    var result User\n    err = model.Where("id", user.Id).Scan(&result)\n    if err != nil {\n        panic(err)\n    }\n    // SELECT * FROM `user_1` WHERE `id`=1 LIMIT 1\n    g.DumpJson(result)\n\n    // Update data\n    _, err = model.Data(g.Map{"name": "John Doe"}).\n        Where("id", user.Id).\n        Update()\n    if err != nil {\n        panic(err)\n    }\n    // UPDATE `user_1` SET `name`=\'John Doe\' WHERE `id`=1\n\n    // Delete data\n    _, err = model.Where("id", user.Id).Delete()\n    if err != nil {\n        panic(err)\n    }\n    // DELETE FROM `user_1` WHERE `id`=1\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"custom-sharding-rules",children:"Custom Sharding Rules"}),"\n",(0,r.jsxs)(n.p,{children:["You can create custom sharding rules by implementing the ",(0,r.jsx)(n.code,{children:"ShardingRule"})," interface:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    _ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n\n    "context"\n    "fmt"\n    "time"\n\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/os/gtime"\n)\n\n// TimeShardingRule implements time-based table sharding\ntype TimeShardingRule struct{}\n\n// TableName implements monthly table sharding rule\nfunc (r *TimeShardingRule) TableName(ctx context.Context, config gdb.ShardingTableConfig, value any) (string, error) {\n    // Convert sharding value to time\n    t, ok := value.(time.Time)\n    if !ok {\n        return "", fmt.Errorf("sharding value must be time.Time for TimeShardingRule")\n    }\n\n    // Generate table name by year and month, e.g., log_202501\n    return fmt.Sprintf("%s%04d%02d", config.Prefix, t.Year(), t.Month()), nil\n}\n\n// SchemaName implements database sharding interface\nfunc (r *TimeShardingRule) SchemaName(ctx context.Context, config gdb.ShardingSchemaConfig, value any) (string, error) {\n    // Not implementing database sharding, return empty string\n    return "", nil\n}\n\nfunc main() {\n    // Create time-based table sharding configuration\n    shardingConfig := gdb.ShardingConfig{\n        Table: gdb.ShardingTableConfig{\n            Enable: true,                // Enable table sharding\n            Prefix: "log_",              // Table prefix\n            Rule:   &TimeShardingRule{}, // Custom sharding rule\n        },\n    }\n\n    // Current time as sharding value\n    now := gtime.Now().Time\n\n    // Create sharded model\n    db := g.DB()\n    db.SetDebug(true)\n    model := db.Model("log").\n        Sharding(shardingConfig).\n        ShardingValue(now) // Use time as sharding value\n\n    // Insert log data\n    _, err := model.Data(g.Map{\n        "content": "System startup",\n        "level":   "info",\n        "time":    now,\n    }).Insert()\n    if err != nil {\n        panic(err)\n    }\n    // INSERT INTO `log_202503`(`content`,`level`,`time`) VALUES(\'System startup\',\'info\',\'2025-03-13 12:02:54\')\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"important-considerations",children:"Important Considerations"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sharding Value Must Be Provided"}),": When table sharding is enabled, a sharding value must be provided via the ",(0,r.jsx)(n.code,{children:"ShardingValue"})," method, otherwise an error will be returned"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sharding Rule Must Be Set"}),": When table sharding is enabled, a sharding rule must be set, otherwise an error will be returned"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cross-Shard Query Limitations"}),": By default, queries are only routed to a single sharded table; for cross-shard queries, custom implementation is required"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transaction Limitations"}),": Table sharding transactions can only be performed within the same database; cross-database table sharding transactions require distributed transactions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Table Structure Consistency"}),": All sharded tables should maintain consistent structure"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"advanced-usage",children:"Advanced Usage"}),"\n",(0,r.jsxs)(n.h3,{id:"using-hook-for-dynamic-table-sharding",children:["Using ",(0,r.jsx)(n.code,{children:"Hook"})," for Dynamic Table Sharding"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GoFrame ORM"})," provides a powerful ",(0,r.jsx)(n.code,{children:"Hook"})," mechanism that can be used to implement more flexible sharding strategies:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Using Hook for dynamic table sharding\nmodel := db.Model("log").Hook(gdb.HookHandler{\n    Select: func(ctx context.Context, in *gdb.HookSelectInput) (result gdb.Result, err error) {\n        // Dynamically determine table name based on query conditions\n        in.Table = "log_" + determineTableSuffix(in.Model.GetWhere())\n        return in.Next(ctx)\n    },\n    Insert: func(ctx context.Context, in *gdb.HookInsertInput) (result sql.Result, err error) {\n        // Dynamically determine table name based on insert data\n        in.Table = "log_" + determineTableSuffixFromData(in.Data)\n        return in.Next(ctx)\n    },\n    // Other Hook methods...\n})\n'})}),"\n",(0,r.jsxs)(n.p,{children:["For more information about the ",(0,r.jsx)(n.code,{children:"Hook"})," feature, please refer to the chapter: ",(0,r.jsx)(n.a,{href:"/en/docs/core/gdb-chaining-hook",children:"ORM Chain Operations-Hook Feature"})]}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsxs)(n.p,{children:["The table sharding feature of ",(0,r.jsx)(n.code,{children:"GoFrame ORM"})," provides a simple yet powerful data partitioning solution suitable for handling large-scale data scenarios. By properly configuring sharding strategies, you can significantly improve system performance and scalability. Whether using the built-in default sharding rules or implementing custom sharding logic, ",(0,r.jsx)(n.code,{children:"GoFrame"})," provides flexible API support."]}),"\n",(0,r.jsx)(n.p,{children:"In practical applications, it is recommended to choose appropriate sharding keys and strategies based on business characteristics, and pay attention to handling cross-shard queries and transaction issues."})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},250065:function(e,n,a){a.d(n,{Z:function(){return d},a:function(){return t}});var i=a(667294);let r={},s=i.createContext(r);function t(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);