"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["91496"],{73262:function(e,n,s){s.r(n),s.d(n,{metadata:()=>t,contentTitle:()=>o,default:()=>h,assets:()=>d,toc:()=>c,frontMatter:()=>a});var t=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u6A21\u578B\u5173\u8054/\u6A21\u578B\u5173\u8054-\u9759\u6001\u5173\u8054-With\u7279\u6027","title":"Model Association - With","description":"The With feature in the GoFrame framework demonstrates how to achieve model association and data queries through examples. It introduces data structure definition, transaction operations, data writing and querying, helping developers better understand and use the GoFrame framework for efficient development.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u6A21\u578B\u5173\u8054/\u6A21\u578B\u5173\u8054-\u9759\u6001\u5173\u8054-With\u7279\u6027.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u6A21\u578B\u5173\u8054","slug":"/docs/core/gdb-chaining-relation-with","permalink":"/en/docs/core/gdb-chaining-relation-with","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u6A21\u578B\u5173\u8054/\u6A21\u578B\u5173\u8054-\u9759\u6001\u5173\u8054-With\u7279\u6027.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732541616000,"sidebarPosition":1,"frontMatter":{"slug":"/docs/core/gdb-chaining-relation-with","title":"Model Association - With","sidebar_position":1,"hide_title":true,"keywords":["GoFrame","With Feature","ORM","Model Association","Data Query","Transaction Operation","Data Structure","Go Language","Database","SQL"],"description":"The With feature in the GoFrame framework demonstrates how to achieve model association and data queries through examples. It introduces data structure definition, transaction operations, data writing and querying, helping developers better understand and use the GoFrame framework for efficient development."},"sidebar":"mainSidebar","previous":{"title":"Model Association - ScanList","permalink":"/en/docs/core/gdb-chaining-relation-scan-list"},"next":{"title":"ORM Model - Object Input","permalink":"/en/docs/core/gdb-chaining-object-parameter"}}'),i=s("785893"),r=s("250065");let a={slug:"/docs/core/gdb-chaining-relation-with",title:"Model Association - With",sidebar_position:1,hide_title:!0,keywords:["GoFrame","With Feature","ORM","Model Association","Data Query","Transaction Operation","Data Structure","Go Language","Database","SQL"],description:"The With feature in the GoFrame framework demonstrates how to achieve model association and data queries through examples. It introduces data structure definition, transaction operations, data writing and querying, helping developers better understand and use the GoFrame framework for efficient development."},o=void 0,d={},c=[{value:"1. Design Background",id:"1-design-background",level:2},{value:"2. An Example",id:"2-an-example",level:2},{value:"1. Data Structure",id:"1-data-structure",level:3},{value:"2. Data Structure",id:"2-data-structure",level:3},{value:"3. Data Insertion",id:"3-data-insertion",level:3},{value:"4. Data Query",id:"4-data-query",level:3},{value:"5. List Query",id:"5-list-query",level:3},{value:"6. Conditions and Sorting",id:"6-conditions-and-sorting",level:3},{value:"7. <code>unscoped</code> Tag",id:"7-unscoped-tag",level:3},{value:"3. Detailed Explanation",id:"3-detailed-explanation",level:2},{value:"1. <code>gmeta</code> Package",id:"1-gmeta-package",level:3},{value:"2. Model Association Specification",id:"2-model-association-specification",level:3},{value:"3. <code>With/WithAll</code>",id:"3-withwithall",level:3},{value:"1) Introduction",id:"1-introduction",level:4},{value:"2) Only Associate User Detail Model",id:"2-only-associate-user-detail-model",level:4},{value:"3) Only Associate User Score Model",id:"3-only-associate-user-score-model",level:4},{value:"4) Do Not Associate Any Model Query",id:"4-do-not-associate-any-model-query",level:4},{value:"4. Usage Restrictions",id:"4-usage-restrictions",level:2},{value:"1. Field Query and Filtering",id:"1-field-query-and-filtering",level:3},{value:"2. Must Exist Association Field Property",id:"2-must-exist-association-field-property",level:3},{value:"5. Recursive Association",id:"5-recursive-association",level:2},{value:"6. Model Examples",id:"6-model-examples",level:2},{value:"1. Nested Associated Models",id:"1-nested-associated-models",level:3},{value:"2. Basic Model Nesting",id:"2-basic-model-nesting",level:3},{value:"3. Models Without <code>meta</code> Information",id:"3-models-without-meta-information",level:3},{value:"7. Future Improvements",id:"7-future-improvements",level:2}];function l(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"1-design-background",children:"1. Design Background"}),"\n",(0,i.jsxs)(n.p,{children:["Everyone knows that usability and maintainability have always been the focus of ",(0,i.jsx)(n.code,{children:"goframe"}),", and it's also a significant difference between ",(0,i.jsx)(n.code,{children:"goframe"})," and other frameworks and components. ",(0,i.jsx)(n.code,{children:"goframe"})," does not adopt other common ",(0,i.jsx)(n.code,{children:"ORM"})," model association designs like ",(0,i.jsx)(n.code,{children:"BelongsTo"}),", ",(0,i.jsx)(n.code,{children:"HasOne"}),", ",(0,i.jsx)(n.code,{children:"HasMany"}),", ",(0,i.jsx)(n.code,{children:"ManyToMany"}),", which are cumbersome to maintain due to foreign key constraints, additional tag annotations, etc., imposing a certain cognitive load on developers. Therefore, the framework is inclined not to inject overly complex tag content, associated attributes, or methods into model structures and consistently tries to simplify the design with the goal of making model association queries as understandable and easy to use as possible. Before learning more about the ",(0,i.jsx)(n.code,{children:"With"})," feature, it is recommended to first understand ",(0,i.jsx)(n.a,{href:"/en/docs/core/gdb-chaining-relation-scan-list",children:"Model Association - ScanList"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Through a series of project practices, we found that although ",(0,i.jsx)(n.code,{children:"ScanList"})," maintains model associations from a runtime business logic perspective, this association maintenance is not as straightforward as expected. Therefore, we continue to improve and introduce the ",(0,i.jsx)(n.code,{children:"With"})," model association feature, which can easily maintain the association relationships through models. Of course, this feature is still dedicated to enhancing the usability and maintainability of the overall framework, and it can be seen as a combination and improvement of ",(0,i.jsx)(n.code,{children:"ScanList"})," and model association maintenance."]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"With"})," feature is currently experimental."]})}),"\n",(0,i.jsx)(n.h2,{id:"2-an-example",children:"2. An Example"}),"\n",(0,i.jsxs)(n.p,{children:["Let's start with a simple example to help better understand the ",(0,i.jsx)(n.code,{children:"With"})," feature, which is an improved version of the same example from the previous ",(0,i.jsx)(n.code,{children:"ScanList"})," section."]}),"\n",(0,i.jsx)(n.h3,{id:"1-data-structure",children:"1. Data Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"# User Table\nCREATE TABLE `user` (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  name varchar(45) NOT NULL,\n  PRIMARY KEY (id)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n# User Detail\nCREATE TABLE `user_detail` (\n  uid  int(10) unsigned NOT NULL AUTO_INCREMENT,\n  address varchar(45) NOT NULL,\n  PRIMARY KEY (uid)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n# User Scores\nCREATE TABLE `user_scores` (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  uid int(10) unsigned NOT NULL,\n  score int(10) unsigned NOT NULL,\n  PRIMARY KEY (id)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-data-structure",children:"2. Data Structure"}),"\n",(0,i.jsx)(n.p,{children:"Based on the table definitions, we can tell:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The user table and user details have a ",(0,i.jsx)(n.code,{children:"1:1"})," relationship."]}),"\n",(0,i.jsxs)(n.li,{children:["The user table and user scores have a ",(0,i.jsx)(n.code,{children:"1:N"})," relationship."]}),"\n",(0,i.jsxs)(n.li,{children:["We did not demonstrate a ",(0,i.jsx)(n.code,{children:"N:N"})," relationship here because, compared to a ",(0,i.jsx)(n.code,{children:"1:N"})," query, it's just an additional association or one more query, and the final processing method is similar to ",(0,i.jsx)(n.code,{children:"1:N"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Golang"})," model can be defined as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// User Detail\ntype UserDetail struct {\n    g.Meta `orm:"table:user_detail"`\n    Uid        int    `json:"uid"`\n    Address    string `json:"address"`\n}\n// User Scores\ntype UserScores struct {\n    g.Meta `orm:"table:user_scores"`\n    Id         int `json:"id"`\n    Uid        int `json:"uid"`\n    Score      int `json:"score"`\n}\n// User Information\ntype User struct {\n    g.Meta `orm:"table:user"`\n    Id         int           `json:"id"`\n    Name       string        `json:"name"`\n    UserDetail *UserDetail   `orm:"with:uid=id"`\n    UserScores []*UserScores `orm:"with:uid=id"`\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-data-insertion",children:"3. Data Insertion"}),"\n",(0,i.jsxs)(n.p,{children:["To simplify the example, we create ",(0,i.jsx)(n.code,{children:"5"})," user records, using transactional operations:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["User information, ",(0,i.jsx)(n.code,{children:"id"})," ranges from ",(0,i.jsx)(n.code,{children:"1-5"}),", ",(0,i.jsx)(n.code,{children:"name"})," ranges from ",(0,i.jsx)(n.code,{children:"name_1"})," to ",(0,i.jsx)(n.code,{children:"name_5"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Simultaneously create ",(0,i.jsx)(n.code,{children:"5"})," user detail records, where ",(0,i.jsx)(n.code,{children:"address"})," data ranges from ",(0,i.jsx)(n.code,{children:"address_1"})," to ",(0,i.jsx)(n.code,{children:"address_5"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Each user has ",(0,i.jsx)(n.code,{children:"5"})," score entries, scoring ",(0,i.jsx)(n.code,{children:"1-5"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"g.DB().Transaction(ctx, func(ctx context.Context, tx gdb.TX) error {\n    for i := 1; i <= 5; i++ {\n        // User.\n        user := User{\n            Name: fmt.Sprintf(`name_%d`, i),\n        }\n        lastInsertId, err := g.Model(user).Data(user).OmitEmpty().InsertAndGetId()\n        if err != nil {\n            return err\n        }\n        // Detail.\n        userDetail := UserDetail{\n            Uid:     int(lastInsertId),\n            Address: fmt.Sprintf(`address_%d`, lastInsertId),\n        }\n        _, err = g.Model(userDetail).Data(userDetail).OmitEmpty().Insert()\n        if err != nil {\n            return err\n        }\n        // Scores.\n        for j := 1; j <= 5; j++ {\n            userScore := UserScores{\n                Uid:   int(lastInsertId),\n                Score: j,\n            }\n            _, err = g.Model(userScore).Data(userScore).OmitEmpty().Insert()\n            if err != nil {\n                return err\n            }\n        }\n    }\n    return nil\n})\n"})}),"\n",(0,i.jsx)(n.p,{children:"After execution, the database data is as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"mysql> show tables;\n+----------------+\n| Tables_in_test |\n+----------------+\n| user           |\n| user_detail    |\n| user_score     |\n+----------------+\n3 rows in set (0.01 sec)\n\nmysql> select * from `user`;\n+----+--------+\n| id | name   |\n+----+--------+\n|  1 | name_1 |\n|  2 | name_2 |\n|  3 | name_3 |\n|  4 | name_4 |\n|  5 | name_5 |\n+----+--------+\n5 rows in set (0.01 sec)\n\nmysql> select * from `user_detail`;\n+-----+-----------+\n| uid | address   |\n+-----+-----------+\n|   1 | address_1 |\n|   2 | address_2 |\n|   3 | address_3 |\n|   4 | address_4 |\n|   5 | address_5 |\n+-----+-----------+\n5 rows in set (0.00 sec)\n\nmysql> select * from `user_score`;\n+----+-----+-------+\n| id | uid | score |\n+----+-----+-------+\n|  1 |   1 |     1 |\n|  2 |   1 |     2 |\n|  3 |   1 |     3 |\n|  4 |   1 |     4 |\n|  5 |   1 |     5 |\n|  6 |   2 |     1 |\n|  7 |   2 |     2 |\n|  8 |   2 |     3 |\n|  9 |   2 |     4 |\n| 10 |   2 |     5 |\n| 11 |   3 |     1 |\n| 12 |   3 |     2 |\n| 13 |   3 |     3 |\n| 14 |   3 |     4 |\n| 15 |   3 |     5 |\n| 16 |   4 |     1 |\n| 17 |   4 |     2 |\n| 18 |   4 |     3 |\n| 19 |   4 |     4 |\n| 20 |   4 |     5 |\n| 21 |   5 |     1 |\n| 22 |   5 |     2 |\n| 23 |   5 |     3 |\n| 24 |   5 |     4 |\n| 25 |   5 |     5 |\n+----+-----+-------+\n25 rows in set (0.00 sec)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-data-query",children:"4. Data Query"}),"\n",(0,i.jsxs)(n.p,{children:["With the new ",(0,i.jsx)(n.code,{children:"With"})," feature, data querying is quite straightforward. For example, to query one record:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Redefine it to avoid scrolling\n// User Detail\ntype UserDetail struct {\n    g.Meta `orm:"table:user_detail"`\n    Uid        int    `json:"uid"`\n    Address    string `json:"address"`\n}\n// User Scores\ntype UserScores struct {\n    g.Meta `orm:"table:user_scores"`\n    Id         int `json:"id"`\n    Uid        int `json:"uid"`\n    Score      int `json:"score"`\n}\n// User Information\ntype User struct {\n    g.Meta `orm:"table:user"`\n    Id         int           `json:"id"`\n    Name       string        `json:"name"`\n    UserDetail *UserDetail   `orm:"with:uid=id"`\n    UserScores []*UserScores `orm:"with:uid=id"`\n}\n\nvar user *User\n// WithAll will query fields with with tags, in this example, it will query tables corresponding to the UserDetail and UserScores structures\ng.Model(tableUser).WithAll().Where("id", 3).Scan(&user)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The above statement will query information for a user with ID ",(0,i.jsx)(n.code,{children:"3"}),", including user information, user details, and user score information. The above statement will automatically execute the following ",(0,i.jsx)(n.code,{children:"SQL"})," statements in the database:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"2021-05-02 22:29:52.634 [DEBU] [  2 ms] [default] SHOW FULL COLUMNS FROM `user`\n2021-05-02 22:29:52.635 [DEBU] [  1 ms] [default] SELECT * FROM `user` WHERE `id`=3 LIMIT 1\n2021-05-02 22:29:52.636 [DEBU] [  1 ms] [default] SHOW FULL COLUMNS FROM `user_detail`\n2021-05-02 22:29:52.637 [DEBU] [  1 ms] [default] SELECT `uid`,`address` FROM `user_detail` WHERE `uid`=3 LIMIT 1\n2021-05-02 22:29:52.643 [DEBU] [  6 ms] [default] SHOW FULL COLUMNS FROM `user_score`\n2021-05-02 22:29:52.644 [DEBU] [  0 ms] [default] SELECT `id`,`uid`,`score` FROM `user_score` WHERE `uid`=3\n"})}),"\n",(0,i.jsxs)(n.p,{children:["After execution, the information printed by ",(0,i.jsx)(n.code,{children:"g.Dump(user)"})," is as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'{\n    Id:         3,\n    Name:       "name_3",\n    UserDetail: {\n        Uid:     3,\n        Address: "address_3",\n    },\n    UserScores: [\n        {\n            Id:    11,\n            Uid:   3,\n            Score: 1,\n        },\n        {\n            Id:    12,\n            Uid:   3,\n            Score: 2,\n        },\n        {\n            Id:    13,\n            Uid:   3,\n            Score: 3,\n        },\n        {\n            Id:    14,\n            Uid:   3,\n            Score: 4,\n        },\n        {\n            Id:    15,\n            Uid:   3,\n            Score: 5,\n        },\n    ],\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"5-list-query",children:"5. List Query"}),"\n",(0,i.jsxs)(n.p,{children:["Let's see an example of querying a list through the ",(0,i.jsx)(n.code,{children:"With"})," feature:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'var users []*User\n// With(UserDetail{}) only queries the table corresponding to UserDetail in the User structure\ng.Model(users).With(UserDetail{}).Where("id>?", 3).Scan(&users)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["After execution, the data printed by ",(0,i.jsx)(n.code,{children:"g.Dump(users)"})," is as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'[\n    {\n        Id:         4,\n        Name:       "name_4",\n        UserDetail: {\n            Uid:     4,\n            Address: "address_4",\n        },\n        UserScores: [],\n    },\n    {\n        Id:         5,\n        Name:       "name_5",\n        UserDetail: {\n            Uid:     5,\n            Address: "address_5",\n        },\n        UserScores: [],\n    },\n]\n'})}),"\n",(0,i.jsx)(n.h3,{id:"6-conditions-and-sorting",children:"6. Conditions and Sorting"}),"\n",(0,i.jsxs)(n.p,{children:["When associating with the ",(0,i.jsx)(n.code,{children:"With"})," feature, additional association conditions can be specified, as well as sorting rules for multiple data results. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type User struct {\n    g.Meta `orm:"table:user"`\n    Id         int           `json:"id"`\n    Name       string        `json:"name"`\n    UserDetail *UserDetail   `orm:"with:uid=id, where:uid > 3"`\n    UserScores []*UserScores `orm:"with:uid=id, where:score>1 and score<5, order:score desc"`\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"where"})," sub-tag and ",(0,i.jsx)(n.code,{children:"order"})," sub-tag in the ",(0,i.jsx)(n.code,{children:"orm"})," tag to specify additional association conditions and sorting rules."]}),"\n",(0,i.jsxs)(n.h3,{id:"7-unscoped-tag",children:["7. ",(0,i.jsx)(n.code,{children:"unscoped"})," Tag"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"with"})," struct tag supports the ",(0,i.jsx)(n.code,{children:"unscoped"})," feature, for example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type User struct {\n    g.Meta `orm:"table:user"`\n    Id         int          `json:"id"`\n    Name       string       `json:"name"`\n    UserDetail *UserDetail  `orm:"with:uid=id, unscoped:true"`\n    UserScores []*UserScore `orm:"with:uid=id, unscoped:true"`\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"3-detailed-explanation",children:"3. Detailed Explanation"}),"\n",(0,i.jsxs)(n.p,{children:["You might be curious about some of the usages above, such as the ",(0,i.jsx)(n.code,{children:"gmeta"})," package, the ",(0,i.jsx)(n.code,{children:"WithAll"})," method, the ",(0,i.jsx)(n.code,{children:"with"})," statement in the ",(0,i.jsx)(n.code,{children:"orm"})," tag, and the ",(0,i.jsx)(n.code,{children:"Model"})," method's struct parameter recognizing table names, etc. That's right, let's talk about them in detail."]}),"\n",(0,i.jsxs)(n.h3,{id:"1-gmeta-package",children:["1. ",(0,i.jsx)(n.code,{children:"gmeta"})," Package"]}),"\n",(0,i.jsxs)(n.p,{children:["In the above data structures, you can see a ",(0,i.jsx)(n.code,{children:"g.Meta"})," struct is embedded in an ",(0,i.jsx)(n.code,{children:"embed"})," way, like:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type UserDetail struct {\n    g.Meta `orm:"table:user_detail"`\n    Uid        int    `json:"uid"`\n    Address    string `json:"address"`\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Within the ",(0,i.jsx)(n.code,{children:"GoFrame"})," framework, there are many such small component packages for implementing specific functions. The ",(0,i.jsx)(n.code,{children:"gmeta"})," package is mainly used to embed into user-defined structures, and using tags to mark the struct (like ",(0,i.jsx)(n.code,{children:"g.Meta"}),") in the ",(0,i.jsx)(n.code,{children:"gmeta"})," package with custom tag content (such as ",(0,i.jsx)(n.code,{children:'`orm:"table:user_detail"`'}),"), and can dynamically obtain these custom tag contents with specific methods at runtime. For more details, refer to the chapter: ",(0,i.jsx)(n.a,{href:"/en/docs/components/util-gmeta",children:"Metadata"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Therefore, embedding ",(0,i.jsx)(n.code,{children:"g.Meta"})," here is to label the data table name associated with the struct."]}),"\n",(0,i.jsx)(n.h3,{id:"2-model-association-specification",children:"2. Model Association Specification"}),"\n",(0,i.jsx)(n.p,{children:"In the following structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type User struct {\n    g.Meta `orm:"table:user"`\n    Id         int          `json:"id"`\n    Name       string       `json:"name"`\n    UserDetail *UserDetail  `orm:"with:uid=id"`\n    UserScores []*UserScore `orm:"with:uid=id"`\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["We bind the ",(0,i.jsx)(n.code,{children:"orm"})," tag to the specified struct property, and specify the association relationship between the current struct (table) and the target struct (table) through the ",(0,i.jsx)(n.code,{children:"with"})," statement in the ",(0,i.jsx)(n.code,{children:"orm"})," tag. The syntax of the ",(0,i.jsx)(n.code,{children:"with"})," statement is as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"with:target_table_association_field=current_structure_association_field\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The field names are ",(0,i.jsx)(n.strong,{children:"case-insensitive and ignore special characters"}),". For example, the following forms of associations can all be automatically recognized:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"with:UID=ID\nwith:Uid=Id\nwith:U_ID=id\n"})}),"\n",(0,i.jsx)(n.p,{children:"If the association fields of both tables have the same name, you can just write one, such as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"with:uid\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, the table corresponding to the ",(0,i.jsx)(n.code,{children:"UserDetail"})," property is ",(0,i.jsx)(n.code,{children:"user_detail"}),", and the table corresponding to the ",(0,i.jsx)(n.code,{children:"UserScores"})," property is ",(0,i.jsx)(n.code,{children:"user_score"}),". Both are associated with the ",(0,i.jsx)(n.code,{children:"user"})," table of the current ",(0,i.jsx)(n.code,{children:"User"})," struct using ",(0,i.jsx)(n.code,{children:"uid"}),", and the associated field of the target ",(0,i.jsx)(n.code,{children:"user"})," table is ",(0,i.jsx)(n.code,{children:"id"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"3-withwithall",children:["3. ",(0,i.jsx)(n.code,{children:"With/WithAll"})]}),"\n",(0,i.jsx)(n.h4,{id:"1-introduction",children:"1) Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["By default, even if the properties in our struct have ",(0,i.jsx)(n.code,{children:"orm"})," tags with ",(0,i.jsx)(n.code,{children:"with"})," statements, the ",(0,i.jsx)(n.code,{children:"ORM"})," component will not enable the ",(0,i.jsx)(n.code,{children:"With"})," feature for association queries by default. It needs to be enabled by the ",(0,i.jsx)(n.code,{children:"With/WithAll"})," method."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"With"}),": Specify the association query tables by specifying the property objects."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"WithAll"}),": Enable association queries for all property structures with ",(0,i.jsx)(n.code,{children:"with"})," statements in the operating object."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In our example, the ",(0,i.jsx)(n.code,{children:"WithAll"})," method is used, so all property model association queries in the ",(0,i.jsx)(n.code,{children:"User"})," table are automatically enabled. As long as the property struct is associated with a table and the ",(0,i.jsx)(n.code,{children:"orm"})," tag contains a ",(0,i.jsx)(n.code,{children:"with"})," statement, it will automatically query data and bind data according to the model structure association relationship. If we only enable association queries for some properties rather than all property models, we can use the ",(0,i.jsx)(n.code,{children:"With"})," method to specify. And the ",(0,i.jsx)(n.code,{children:"With"})," method can specify multiple associated model automatic queries. The ",(0,i.jsx)(n.code,{children:"WithAll"})," in this example is equivalent to:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'var user *User\ng.Model(tableUser).With(UserDetail{}, UserScore{}).Where("id", 3).Scan(&user)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Or like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'var user *User\ng.Model(tableUser).With(User{}.UserDetail, User{}.UserScore).Where("id", 3).Scan(&user)\n'})}),"\n",(0,i.jsx)(n.h4,{id:"2-only-associate-user-detail-model",children:"2) Only Associate User Detail Model"}),"\n",(0,i.jsxs)(n.p,{children:["If we only need to query user details and not user scores, we can use the ",(0,i.jsx)(n.code,{children:"With"})," method to enable association queries for the specified object corresponding tables, such as:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'var user *User\ng.Model(tableUser).With(UserDetail{}).Where("id", 3).Scan(&user)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Or like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'var user *User\ng.Model(tableUser).With(User{}.UserDetail).Where("id", 3).Scan(&user)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["After execution, the data printed by ",(0,i.jsx)(n.code,{children:"g.Dump(user)"})," is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'{\n        "id": 3,\n        "name": "name_3",\n        "UserDetail": {\n                "uid": 3,\n                "address": "address_3"\n        },\n        "UserScores": []\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"3-only-associate-user-score-model",children:"3) Only Associate User Score Model"}),"\n",(0,i.jsx)(n.p,{children:"We can also associate and query only user score information, such as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'var user *User\ng.Model(tableUser).With(UserScore{}).Where("id", 3).Scan(&user)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Or like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'var user *User\ng.Model(tableUser).With(User{}.UserScore).Where("id", 3).Scan(&user)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["After execution, the data printed by ",(0,i.jsx)(n.code,{children:"g.Dump(user)"})," is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'{\n        "id": 3,\n        "name": "name_3",\n        "UserDetail": null,\n        "UserScores": [\n                {\n                        "id": 11,\n                        "uid": 3,\n                        "score": 1\n                },\n                {\n                        "id": 12,\n                        "uid": 3,\n                        "score": 2\n                },\n                {\n                        "id": 13,\n                        "uid": 3,\n                        "score": 3\n                },\n                {\n                        "id": 14,\n                        "uid": 3,\n                        "score": 4\n                },\n                {\n                        "id": 15,\n                        "uid": 3,\n                        "score": 5\n                }\n        ]\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"4-do-not-associate-any-model-query",children:"4) Do Not Associate Any Model Query"}),"\n",(0,i.jsx)(n.p,{children:"If we do not need any association query, it's simpler, for example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'var user *User\ng.Model(tableUser).Where("id", 3).Scan(&user)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["After execution, the data printed by ",(0,i.jsx)(n.code,{children:"g.Dump(user)"})," is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'{\n        "id": 3,\n        "name": "name_3",\n        "UserDetail": null,\n        "UserScores": []\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"4-usage-restrictions",children:"4. Usage Restrictions"}),"\n",(0,i.jsx)(n.h3,{id:"1-field-query-and-filtering",children:"1. Field Query and Filtering"}),"\n",(0,i.jsxs)(n.p,{children:["As seen in our example above, we have not specified the fields to query, but in the ",(0,i.jsx)(n.code,{children:"SQL"})," logs printed, the query statement is not a simple ",(0,i.jsx)(n.code,{children:"SELECT *"})," but executed concrete field queries. Under the ",(0,i.jsx)(n.code,{children:"With"})," feature, automatic field query mapping according to the associated model object properties will happen, and it will automatically filter out fields that cannot be mapped."]}),"\n",(0,i.jsxs)(n.p,{children:["Therefore, under the ",(0,i.jsx)(n.code,{children:"With"})," feature, we cannot query only some corresponding properties\u2019 fields. To query and assign only specific fields, it is recommended to trim the ",(0,i.jsx)(n.code,{children:"model"})," data structure according to business scenarios and create data structures that meet specific business scenarios, rather than using one data structure to fit multiple different scenarios."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's use an example for better illustration. Suppose we have an entity object data structure ",(0,i.jsx)(n.code,{children:"Content"}),", a common content model in a ",(0,i.jsx)(n.code,{children:"CMS"})," system as follows, which corresponds to the fields of the data table:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type Content struct {\n    Id             uint        `orm:"id,primary"       json:"id"`               // Auto-increment ID\n    Key            string      `orm:"key"              json:"key"`              // Unique key name, generally not commonly used\n    Type           string      `orm:"type"             json:"type"`             // Content model: topic, ask, article, etc., defined by the program\n    CategoryId     uint        `orm:"category_id"      json:"category_id"`      // Category ID\n    UserId         uint        `orm:"user_id"          json:"user_id"`          // User ID\n    Title          string      `orm:"title"            json:"title"`            // Title\n    Content        string      `orm:"content"          json:"content"`          // Content\n    Sort           uint        `orm:"sort"             json:"sort"`             // Sort order, lower value means higher priority, default is the timestamp when added, can be used to pin\n    Brief          string      `orm:"brief"            json:"brief"`            // Summary\n    Thumb          string      `orm:"thumb"            json:"thumb"`            // Thumbnail\n    Tags           string      `orm:"tags"             json:"tags"`             // Tag names list, stored in JSON\n    Referer        string      `orm:"referer"          json:"referer"`          // Content Source, e.g., GitHub/Gitee\n    Status         uint        `orm:"status"           json:"status"`           // Status 0: Normal, 1: Disabled\n    ReplyCount     uint        `orm:"reply_count"      json:"reply_count"`      // Reply count\n    ViewCount      uint        `orm:"view_count"       json:"view_count"`       // View count\n    ZanCount       uint        `orm:"zan_count"        json:"zan_count"`        // Likes\n    CaiCount       uint        `orm:"cai_count"        json:"cai_count"`        // Dislikes\n    CreatedAt      *gtime.Time `orm:"created_at"       json:"created_at"`       // Creation time\n    UpdatedAt      *gtime.Time `orm:"updated_at"       json:"updated_at"`       // Update time\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The content list page does not need to display such detailed content, especially the ",(0,i.jsx)(n.code,{children:"Content"})," field, which is very large. We only need to query a few fields for the list page. Therefore, we can define a separate data structure for list returns (field trimming) instead of directly using the data table entity object data structure. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type ContentListItem struct {\n    Id         uint        `json:"id"`          // Auto-increment ID\n    CategoryId uint        `json:"category_id"` // Category ID\n    UserId     uint        `json:"user_id"`     // User ID\n    Title      string      `json:"title"`       // Title\n    CreatedAt  *gtime.Time `json:"created_at"`  // Creation time\n    UpdatedAt  *gtime.Time `json:"updated_at"`  // Update time\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-must-exist-association-field-property",children:"2. Must Exist Association Field Property"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"With"})," feature is achieved by recognizing data structure associations and automatically executing multiple SQL queries, so associated fields must exist as object properties for automatic retrieval of association field values. Simply put, the fields in the ",(0,i.jsx)(n.code,{children:"with"})," tag must be present in the attributes of the associated object."]}),"\n",(0,i.jsx)(n.h2,{id:"5-recursive-association",children:"5. Recursive Association"}),"\n",(0,i.jsxs)(n.p,{children:["If the associated model properties also have ",(0,i.jsx)(n.code,{children:"with"})," tags, recursive association querying will occur. The ",(0,i.jsx)(n.code,{children:"With"})," feature supports unlimited levels of recursive association. The following example is for reference only:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// User Detail\ntype UserDetail struct {\n    g.Meta `orm:"table:user_detail"`\n    Uid        int    `json:"uid"`\n    Address    string `json:"address"`\n}\n\n// User Scores - Required Courses\ntype UserScoresRequired struct {\n    g.Meta `orm:"table:user_scores"`\n    Id         int `json:"id"`\n    Uid        int `json:"uid"`\n    Score      int `json:"score"`\n}\n\n// User Scores - Elective Courses\ntype UserScoresOptional struct {\n    g.Meta `orm:"table:user_scores"`\n    Id         int `json:"id"`\n    Uid        int `json:"uid"`\n    Score      int `json:"score"`\n}\n\n// User Scores\ntype UserScores struct {\n    g.Meta `orm:"table:user_scores"`\n    Id         int                  `json:"id"`\n    Uid        int                  `json:"uid"`\n    Required   []UserScoresRequired `orm:"with:id, where:type=1"`\n    Optional   []UserScoresOptional `orm:"with:id, where:type=2"`\n}\n\n// User Information\ntype User struct {\n    g.Meta `orm:"table:user"`\n    Id         int           `json:"id"`\n    Name       string        `json:"name"`\n    UserDetail *UserDetail   `orm:"with:uid=id"`\n    UserScores []*UserScores `orm:"with:uid=id"`\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"6-model-examples",children:"6. Model Examples"}),"\n",(0,i.jsx)(n.p,{children:"Based on the current data tables, more model writing examples are provided for reference."}),"\n",(0,i.jsx)(n.h3,{id:"1-nested-associated-models",children:"1. Nested Associated Models"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type UserDetail struct {\n    g.Meta `orm:"table:user_detail"`\n    Uid        int    `json:"uid"`\n    Address    string `json:"address"`\n}\n\ntype UserScores struct {\n    g.Meta `orm:"table:user_scores"`\n    Id         int `json:"id"`\n    Uid        int `json:"uid"`\n    Score      int `json:"score"`\n}\n\ntype User struct {\n    g.Meta  `orm:"table:user"`\n    *UserDetail `orm:"with:uid=id"`\n    Id          int           `json:"id"`\n    Name        string        `json:"name"`\n    UserScores  []*UserScores `orm:"with:uid=id"`\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Nested models also support nesting to allow automatic data assignment for embedded structures, such as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type UserDetail struct {\n    Uid     int    `json:"uid"`\n    Address string `json:"address"`\n}\n\ntype UserDetailEmbedded struct {\n    UserDetail\n}\n\ntype UserScores struct {\n    Id    int `json:"id"`\n    Uid   int `json:"uid"`\n    Score int `json:"score"`\n}\n\ntype User struct {\n    *UserDetailEmbedded `orm:"with:uid=id"`\n    Id                  int           `json:"id"`\n    Name                string        `json:"name"`\n    UserScores          []*UserScores `orm:"with:uid=id"`\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-basic-model-nesting",children:"2. Basic Model Nesting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type UserDetail struct {\n    g.Meta `orm:"table:user_detail"`\n    Uid        int    `json:"uid"`\n    Address    string `json:"address"`\n}\n\ntype UserScores struct {\n    g.Meta `orm:"table:user_scores"`\n    Id         int `json:"id"`\n    Uid        int `json:"uid"`\n    Score      int `json:"score"`\n}\n\ntype UserEmbedded struct {\n    Id   int    `json:"id"`\n    Name string `json:"name"`\n}\n\ntype User struct {\n    g.Meta `orm:"table:user"`\n    UserEmbedded\n    *UserDetail `orm:"with:uid=id"`\n    UserScores  []*UserScores `orm:"with:uid=id"`\n}\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"3-models-without-meta-information",children:["3. Models Without ",(0,i.jsx)(n.code,{children:"meta"})," Information"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"meta"})," structure in the model is crucial for specifying the table name. When there is no ",(0,i.jsx)(n.code,{children:"meta"})," information, the table name for query will automatically use the ",(0,i.jsx)(n.code,{children:"CaseSnake"})," name of the struct. For example, ",(0,i.jsx)(n.code,{children:"UserDetail"})," will automatically use the ",(0,i.jsx)(n.code,{children:"user_detail"})," table name, and ",(0,i.jsx)(n.code,{children:"UserScores"})," will automatically use the ",(0,i.jsx)(n.code,{children:"user_scores"})," table name."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type UserDetail struct {\n    Uid     int    `json:"uid"`\n    Address string `json:"address"`\n}\n\ntype UserScores struct {\n    Id    int `json:"id"`\n    Uid   int `json:"uid"`\n    Score int `json:"score"`\n}\n\ntype User struct {\n    *UserDetail `orm:"with:uid=id"`\n    Id          int           `json:"id"`\n    Name        string        `json:"name"`\n    UserScores  []*UserScores `orm:"with:uid=id"`\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"7-future-improvements",children:"7. Future Improvements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Currently, the ",(0,i.jsx)(n.code,{children:"With"})," feature is only implemented for query operations and does not support write or update operations."]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},250065:function(e,n,s){s.d(n,{Z:function(){return o},a:function(){return a}});var t=s(667294);let i={},r=t.createContext(i);function a(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);