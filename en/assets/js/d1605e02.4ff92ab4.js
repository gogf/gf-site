"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["68315"],{901587:function(e,n,t){t.r(n),t.d(n,{metadata:()=>a,contentTitle:()=>c,default:()=>l,assets:()=>s,toc:()=>u,frontMatter:()=>r});var a=JSON.parse('{"id":"docs/\u7EC4\u4EF6\u5217\u8868/\u6570\u636E\u7ED3\u6784/\u961F\u5217\u7C7B\u578B-gqueue/\u961F\u5217\u7C7B\u578B-\u6027\u80FD\u6D4B\u8BD5","title":"Queue - Performance","description":"Performance testing of gqueue and the standard library channel in the GoFrame framework. Benchmark tests demonstrate gqueue\'s advantages in dynamic storage and elastic capacity, showing better efficiency and flexibility in creation compared to the fixed memory allocation and capacity limitation of the channel.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u7EC4\u4EF6\u5217\u8868/\u6570\u636E\u7ED3\u6784/\u961F\u5217\u7C7B\u578B-gqueue/\u961F\u5217\u7C7B\u578B-\u6027\u80FD\u6D4B\u8BD5.md","sourceDirName":"docs/\u7EC4\u4EF6\u5217\u8868/\u6570\u636E\u7ED3\u6784/\u961F\u5217\u7C7B\u578B-gqueue","slug":"/docs/components/container-gqueue-benchmark","permalink":"/en/docs/components/container-gqueue-benchmark","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u7EC4\u4EF6\u5217\u8868/\u6570\u636E\u7ED3\u6784/\u961F\u5217\u7C7B\u578B-gqueue/\u961F\u5217\u7C7B\u578B-\u6027\u80FD\u6D4B\u8BD5.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1740621099000,"sidebarPosition":1,"frontMatter":{"slug":"/docs/components/container-gqueue-benchmark","title":"Queue - Performance","sidebar_position":1,"hide_title":true,"keywords":["GoFrame","GoFrame framework","gqueue","performance testing","queue type","channel","benchmark","dynamic queue","queue performance","benchmark"],"description":"Performance testing of gqueue and the standard library channel in the GoFrame framework. Benchmark tests demonstrate gqueue\'s advantages in dynamic storage and elastic capacity, showing better efficiency and flexibility in creation compared to the fixed memory allocation and capacity limitation of the channel."},"sidebar":"mainSidebar","previous":{"title":"Queue - Usage","permalink":"/en/docs/components/container-gqueue-example"},"next":{"title":"Tree","permalink":"/en/docs/components/container-gtree"}}'),i=t("785893"),o=t("250065");let r={slug:"/docs/components/container-gqueue-benchmark",title:"Queue - Performance",sidebar_position:1,hide_title:!0,keywords:["GoFrame","GoFrame framework","gqueue","performance testing","queue type","channel","benchmark","dynamic queue","queue performance","benchmark"],description:"Performance testing of gqueue and the standard library channel in the GoFrame framework. Benchmark tests demonstrate gqueue's advantages in dynamic storage and elastic capacity, showing better efficiency and flexibility in creation compared to the fixed memory allocation and capacity limitation of the channel."},c=void 0,s={},u=[];function d(e){let n={a:"a",code:"code",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/gogf/gf/blob/master/container/gqueue/gqueue_z_bench_test.go",children:"https://github.com/gogf/gf/blob/master/container/gqueue/gqueue_z_bench_test.go"})}),"\n",(0,i.jsxs)(n.p,{children:["Benchmark testing of ",(0,i.jsx)(n.code,{children:"gqueue"})," and the standard library ",(0,i.jsx)(n.code,{children:"channel"}),", where each benchmark test has a ",(0,i.jsx)(n.code,{children:"b.N"})," value of ",(0,i.jsx)(n.code,{children:"20000000"})," to ensure consistent dynamic queue access and prevent ",(0,i.jsx)(n.code,{children:"deadlock"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"goos: linux\ngoarch: amd64\npkg: github.com/gogf/gf/v2/container/gqueue\nBenchmark_Gqueue_StaticPushAndPop-4       20000000            84.2 ns/op\nBenchmark_Gqueue_DynamicPush-4            20000000             164 ns/op\nBenchmark_Gqueue_DynamicPop-4             20000000             121 ns/op\nBenchmark_Channel_PushAndPop-4            20000000            70.0 ns/op\nPASS\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It can be seen that the read and write performance of the standard library ",(0,i.jsx)(n.code,{children:"channel"})," is very high, but due to the need to initialize memory during creation, the efficiency is very, very low when creating a ",(0,i.jsx)(n.code,{children:"channel"})," (initialization involves memory allocation), and it is limited by the queue size, meaning that the written data cannot exceed the specified queue size. ",(0,i.jsx)(n.code,{children:"gqueue"})," is more flexible to use compared to ",(0,i.jsx)(n.code,{children:"channel"}),", offering higher creation efficiency (dynamically allocated memory) and not being restricted by queue size (though size can be limited)."]})]})}function l(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return c},a:function(){return r}});var a=t(667294);let i={},o=a.createContext(i);function r(e){let n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);