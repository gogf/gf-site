"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["13811"],{241407:function(e,n,o){o.r(n),o.d(n,{metadata:()=>c,contentTitle:()=>s,default:()=>d,assets:()=>l,toc:()=>a,frontMatter:()=>t});var c=JSON.parse('{"id":"docs/\u7EC4\u4EF6\u5217\u8868/\u7CFB\u7EDF\u76F8\u5173/\u5185\u5B58\u9501-gmlock","title":"Memory Lock","description":"The memory lock module provides dynamic mutex lock functionality based on the GoFrame framework, supporting concurrent safety and the TryLock feature by dynamically generating locks for given key names. Methods provided by GoFrame can be conveniently applied in scenarios requiring dynamic creation of a large number of mutex locks, such as effectively managing locks in multi-goroutine concurrent processing to ensure safe access to resources.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u7EC4\u4EF6\u5217\u8868/\u7CFB\u7EDF\u76F8\u5173/\u5185\u5B58\u9501-gmlock.md","sourceDirName":"docs/\u7EC4\u4EF6\u5217\u8868/\u7CFB\u7EDF\u76F8\u5173","slug":"/docs/components/os-gmlock","permalink":"/en/docs/components/os-gmlock","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u7EC4\u4EF6\u5217\u8868/\u7CFB\u7EDF\u76F8\u5173/\u5185\u5B58\u9501-gmlock.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732443619000,"sidebarPosition":2,"frontMatter":{"slug":"/docs/components/os-gmlock","title":"Memory Lock","sidebar_position":2,"hide_title":true,"keywords":["memory lock","dynamic mutex lock","GoFrame","gmlock","concurrency safety","TryLock","Remove method","dynamic creation of mutex locks","GoFrame framework","lock management"],"description":"The memory lock module provides dynamic mutex lock functionality based on the GoFrame framework, supporting concurrent safety and the TryLock feature by dynamically generating locks for given key names. Methods provided by GoFrame can be conveniently applied in scenarios requiring dynamic creation of a large number of mutex locks, such as effectively managing locks in multi-goroutine concurrent processing to ensure safe access to resources."},"sidebar":"mainSidebar","previous":{"title":"Mutex","permalink":"/en/docs/components/os-gmutex"},"next":{"title":"Context","permalink":"/en/docs/components/os-gctx"}}'),r=o("785893"),i=o("250065");let t={slug:"/docs/components/os-gmlock",title:"Memory Lock",sidebar_position:2,hide_title:!0,keywords:["memory lock","dynamic mutex lock","GoFrame","gmlock","concurrency safety","TryLock","Remove method","dynamic creation of mutex locks","GoFrame framework","lock management"],description:"The memory lock module provides dynamic mutex lock functionality based on the GoFrame framework, supporting concurrent safety and the TryLock feature by dynamically generating locks for given key names. Methods provided by GoFrame can be conveniently applied in scenarios requiring dynamic creation of a large number of mutex locks, such as effectively managing locks in multi-goroutine concurrent processing to ensure safe access to resources."},s=void 0,l={},a=[{value:"Example 1: Basic Usage",id:"example-1-basic-usage",level:3},{value:"Example 2: TryLock Non-blocking Lock",id:"example-2-trylock-non-blocking-lock",level:3}];function u(e){let n={a:"a",blockquote:"blockquote",code:"code",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The memory lock module, also known as the ",(0,r.jsx)(n.code,{children:"dynamic mutex lock"})," module, supports ",(0,r.jsx)(n.code,{children:"dynamically generating mutex locks"})," based on given key names, ensuring concurrency safety and supporting the ",(0,r.jsx)(n.code,{children:"Try*Lock"})," feature."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["In scenarios where a large number of dynamic mutex locks are maintained, please manually call the ",(0,r.jsx)(n.code,{children:"Remove"})," method to delete mutex lock objects that are no longer in use."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'import "github.com/gogf/gf/v2/os/gmlock"\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage scenarios"}),": Scenarios that require ",(0,r.jsx)(n.code,{children:"dynamic creation of mutex locks"}),", or need to maintain ",(0,r.jsx)(n.code,{children:"a large number of dynamic locks"}),";"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Interface documentation"}),":"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://pkg.go.dev/github.com/gogf/gf/v2/os/gmlock",children:"https://pkg.go.dev/github.com/gogf/gf/v2/os/gmlock"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func Lock(key string)\nfunc LockFunc(key string, f func())\nfunc RLock(key string)\nfunc RLockFunc(key string, f func())\nfunc RUnlock(key string)\nfunc Remove(key string)\nfunc TryLock(key string) bool\nfunc TryLockFunc(key string, f func()) bool\nfunc TryRLock(key string) bool\nfunc TryRLockFunc(key string, f func()) bool\nfunc Unlock(key string)\ntype Locker\n    func New() *Locker\n    func (l *Locker) Clear()\n    func (l *Locker) Lock(key string)\n    func (l *Locker) LockFunc(key string, f func())\n    func (l *Locker) RLock(key string)\n    func (l *Locker) RLockFunc(key string, f func())\n    func (l *Locker) RUnlock(key string)\n    func (l *Locker) Remove(key string)\n    func (l *Locker) TryLock(key string) bool\n    func (l *Locker) TryLockFunc(key string, f func()) bool\n    func (l *Locker) TryRLock(key string) bool\n    func (l *Locker) TryRLockFunc(key string, f func()) bool\n    func (l *Locker) Unlock(key string)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-1-basic-usage",children:"Example 1: Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "time"\n    "sync"\n    "github.com/gogf/gf/v2/os/glog"\n    "github.com/gogf/gf/v2/os/gmlock"\n)\n\nfunc main() {\n    key := "lock"\n    wg  := sync.WaitGroup{}\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func(i int) {\n            gmlock.Lock(key)\n            glog.Println(i)\n            time.Sleep(time.Second)\n            gmlock.Unlock(key)\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, it simulates opening ",(0,r.jsx)(n.code,{children:"10"})," ",(0,r.jsx)(n.code,{children:"goroutines"})," simultaneously, but at any one time only one ",(0,r.jsx)(n.code,{children:"goroutine"})," can acquire the lock. The ",(0,r.jsx)(n.code,{children:"goroutine"})," with the lock will execute for ",(0,r.jsx)(n.code,{children:"1"})," second before exiting, allowing other ",(0,r.jsx)(n.code,{children:"goroutines"})," to acquire the lock."]}),"\n",(0,r.jsx)(n.p,{children:"After execution, the output is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"2018-10-15 23:57:28.295 9\n2018-10-15 23:57:29.296 0\n2018-10-15 23:57:30.296 1\n2018-10-15 23:57:31.296 2\n2018-10-15 23:57:32.296 3\n2018-10-15 23:57:33.297 4\n2018-10-15 23:57:34.297 5\n2018-10-15 23:57:35.297 6\n2018-10-15 23:57:36.298 7\n2018-10-15 23:57:37.298 8\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-2-trylock-non-blocking-lock",children:"Example 2: TryLock Non-blocking Lock"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"TryLock"})," method returns a value, indicating whether the lock was successfully acquired. If successful, it returns ",(0,r.jsx)(n.code,{children:"true"}),"; if the lock is already acquired by another ",(0,r.jsx)(n.code,{children:"goroutine"}),", it returns ",(0,r.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "sync"\n    "github.com/gogf/gf/v2/os/glog"\n    "time"\n    "github.com/gogf/gf/v2/os/gmlock"\n)\n\nfunc main() {\n    key := "lock"\n    wg  := sync.WaitGroup{}\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func(i int) {\n            if gmlock.TryLock(key) {\n                glog.Println(i)\n                time.Sleep(time.Second)\n                gmlock.Unlock(key)\n            } else {\n                glog.Println(false)\n            }\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Similarly, in this example, only ",(0,r.jsx)(n.code,{children:"1"})," ",(0,r.jsx)(n.code,{children:"goroutine"})," can acquire the lock at the same time, and other ",(0,r.jsx)(n.code,{children:"goroutines"})," will exit immediately if ",(0,r.jsx)(n.code,{children:"TryLock"})," fails."]}),"\n",(0,r.jsx)(n.p,{children:"After execution, the output is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"2018-10-16 00:01:59.172 9\n2018-10-16 00:01:59.172 false\n2018-10-16 00:01:59.172 false\n2018-10-16 00:01:59.172 false\n2018-10-16 00:01:59.172 false\n2018-10-16 00:01:59.172 false\n2018-10-16 00:01:59.172 false\n2018-10-16 00:01:59.172 false\n2018-10-16 00:01:59.172 false\n2018-10-16 00:01:59.176 false\n"})})]})}function d(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},250065:function(e,n,o){o.d(n,{Z:function(){return s},a:function(){return t}});var c=o(667294);let r={},i=c.createContext(r);function t(e){let n=c.useContext(i);return c.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),c.createElement(i.Provider,{value:n},e.children)}}}]);