"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["3984"],{966561(e,n,r){r.r(n),r.d(n,{metadata:()=>t,default:()=>u,frontMatter:()=>s,contentTitle:()=>c,toc:()=>a,assets:()=>l});var t=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-\u81EA\u5B9A\u4E49\u7C7B\u578B\u8F6C\u6362","title":"Type Conversion - Custom Type Conversion","description":"GoFrame custom type conversion provides flexible mechanisms for implementing conversions between complex data types, enhancing application flexibility and maintainability.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-\u81EA\u5B9A\u4E49\u7C7B\u578B\u8F6C\u6362.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362","slug":"/docs/core/gconv-register-converter-func","permalink":"/en/docs/core/gconv-register-converter-func","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-\u81EA\u5B9A\u4E49\u7C7B\u578B\u8F6C\u6362.md","tags":[],"version":"current","lastUpdatedBy":"John Guo","lastUpdatedAt":1742194305000,"sidebarPosition":7000,"frontMatter":{"slug":"/docs/core/gconv-register-converter-func","title":"Type Conversion - Custom Type Conversion","sidebar_position":7000,"hide_title":true,"keywords":["GoFrame","gconv","custom conversion","type conversion","converter"],"description":"GoFrame custom type conversion provides flexible mechanisms for implementing conversions between complex data types, enhancing application flexibility and maintainability."},"sidebar":"mainSidebar","previous":{"title":"Type Conversion - Converter","permalink":"/en/docs/core/gconv-converter"},"next":{"title":"Database ORM\u{1F525}","permalink":"/en/docs/core/gdb"}}'),o=r(474848),i=r(28453);let s={slug:"/docs/core/gconv-register-converter-func",title:"Type Conversion - Custom Type Conversion",sidebar_position:7e3,hide_title:!0,keywords:["GoFrame","gconv","custom conversion","type conversion","converter"],description:"GoFrame custom type conversion provides flexible mechanisms for implementing conversions between complex data types, enhancing application flexibility and maintainability."},c,l={},a=[{value:"RegisterTypeConverterFunc",id:"registertypeconverterfunc",level:2},{value:"Function Definition",id:"function-definition",level:3},{value:"Usage Examples",id:"usage-examples",level:3},{value:"Struct Type Conversion",id:"struct-type-conversion",level:4},{value:"Alias Type Conversion",id:"alias-type-conversion",level:4},{value:"RegisterAnyConverterFunc",id:"registeranyconverterfunc",level:2},{value:"Function Definition",id:"function-definition-1",level:3},{value:"Usage Examples",id:"usage-examples-1",level:3},{value:"Struct Conversion Example",id:"struct-conversion-example",level:4},{value:"Complex Nested Struct Conversion Example",id:"complex-nested-struct-conversion-example",level:4},{value:"Comparison of Two Conversion Functions",id:"comparison-of-two-conversion-functions",level:2},{value:"RegisterTypeConverterFunc",id:"registertypeconverterfunc-1",level:3},{value:"RegisterAnyConverterFunc",id:"registeranyconverterfunc-1",level:3}];function d(e){let n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"gconv"})," conversion component provides powerful type conversion functionality, allowing developers to customize conversion logic between types. It offers two main custom conversion method registration mechanisms: ",(0,o.jsx)(n.code,{children:"RegisterTypeConverterFunc"})," and ",(0,o.jsx)(n.code,{children:"RegisterAnyConverterFunc"}),"."]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Custom type conversion ",(0,o.jsx)(n.strong,{children:"does not support"})," custom conversion of basic types (such as ",(0,o.jsx)(n.code,{children:"int"}),", ",(0,o.jsx)(n.code,{children:"string"}),", etc.), and only supports complex data structure types (such as ",(0,o.jsx)(n.code,{children:"slice"}),", ",(0,o.jsx)(n.code,{children:"map"}),", ",(0,o.jsx)(n.code,{children:"struct"}),", etc.). This design is to improve conversion efficiency."]})}),"\n",(0,o.jsx)(n.h2,{id:"registertypeconverterfunc",children:"RegisterTypeConverterFunc"}),"\n",(0,o.jsx)(n.h3,{id:"function-definition",children:"Function Definition"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"RegisterTypeConverterFunc"})," method is used to register conversion functions between specific types, defined as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"func RegisterTypeConverterFunc(fn interface{}) (err error)\n"})}),"\n",(0,o.jsx)(n.p,{children:"The signature of the conversion function must conform to the following format:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"func(T1) (*T2, error)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Where ",(0,o.jsx)(n.code,{children:"T1"})," needs to be a non-pointer object, and ",(0,o.jsx)(n.code,{children:"T2"})," needs to be a pointer type. If the types are incorrect, the conversion method registration will report an error."]}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["The design of requiring the input parameter (",(0,o.jsx)(n.code,{children:"T1"}),") to be a non-pointer object is to ensure the safety of the input parameter and to avoid modifying the input parameter within the conversion method, which could cause problems outside the scope."]})}),"\n",(0,o.jsx)(n.h3,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,o.jsx)(n.h4,{id:"struct-type-conversion",children:"Struct Type Conversion"}),"\n",(0,o.jsxs)(n.p,{children:["The most common application scenario for ",(0,o.jsx)(n.code,{children:"RegisterTypeConverterFunc"})," is type conversion between structs. Let's look at an example using ",(0,o.jsx)(n.code,{children:"RegisterTypeConverterFunc"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n	"fmt"\n	"time"\n\n	"github.com/gogf/gf/v2/util/gconv"\n)\n\n// UserInfo custom type\ntype UserInfo struct {\n	ID       int\n	Name     string\n	Birthday time.Time\n}\n\ntype UserDTO struct {\n	UserID   string\n	UserName string\n	Age      int\n}\n\nfunc userInfoT2UserDTO(in UserInfo) (*UserDTO, error) {\n	if in.ID <= 0 {\n		return nil, fmt.Errorf("invalid user ID: %d", in.ID)\n	}\n	// Calculate age\n	age := time.Now().Year() - in.Birthday.Year()\n	return &UserDTO{\n		UserID:   fmt.Sprintf("U%d", in.ID),\n		UserName: in.Name,\n		Age:      age,\n	}, nil\n}\n\nfunc main() {\n	converter := gconv.NewConverter()\n	// Register custom type conversion function - from UserInfo to UserDTO\n	err := converter.RegisterTypeConverterFunc(userInfoT2UserDTO)\n	if err != nil {\n		fmt.Println("Failed to register conversion function:", err)\n		return\n	}\n\n	// Use custom type conversion\n	userInfo := UserInfo{\n		ID:       101,\n		Name:     "Zhang San",\n		Birthday: time.Date(1990, 5, 15, 0, 0, 0, 0, time.Local),\n	}\n\n	var userDTO UserDTO\n	err = converter.Scan(userInfo, &userDTO)\n	if err != nil {\n		fmt.Println("Conversion failed:", err)\n	} else {\n		fmt.Printf("Custom type conversion result: %#v\\n", userDTO)\n		// Output similar to: Custom type conversion result: main.UserDTO{UserID:"U101", UserName:"Zhang San", Age:35}\n	}\n\n	// Test error handling\n	invalidUser := UserInfo{ID: -1, Name: "Invalid User"}\n	err = converter.Scan(invalidUser, &userDTO)\n	if err != nil {\n		fmt.Println("Expected error:", err) // Output error message: invalid user ID: -1\n	}\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In this example code, two type conversion scenarios are demonstrated: custom struct conversion, and automatic conversion of structs as properties. The conversion method uses the general struct conversion method ",(0,o.jsx)(n.code,{children:"gconv.Scan"}),", which in its internal implementation will automatically determine if there is a custom type conversion function, will prioritize using the custom type conversion function, otherwise will follow the default conversion logic."]}),"\n",(0,o.jsx)(n.h4,{id:"alias-type-conversion",children:"Alias Type Conversion"}),"\n",(0,o.jsxs)(n.p,{children:["We can also use ",(0,o.jsx)(n.code,{children:"RegisterTypeConverterFunc"})," to implement conversion of ",(0,o.jsx)(n.strong,{children:"alias types"}),". Here is an example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n\n    "github.com/gogf/gf/v2/os/gtime"\n    "github.com/gogf/gf/v2/util/gconv"\n)\n\ntype MyTime = *gtime.Time\n\ntype Src struct {\n    A MyTime\n}\n\ntype Dst struct {\n    B string\n}\n\ntype SrcWrap struct {\n    Value Src\n}\n\ntype DstWrap struct {\n    Value Dst\n}\n\n// MyTimeToDstConverter custom conversion function from MyTime to Dst\nfunc MyTimeToDstConverter(src MyTime) (dst *Dst, err error) {\n    if src == nil {\n        return &Dst{B: ""}, nil\n    }\n    return &Dst{B: src.String()}, nil\n}\n\nfunc main() {\n    // Register custom conversion function\n    err := gconv.RegisterTypeConverterFunc(MyTimeToDstConverter)\n    if err != nil {\n        panic(err)\n    }\n\n    // Create test data\n    now := gtime.Now()\n    src := Src{A: now}\n    \n    // Execute conversion\n    var dst *Dst\n    err = gconv.Scan(src, &dst)\n    if err != nil {\n        panic(err)\n    }\n    \n    fmt.Println("Original time:", now)\n    fmt.Println("Conversion result:", dst.B)\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"registeranyconverterfunc",children:"RegisterAnyConverterFunc"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"RegisterAnyConverterFunc"})," provides a more flexible type conversion mechanism, allowing one conversion function to handle conversions between multiple types. This is especially useful when dealing with complex data structure conversion needs."]}),"\n",(0,o.jsx)(n.h3,{id:"function-definition-1",children:"Function Definition"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"RegisterAnyConverterFunc"})," method provides a more flexible type conversion mechanism, allowing handling of conversions between multiple types, defined as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"func RegisterAnyConverterFunc(f AnyConvertFunc, types ...reflect.Type)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Where the definition of ",(0,o.jsx)(n.code,{children:"AnyConvertFunc"})," is:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"// AnyConvertFunc is the function type for converting any to specified type.\ntype AnyConvertFunc func(from any, to reflect.Value) error\n"})}),"\n",(0,o.jsx)(n.p,{children:"This approach allows developers to register a general conversion function that can handle conversions between multiple types."}),"\n",(0,o.jsx)(n.h3,{id:"usage-examples-1",children:"Usage Examples"}),"\n",(0,o.jsx)(n.h4,{id:"struct-conversion-example",children:"Struct Conversion Example"}),"\n",(0,o.jsxs)(n.p,{children:["Here is a basic example using ",(0,o.jsx)(n.code,{children:"RegisterAnyConverterFunc"}),", demonstrating how to implement custom struct conversion:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n	"fmt"\n	"reflect"\n\n	"github.com/gogf/gf/v2/util/gconv"\n)\n\n// UserInput source struct\ntype UserInput struct {\n	Name     string\n	Age      int\n	IsActive bool\n}\n\n// UserModel target struct\ntype UserModel struct {\n	ID       int\n	FullName string\n	Age      int\n	Status   int\n}\n\nfunc userInput2Model(in any, out reflect.Value) error {\n	// Check if output type is UserModel\n	if out.Type() == reflect.TypeOf(&UserModel{}) {\n		// Handle conversion from UserInput to UserModel\n		if input, ok := in.(UserInput); ok {\n			model := UserModel{\n				ID:       1,\n				FullName: input.Name,\n				Age:      input.Age,\n				Status:   0,\n			}\n			if input.IsActive {\n				model.Status = 1\n			}\n			out.Elem().Set(reflect.ValueOf(model))\n			return nil\n		}\n		return fmt.Errorf("conversion from %T to UserModel not supported", in)\n	}\n	return fmt.Errorf("conversion to %s not supported", out.Type())\n}\n\nfunc main() {\n	// Create converter\n	converter := gconv.NewConverter()\n\n	// Register custom conversion function\n	converter.RegisterAnyConverterFunc(userInput2Model, reflect.TypeOf(UserModel{}))\n\n	// Test conversion\n	var (\n		model UserModel\n		input = UserInput{Name: "Zhang San", Age: 30, IsActive: true}\n	)\n	err := converter.Scan(input, &model)\n	if err != nil {\n		fmt.Println("Conversion failed:", err)\n	} else {\n		fmt.Printf(\n			"Conversion result: ID=%d, Name=%s, Age=%d, Status=%d\\n",\n			model.ID, model.FullName, model.Age, model.Status,\n		)\n	}\n}\n'})}),"\n",(0,o.jsx)(n.h4,{id:"complex-nested-struct-conversion-example",children:"Complex Nested Struct Conversion Example"}),"\n",(0,o.jsxs)(n.p,{children:["Here is a more complex example with nested data structures, demonstrating how to use ",(0,o.jsx)(n.code,{children:"RegisterAnyConverterFunc"})," to handle complex nested struct conversions:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n	"fmt"\n	"reflect"\n\n	"github.com/gogf/gf/v2/util/gconv"\n)\n\n// UserDetail source data structure\ntype UserDetail struct {\n	UserID  int\n	Name    string\n	Address Address\n}\n\n// UserDTO target data structure\ntype UserDTO struct {\n	ID          string\n	DisplayName string\n	Location    string\n}\n\ntype Address struct {\n	City    string\n	Country string\n}\n\nfunc userDetail2DTO(in any, out reflect.Value) error {\n	// Check if output type is UserDTO\n	if out.Type() == reflect.TypeOf(&UserDTO{}) {\n		// Handle conversion from UserDetail to UserDTO\n		if detail, ok := in.(UserDetail); ok {\n			dto := UserDTO{\n				ID:          fmt.Sprintf("USER-%d", detail.UserID),\n				DisplayName: detail.Name,\n				Location:    fmt.Sprintf("%s, %s", detail.Address.City, detail.Address.Country),\n			}\n			out.Elem().Set(reflect.ValueOf(dto))\n			return nil\n		}\n		return fmt.Errorf("conversion from %T to UserDTO not supported", in)\n	}\n	return fmt.Errorf("conversion to %s not supported", out.Type())\n}\n\nfunc main() {\n	// Create converter\n	converter := gconv.NewConverter()\n\n	// Register custom conversion function\n	converter.RegisterAnyConverterFunc(userDetail2DTO, reflect.TypeOf(UserDTO{}))\n\n	// Test conversion\n	var (\n		dto    UserDTO\n		detail = UserDetail{\n			UserID: 12345,\n			Name:   "Zhang San",\n			Address: Address{\n				City:    "Beijing",\n				Country: "China",\n			},\n		}\n	)\n	if err := converter.Scan(detail, &dto); err != nil {\n		fmt.Println("Conversion failed:", err)\n	} else {\n		fmt.Printf(\n			"Conversion result: ID=%s, Name=%s, Address=%s\\n",\n			dto.ID, dto.DisplayName, dto.Location,\n		)\n	}\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["This example demonstrates how to use ",(0,o.jsx)(n.code,{children:"RegisterAnyConverterFunc"})," to implement complex nested struct conversion, including conversion from ",(0,o.jsx)(n.code,{children:"UserDetail"})," to ",(0,o.jsx)(n.code,{children:"UserDTO"}),", and conversion from nested ",(0,o.jsx)(n.code,{children:"map"})," to ",(0,o.jsx)(n.code,{children:"UserDTO"}),". This kind of complex data structure conversion is the main application scenario for ",(0,o.jsx)(n.code,{children:"RegisterAnyConverterFunc"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"comparison-of-two-conversion-functions",children:"Comparison of Two Conversion Functions"}),"\n",(0,o.jsx)(n.p,{children:"The two registration methods each have their advantages, disadvantages, and applicable scenarios:"}),"\n",(0,o.jsx)(n.h3,{id:"registertypeconverterfunc-1",children:"RegisterTypeConverterFunc"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Type safety"}),": Since the function signature has already defined the input and output types, the compiler can perform type checking at compile time."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Simple to use"}),": Definition and usage are relatively intuitive, no need to manually handle reflection."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Suitable for specific type conversion"}),": When you only need to handle conversion between two specific types, this method is clearer."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Disadvantages:"})}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Limited flexibility"}),": Each function can only handle conversion from one specific type to another specific type."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Multiple functions needed"}),": If you need to handle conversions of multiple types, you need to define and register multiple functions."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"registeranyconverterfunc-1",children:"RegisterAnyConverterFunc"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Highly flexible"}),": One function can handle conversions from multiple input types to a specific output type."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Code reuse"}),": Related conversion logic can be centralized in one function, reducing duplicate code."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dynamic judgment"}),": Can dynamically decide how to convert based on input type at runtime."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Disadvantages:"})}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reduced type safety"}),": Using reflection and interface types, the compiler cannot check for type errors."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Complex to use"}),": Need to manually handle reflection and type assertions, increasing complexity."]}),"\n"]})]})}function u(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453(e,n,r){r.d(n,{R:()=>s,x:()=>c});var t=r(296540);let o={},i=t.createContext(o);function s(e){let n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);