"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["30711"],{544230:function(e,t,d){d.r(t),d.d(t,{metadata:()=>n,contentTitle:()=>s,default:()=>u,assets:()=>o,toc:()=>r,frontMatter:()=>l});var n=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u65F6\u95F4\u7EF4\u62A4/\u65F6\u95F4\u7EF4\u62A4-\u6574\u578B\u5B57\u6BB5","title":"Time Fields - Integer Fields","description":"If time fields such as created_at, updated_at, and deleted_at are integer fields, GoFrame\'s ORM component will automatically recognize and write second-level timestamps. During insertion, created_at is automatically updated, but updates and deletions do not change created_at. The Replace method will update all time fields. In the case of soft deletion, all queries automatically include the condition deleted_at=0.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u65F6\u95F4\u7EF4\u62A4/\u65F6\u95F4\u7EF4\u62A4-\u6574\u578B\u5B57\u6BB5.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u65F6\u95F4\u7EF4\u62A4","slug":"/docs/core/gdb-chaining-soft-time-numeric-fields","permalink":"/en/docs/core/gdb-chaining-soft-time-numeric-fields","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u65F6\u95F4\u7EF4\u62A4/\u65F6\u95F4\u7EF4\u62A4-\u6574\u578B\u5B57\u6BB5.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732541616000,"sidebarPosition":1,"frontMatter":{"slug":"/docs/core/gdb-chaining-soft-time-numeric-fields","title":"Time Fields - Integer Fields","sidebar_position":1,"hide_title":true,"keywords":["GoFrame","Time Maintenance","Integer Fields","created_at","updated_at","deleted_at","Soft Delete","ORM Component","Insert","Update"],"description":"If time fields such as created_at, updated_at, and deleted_at are integer fields, GoFrame\'s ORM component will automatically recognize and write second-level timestamps. During insertion, created_at is automatically updated, but updates and deletions do not change created_at. The Replace method will update all time fields. In the case of soft deletion, all queries automatically include the condition deleted_at=0."},"sidebar":"mainSidebar","previous":{"title":"Time Fields - Intro","permalink":"/en/docs/core/gdb-chaining-soft-time-example"},"next":{"title":"Time Fields - Boolean Fields","permalink":"/en/docs/core/gdb-chaining-soft-time-bool-fields"}}'),i=d("785893"),a=d("250065");let l={slug:"/docs/core/gdb-chaining-soft-time-numeric-fields",title:"Time Fields - Integer Fields",sidebar_position:1,hide_title:!0,keywords:["GoFrame","Time Maintenance","Integer Fields","created_at","updated_at","deleted_at","Soft Delete","ORM Component","Insert","Update"],description:"If time fields such as created_at, updated_at, and deleted_at are integer fields, GoFrame's ORM component will automatically recognize and write second-level timestamps. During insertion, created_at is automatically updated, but updates and deletions do not change created_at. The Replace method will update all time fields. In the case of soft deletion, all queries automatically include the condition deleted_at=0."},s=void 0,o={},r=[{value:"Example SQL",id:"example-sql",level:2},{value:"<code>created_at</code> Writing Time",id:"created_at-writing-time",level:2},{value:"<code>deleted_at</code> Soft Delete",id:"deleted_at-soft-delete",level:2},{value:"<code>updated_at</code> Update Time",id:"updated_at-update-time",level:2},{value:"Scenarios of Joint Table Queries",id:"scenarios-of-joint-table-queries",level:2},{value:"Control the Granularity of Time Writing",id:"control-the-granularity-of-time-writing",level:2}];function c(e){let t={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Since version ",(0,i.jsx)(t.code,{children:"v2.8"}),", if the time fields ",(0,i.jsx)(t.code,{children:"created_at"}),", ",(0,i.jsx)(t.code,{children:"updated_at"}),", and ",(0,i.jsx)(t.code,{children:"deleted_at"})," are integer fields, the ORM component will automatically recognize and support them, writing ",(0,i.jsx)(t.strong,{children:"second-level timestamp"})," values."]}),"\n",(0,i.jsx)(t.h2,{id:"example-sql",children:"Example SQL"}),"\n",(0,i.jsxs)(t.p,{children:["This is the ",(0,i.jsx)(t.code,{children:"MySQL"})," table structure used in the subsequent example code."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE `user` (\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `name` varchar(45) NOT NULL,\n  `status` tinyint DEFAULT 0,\n  `created_at` int(10) unsigned DEFAULT NULL,\n  `updated_at` int(10) unsigned DEFAULT NULL,\n  `deleted_at` int(10) unsigned DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nCREATE TABLE IF NOT EXISTS `user_detail` (\n    `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n    `address` varchar(45) NOT NULL,\n    PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["If you try to test viewing the ",(0,i.jsx)(t.code,{children:"SQL"})," statements executed by ",(0,i.jsx)(t.code,{children:"ORM"})," operations, it's recommended to enable ",(0,i.jsx)(t.code,{children:"debug"})," mode (related documentation: ",(0,i.jsx)(t.a,{href:"/en/docs/core/gdb-senior-debugging",children:"ORM Senior - Debug Mode"}),"), the ",(0,i.jsx)(t.code,{children:"SQL"})," statements will be automatically printed to log output."]})}),"\n",(0,i.jsxs)(t.h2,{id:"created_at-writing-time",children:[(0,i.jsx)(t.code,{children:"created_at"})," Writing Time"]}),"\n",(0,i.jsxs)(t.p,{children:["When executing the ",(0,i.jsx)(t.code,{children:"Insert/InsertIgnore/BatchInsert/BatchInsertIgnore"})," methods, this time is automatically written. Subsequent update/delete operations will not change the content of the ",(0,i.jsx)(t.code,{children:"created_at"})," field."]}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsxs)(t.p,{children:["It should be noted that the ",(0,i.jsx)(t.code,{children:"Replace"})," method will also update this field because this operation is equivalent to deleting the existing old data and writing a new data record."]})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'// INSERT INTO `user`(`name`,`created_at`,`updated_at`,`deleted_at`) VALUES(\'john\',1731481488,1731481488,0)\ng.Model("user").Data(g.Map{"name": "john"}).Insert()\n\n// INSERT IGNORE INTO `user`(`id`,`name`,`created_at`,`updated_at`,`deleted_at`) VALUES(10000,\'john\',1731481518,1731481518,0) \ng.Model("user").Data(g.Map{"id": 10000, "name": "john"}).InsertIgnore()\n\n// REPLACE INTO `user`(`id`,`name`,`created_at`,`updated_at`,`deleted_at`) VALUES(10000,\'john\',1731481747,1731481747,0)\ng.Model("user").Data(g.Map{"id": 10000, "name": "john"}).Replace()\n\n// INSERT INTO `user`(`id`,`name`,`created_at`,`updated_at`,`deleted_at`) VALUES(10001,\'john\',1731481766,1731481766,0) ON DUPLICATE KEY UPDATE `id`=VALUES(`id`),`name`=VALUES(`name`),`updated_at`=VALUES(`updated_at`),`deleted_at`=VALUES(`deleted_at`)\ng.Model("user").Data(g.Map{"id": 10001, "name": "john"}).Save()\n'})}),"\n",(0,i.jsxs)(t.h2,{id:"deleted_at-soft-delete",children:[(0,i.jsx)(t.code,{children:"deleted_at"})," Soft Delete"]}),"\n",(0,i.jsxs)(t.p,{children:["When soft deletion is present (i.e., the ",(0,i.jsx)(t.code,{children:"deleted_at"})," field exists), all query statements will automatically add conditions for ",(0,i.jsx)(t.code,{children:"deleted_at"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'// UPDATE `user` SET `deleted_at`=1731481948 WHERE (`id`=10) AND `deleted_at`=0\ng.Model("user").Where("id", 10).Delete()\n'})}),"\n",(0,i.jsx)(t.p,{children:"Changes occur when querying:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'// SELECT * FROM `user` WHERE (id>1) AND `deleted_at`=0\ng.Model("user").Where("id>?", 1).All()\n'})}),"\n",(0,i.jsxs)(t.p,{children:["You can see that when the ",(0,i.jsx)(t.code,{children:"deleted_at"})," field exists in the data table, all query operations involving the table automatically add the condition ",(0,i.jsx)(t.code,{children:"deleted_at=0"}),"."]}),"\n",(0,i.jsxs)(t.h2,{id:"updated_at-update-time",children:[(0,i.jsx)(t.code,{children:"updated_at"})," Update Time"]}),"\n",(0,i.jsxs)(t.p,{children:["When executing the ",(0,i.jsx)(t.code,{children:"Save/Update"})," methods, this time is automatically written. It should be noted that the ",(0,i.jsx)(t.code,{children:"Replace"})," method will also update this field because it is equivalent to deleting the existing old data and writing a new data record."]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["If the ",(0,i.jsx)(t.code,{children:"deleted_at"})," soft delete field also exists, the update operation statement will also contain the ",(0,i.jsx)(t.code,{children:"deleted_at"})," condition."]})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'// UPDATE `user` SET `name`=\'john guo\',`updated_at`=1731481821 WHERE (`name`=\'john\') AND `deleted_at`=0\ng.Model("user").Data(g.Map{"name" : "john guo"}).Where("name", "john").Update()\n\n// UPDATE `user` SET `status`=1,`updated_at`=1731481895 WHERE `deleted_at`=0 ORDER BY `id` ASC LIMIT 10\ng.Model("user").Data("status", 1).OrderAsc("id").Limit(10).Update()\n\n// INSERT INTO `user`(`id`,`name`,`created_at`,`updated_at`,`deleted_at`) VALUES(1,\'john guo\',1731481915,1731481915,0) ON DUPLICATE KEY UPDATE `id`=VALUES(`id`),`name`=VALUES(`name`),`updated_at`=VALUES(`updated_at`),`deleted_at`=VALUES(`deleted_at`)\ng.Model("user").Data(g.Map{"id": 1, "name": "john guo"}).Save()\n'})}),"\n",(0,i.jsx)(t.h2,{id:"scenarios-of-joint-table-queries",children:"Scenarios of Joint Table Queries"}),"\n",(0,i.jsx)(t.p,{children:"If several tables involved in an associated query have enabled the soft delete feature, the following situation will occur, where all relevant tables will have soft deletion time judgment added to the condition statements."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'// SELECT * FROM `user` AS `u` LEFT JOIN `user_detail` AS `ud` ON (ud.id=u.id) WHERE (`u`.`id`=10) AND `u`.`deleted_at`=0 LIMIT 1\ng.Model("user", "u").LeftJoin("user_detail", "ud", "ud.id=u.id").Where("u.id", 10).One()\n'})}),"\n",(0,i.jsx)(t.h2,{id:"control-the-granularity-of-time-writing",children:"Control the Granularity of Time Writing"}),"\n",(0,i.jsxs)(t.p,{children:["The time field value writing in this chapter is by default in seconds-level timestamp. But if we want to control the granularity of time writing such as writing a millisecond-level timestamp, how do we do it? We can use ",(0,i.jsx)(t.a,{href:"/en/docs/core/gdb-chaining-soft-time-option",children:"Time Fields - SoftTimeOption"}),"."]})]})}function u(e={}){let{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},250065:function(e,t,d){d.d(t,{Z:function(){return s},a:function(){return l}});var n=d(667294);let i={},a=n.createContext(i);function l(e){let t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);