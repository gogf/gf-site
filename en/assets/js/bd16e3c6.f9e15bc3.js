"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["62186"],{627325:function(e,i,n){n.r(i),n.d(i,{metadata:()=>t,contentTitle:()=>l,default:()=>h,assets:()=>o,toc:()=>a,frontMatter:()=>r});var t=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u5B57\u6BB5\u8FC7\u6EE4","title":"ORM Model - Fields Filtering","description":"How to perform field filtering when operating databases with the GoFrame framework. It describes in detail the purposes and examples of the Fields and FieldsEx methods, and explores how the OmitEmpty and OmitNil features help filter out empty data during database writing. Additionally, it discusses the impact of null values on query conditions.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u5B57\u6BB5\u8FC7\u6EE4.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C","slug":"/docs/core/gdb-chaining-fields-filtering","permalink":"/en/docs/core/gdb-chaining-fields-filtering","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u94FE\u5F0F\u64CD\u4F5C/ORM\u94FE\u5F0F\u64CD\u4F5C-\u5B57\u6BB5\u8FC7\u6EE4.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732440306000,"sidebarPosition":6,"frontMatter":{"slug":"/docs/core/gdb-chaining-fields-filtering","title":"ORM Model - Fields Filtering","sidebar_position":6,"hide_title":true,"keywords":["GoFrame","GoFrame Framework","ORM","Field Filtering","Fields","FieldsEx","OmitEmpty","OmitNil","GoFrame DAO","Table"],"description":"How to perform field filtering when operating databases with the GoFrame framework. It describes in detail the purposes and examples of the Fields and FieldsEx methods, and explores how the OmitEmpty and OmitNil features help filter out empty data during database writing. Additionally, it discusses the impact of null values on query conditions."},"sidebar":"mainSidebar","previous":{"title":"ORM Model - Object Input","permalink":"/en/docs/core/gdb-chaining-object-parameter"},"next":{"title":"ORM Model - Fields Retrieval","permalink":"/en/docs/core/gdb-chaining-fields-retrieving"}}'),s=n("785893"),d=n("250065");let r={slug:"/docs/core/gdb-chaining-fields-filtering",title:"ORM Model - Fields Filtering",sidebar_position:6,hide_title:!0,keywords:["GoFrame","GoFrame Framework","ORM","Field Filtering","Fields","FieldsEx","OmitEmpty","OmitNil","GoFrame DAO","Table"],description:"How to perform field filtering when operating databases with the GoFrame framework. It describes in detail the purposes and examples of the Fields and FieldsEx methods, and explores how the OmitEmpty and OmitNil features help filter out empty data during database writing. Additionally, it discusses the impact of null values on query conditions."},l=void 0,o={},a=[{value:"<code>Fields/FieldsEx</code> Field Filtering",id:"fieldsfieldsex-field-filtering",level:2},{value:"<code>Fields</code> Example",id:"fields-example",level:3},{value:"<code>FieldsEx</code> Example",id:"fieldsex-example",level:3},{value:"<code>OmitEmpty</code> Empty Value Filtering",id:"omitempty-empty-value-filtering",level:2},{value:"Insert/Update Operations",id:"insertupdate-operations",level:3},{value:"Data Query Operations",id:"data-query-operations",level:3},{value:"<code>OmitNil</code> Empty Value Filtering",id:"omitnil-empty-value-filtering",level:2},{value:"Overview",id:"overview",level:3},{value:"Using <code>do</code> Objects for Field Filtering",id:"using-do-objects-for-field-filtering",level:3},{value:"<code>Filter</code> Field Filtering (Built-in)",id:"filter-field-filtering-built-in",level:2}];function c(e){let i={admonition:"admonition",code:"code",del:"del",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,d.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(i.h2,{id:"fieldsfieldsex-field-filtering",children:[(0,s.jsx)(i.code,{children:"Fields/FieldsEx"})," Field Filtering"]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"Fields"})," is used to specify the fields of the table to be operated on, including query fields, write fields, update fields, etc.;"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"FieldsEx"})," is used for specifying exception fields and can be used for query fields, write fields, update fields, etc.;"]}),"\n"]}),"\n",(0,s.jsxs)(i.h3,{id:"fields-example",children:[(0,s.jsx)(i.code,{children:"Fields"})," Example"]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Suppose the ",(0,s.jsx)(i.code,{children:"user"})," table has 4 fields: ",(0,s.jsx)(i.code,{children:"uid"}),", ",(0,s.jsx)(i.code,{children:"nickname"}),", ",(0,s.jsx)(i.code,{children:"passport"}),", ",(0,s.jsx)(i.code,{children:"password"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Query field filtering"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'// SELECT `uid`,`nickname` FROM `user` ORDER BY `uid` asc\ng.Model("user").Fields("uid, nickname").Order("uid asc").All()\n'})}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Write field filtering"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'m := g.Map{\n    "uid"      : 10000,\n    "nickname" : "John Guo",\n    "passport" : "john",\n    "password" : "123456",\n}\ng.Model(table).Fields("nickname,passport,password").Data(m).Insert()\n// INSERT INTO `user`(`nickname`,`passport`,`password`) VALUES(\'John Guo\',\'john\',\'123456\')\n'})}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Supports ",(0,s.jsx)(i.code,{children:"gdb.Raw"})," input"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'// SELECT 1 FROM `user` WHERE `id`=10\ng.Model("user").Fields(gdb.Raw("1")).Where("id", 10).Value()\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.h3,{id:"fieldsex-example",children:[(0,s.jsx)(i.code,{children:"FieldsEx"})," Example"]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Suppose the ",(0,s.jsx)(i.code,{children:"user"})," table has 4 fields: ",(0,s.jsx)(i.code,{children:"uid"}),", ",(0,s.jsx)(i.code,{children:"nickname"}),", ",(0,s.jsx)(i.code,{children:"passport"}),", ",(0,s.jsx)(i.code,{children:"password"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Query field exclusion"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'// SELECT `uid`,`nickname` FROM `user`\ng.Model("user").FieldsEx("passport, password").All()\n'})}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Write field exclusion"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'m := g.Map{\n    "uid"      : 10000,\n    "nickname" : "John Guo",\n    "passport" : "john",\n    "password" : "123456",\n}\ng.Model(table).FieldsEx("uid").Data(m).Insert()\n// INSERT INTO `user`(`nickname`,`passport`,`password`) VALUES(\'John Guo\',\'john\',\'123456\')\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.h2,{id:"omitempty-empty-value-filtering",children:[(0,s.jsx)(i.code,{children:"OmitEmpty"})," Empty Value Filtering"]}),"\n",(0,s.jsxs)(i.p,{children:["When there are empty values like ",(0,s.jsx)(i.code,{children:"nil"}),", ",(0,s.jsx)(i.code,{children:'""'}),", ",(0,s.jsx)(i.code,{children:"0"})," in a ",(0,s.jsx)(i.code,{children:"map"}),"/ ",(0,s.jsx)(i.code,{children:"struct"}),", by default, ",(0,s.jsx)(i.code,{children:"gdb"})," will consider them as normal input parameters, and hence, they will be updated to the data table. The ",(0,s.jsx)(i.code,{children:"OmitEmpty"})," feature helps filter out these empty fields before writing data to the database."]}),"\n",(0,s.jsx)(i.p,{children:"Related methods:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:"func (m *Model) OmitEmpty() *Model\nfunc (m *Model) OmitEmptyWhere() *Model\nfunc (m *Model) OmitEmptyData() *Model\n"})}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"OmitEmpty"})," method filters out empty data fields from both ",(0,s.jsx)(i.code,{children:"Where"})," and ",(0,s.jsx)(i.code,{children:"Data"}),", while the ",(0,s.jsx)(i.code,{children:"OmitEmptyWhere/OmitEmptyData"})," methods allow specific field filtering."]}),"\n",(0,s.jsx)(i.h3,{id:"insertupdate-operations",children:"Insert/Update Operations"}),"\n",(0,s.jsxs)(i.p,{children:["Empty values affect insert/update operation methods like ",(0,s.jsx)(i.code,{children:"Insert"}),", ",(0,s.jsx)(i.code,{children:"Replace"}),", ",(0,s.jsx)(i.code,{children:"Update"}),", ",(0,s.jsx)(i.code,{children:"Save"}),". As in the following operation (taking ",(0,s.jsx)(i.code,{children:"map"})," as an example, the same applies to ",(0,s.jsx)(i.code,{children:"struct"}),"):"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'// UPDATE `user` SET `name`=\'john\',update_time=null WHERE `id`=1\ng.Model("user").Data(g.Map{\n    "name"        : "john",\n    "update_time" : nil,\n}).Where("id", 1).Update()\n'})}),"\n",(0,s.jsxs)(i.p,{children:["To handle empty values, we can use the ",(0,s.jsx)(i.code,{children:"OmitEmpty"})," method to filter them out. For example, the above example can be modified as follows:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'// UPDATE `user` SET `name`=\'john\' WHERE `id`=1\ng.Model("user").OmitEmpty().Data(g.Map{\n    "name"        : "john",\n    "update_time" : nil,\n}).Where("id", 1).Update()\n'})}),"\n",(0,s.jsxs)(i.p,{children:["For ",(0,s.jsx)(i.code,{children:"struct"})," data parameters, we can also perform empty value filtering. An operation example:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'type User struct {\n    Id         int    `orm:"id"`\n    Passport   string `orm:"passport"`\n    Password   string `orm:"password"`\n    NickName   string `orm:"nickname"`\n    CreateTime string `orm:"create_time"`\n    UpdateTime string `orm:"update_time"`\n}\nuser := User{\n    Id        : 1,\n    NickName  : "john",\n    UpdateTime: gtime.Now().String(),\n}\ng.Model("user").OmitEmpty().Data(user).Insert()\n// INSERT INTO `user`(`id`,`nickname`,`update_time`) VALUES(1,\'john\',\'2019-10-01 12:00:00\')\n'})}),"\n",(0,s.jsx)(i.admonition,{type:"warning",children:(0,s.jsxs)(i.p,{children:["Note that in batch insert/update operations, the ",(0,s.jsx)(i.code,{children:"OmitEmpty"})," method will be ineffective because fields for each inserted record must be consistent."]})}),"\n",(0,s.jsxs)(i.p,{children:["Regarding the ",(0,s.jsx)(i.code,{children:"omitempty"})," tag and the ",(0,s.jsx)(i.code,{children:"OmitEmpty"})," method:"]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["For empty value filtering in ",(0,s.jsx)(i.code,{children:"struct"}),", people might think of the ",(0,s.jsx)(i.code,{children:"omitempty"})," tag. This tag is commonly used for filtering empty values in ",(0,s.jsx)(i.code,{children:"json"})," conversion and in some third-party ",(0,s.jsx)(i.code,{children:"ORM"})," libraries for filtering out ",(0,s.jsx)(i.code,{children:"struct"})," fields with empty values, meaning when a property is empty, it is not converted."]}),"\n",(0,s.jsxs)(i.li,{children:["The ",(0,s.jsx)(i.code,{children:"omitempty"})," tag and the ",(0,s.jsx)(i.code,{children:"OmitEmpty"})," method achieve the same effect. In ",(0,s.jsx)(i.code,{children:"ORM"})," operations, we do not recommend using the ",(0,s.jsx)(i.code,{children:"omitempty"})," tag on ",(0,s.jsx)(i.code,{children:"struct"})," to control field empty value filtering. Instead, we suggest using the ",(0,s.jsx)(i.code,{children:"OmitEmpty"})," method. Once the tag is applied, it binds to the ",(0,s.jsx)(i.code,{children:"struct"}),", and there is no way to control it flexibly; however, with the ",(0,s.jsx)(i.code,{children:"OmitEmpty"})," method, developers can selectively filter empty values based on the business scenario, allowing for more flexible operations."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"data-query-operations",children:"Data Query Operations"}),"\n",(0,s.jsxs)(i.p,{children:["Empty values also affect data query operations, mainly impacting ",(0,s.jsx)(i.code,{children:"where"})," condition parameters. We can filter empty values in condition parameters using the ",(0,s.jsx)(i.code,{children:"OmitEmpty"})," method."]}),"\n",(0,s.jsx)(i.p,{children:"Examples of use:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'// SELECT * FROM `user` WHERE `passport`=\'john\' LIMIT 1\nr, err := g.Model("user").Where(g.Map{\n    "nickname" : "",\n    "passport" : "john",\n}).OmitEmpty().One()\n'})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'type User struct {\n    Id         int    `orm:"id"`\n    Passport   string `orm:"passport"`\n    Password   string `orm:"password"`\n    NickName   string `orm:"nickname"`\n    CreateTime string `orm:"create_time"`\n    UpdateTime string `orm:"update_time"`\n}\nuser := User{\n    Passport : "john",\n}\nr, err := g.Model("user").OmitEmpty().Where(user).One()\n// SELECT * FROM `user` WHERE `passport`=\'john\' LIMIT 1\n'})}),"\n",(0,s.jsxs)(i.h2,{id:"omitnil-empty-value-filtering",children:[(0,s.jsx)(i.code,{children:"OmitNil"})," Empty Value Filtering"]}),"\n",(0,s.jsx)(i.h3,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(i.p,{children:["When there are empty values like ",(0,s.jsx)(i.code,{children:"nil"})," in a ",(0,s.jsx)(i.code,{children:"map"}),"/ ",(0,s.jsx)(i.code,{children:"struct"}),", by default, ",(0,s.jsx)(i.code,{children:"gdb"})," will consider them as normal input parameters, and hence, they will be updated to the data table. The ",(0,s.jsx)(i.code,{children:"OmitNil"})," feature helps filter out these empty fields before writing data to the database. The difference between ",(0,s.jsx)(i.code,{children:"OmitNil"})," and ",(0,s.jsx)(i.code,{children:"OmitEmpty"})," is that ",(0,s.jsx)(i.code,{children:"OmitNil"})," only filters fields with ",(0,s.jsx)(i.code,{children:"nil"})," values, while other empty values like ",(0,s.jsx)(i.code,{children:'""'}),", ",(0,s.jsx)(i.code,{children:"0"})," will not be filtered."]}),"\n",(0,s.jsx)(i.p,{children:"Related methods:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:"func (m *Model) OmitNil() *Model\nfunc (m *Model) OmitNilWhere() *Model\nfunc (m *Model) OmitNilData() *Model\n"})}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"OmitNil"})," method filters out empty fields from both ",(0,s.jsx)(i.code,{children:"Where"})," and ",(0,s.jsx)(i.code,{children:"Data"}),", while the ",(0,s.jsx)(i.code,{children:"OmitNilWhere/OmitNilData"})," methods allow specific field filtering."]}),"\n",(0,s.jsxs)(i.h3,{id:"using-do-objects-for-field-filtering",children:["Using ",(0,s.jsx)(i.code,{children:"do"})," Objects for Field Filtering"]}),"\n",(0,s.jsxs)(i.p,{children:["If you use the ",(0,s.jsx)(i.code,{children:"GoFrame"})," project directory and use the ",(0,s.jsx)(i.code,{children:"gf gen dao"})," or ",(0,s.jsx)(i.code,{children:"make dao"})," command, the corresponding table ",(0,s.jsx)(i.code,{children:"dao/entity/do"})," files will be automatically generated based on the configured database. If ",(0,s.jsx)(i.code,{children:"do"})," objects are used in database operations, unassigned fields will be automatically filtered. For example:"]}),"\n",(0,s.jsxs)(i.p,{children:["Generated ",(0,s.jsx)(i.code,{children:"do"})," object struct definition"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'// User is the golang structure of table user for DAO operations like Where/Data.\ntype User struct {\n    g.Meta   `orm:"table:user, do:true"`\n    Id       interface{} // User ID\n    Passport interface{} // User Passport\n    Password interface{} // User Password\n    Nickname interface{} // User Nickname\n    CreateAt *gtime.Time // Created Time\n    UpdateAt *gtime.Time // Updated Time\n}\n'})}),"\n",(0,s.jsx)(i.p,{children:"Data Insertion:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:"dao.User.Transaction(ctx, func(ctx context.Context, tx gdb.TX) error {\n    _, err = dao.User.Ctx(ctx).Data(do.User{\n        Passport: in.Passport,\n        Password: in.Password,\n        Nickname: in.Nickname,\n    }).Insert()\n    return err\n})\n"})}),"\n",(0,s.jsx)(i.p,{children:"Data Query:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:"var user *entity.User\nerr = dao.User.Ctx(ctx).Where(do.User{\n    Passport: in.Passport,\n    Password: in.Password,\n}).Scan(&user)\n"})}),"\n",(0,s.jsxs)(i.h2,{id:"filter-field-filtering-built-in",children:[(0,s.jsx)(i.code,{children:"Filter"})," Field Filtering (Built-in)"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsxs)(i.del,{children:[(0,s.jsx)(i.code,{children:"gdb"})," can automatically synchronize the ",(0,s.jsx)(i.strong,{children:"table structure"})," to the program cache (cache does not expire until the program restarts/redeploys) and can filter out non-compliant table structure items from the submitted parameters. This feature can be achieved using the ",(0,s.jsx)(i.code,{children:"Filter"})," method. It is commonly used in scenarios involving input ",(0,s.jsx)(i.code,{children:"map/struct/[]map/[]string"})," parameters for insert/delete operations."]})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsxs)(i.del,{children:["Usage example, suppose the ",(0,s.jsx)(i.code,{children:"user"})," table has 4 fields: ",(0,s.jsx)(i.code,{children:"uid"}),", ",(0,s.jsx)(i.code,{children:"nickname"}),", ",(0,s.jsx)(i.code,{children:"passport"}),", ",(0,s.jsx)(i.code,{children:"password"}),":"]})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'r, err := g.Model("user").Filter().Data(g.Map{\n    "id"          : 1,\n    "uid"         : 1,\n    "passport"    : "john",\n    "password"    : "123456",\n}).Insert()\n// INSERT INTO user(uid,passport,password) VALUES(1, "john", "123456")\n'})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsxs)(i.del,{children:["Here, ",(0,s.jsx)(i.code,{children:"id"})," is a non-existent field, and it will be filtered out during data insertion to prevent execution errors in the constructed SQL."]})}),"\n",(0,s.jsx)(i.admonition,{type:"tip",children:(0,s.jsx)(i.p,{children:(0,s.jsxs)(i.del,{children:["The database is not designed to automatically filter for the ",(0,s.jsx)(i.code,{children:"Data"})," method. Instead, developers need to specify filtering manually by calling the ",(0,s.jsx)(i.code,{children:"Filter"})," method. This aims to kindly remind developers of possible mistakes/wrongly passed field names. Automatically filtering may cause unpredictable business logic anomalies, for example, the ",(0,s.jsx)(i.code,{children:"Filter"})," method can cause the automatic filtering of essential fields due to incorrect spelling of field names, leading to incomplete data in the database."]})})}),"\n",(0,s.jsx)(i.admonition,{type:"warning",children:(0,s.jsxs)(i.p,{children:["From version ",(0,s.jsx)(i.code,{children:"GoFrame v1.15.7"}),", based on overall community feedback, to enhance component usability, the ",(0,s.jsx)(i.code,{children:"filter"})," feature is enabled by default and no longer needs to be explicitly called, making the ",(0,s.jsx)(i.code,{children:"Filter"})," method deprecated."]})})]})}function h(e={}){let{wrapper:i}={...(0,d.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},250065:function(e,i,n){n.d(i,{Z:function(){return l},a:function(){return r}});var t=n(667294);let s={},d=t.createContext(s);function r(e){let i=t.useContext(d);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(d.Provider,{value:i},e.children)}}}]);