"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["77012"],{906773:function(n,e,i){i.r(e),i.d(e,{metadata:()=>s,contentTitle:()=>a,default:()=>g,assets:()=>l,toc:()=>c,frontMatter:()=>r});var s=JSON.parse('{"id":"docs/\u7EC4\u4EF6\u5217\u8868/\u7CFB\u7EDF\u76F8\u5173/\u8FDB\u7A0B\u7BA1\u7406-gproc/\u8FDB\u7A0B\u7BA1\u7406-\u4FE1\u53F7\u76D1\u542C","title":"Process - Signal","description":"Using the gproc component in the GoFrame framework to implement signal listening and handling, addressing the issue of redundant signal processing logic among multiple components and the inability to exit programs smoothly. By unified signal registration and callback processing, it ensures that each component can effectively receive exit signals and perform deconstruction, making signal processing logic more rigorous.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u7EC4\u4EF6\u5217\u8868/\u7CFB\u7EDF\u76F8\u5173/\u8FDB\u7A0B\u7BA1\u7406-gproc/\u8FDB\u7A0B\u7BA1\u7406-\u4FE1\u53F7\u76D1\u542C.md","sourceDirName":"docs/\u7EC4\u4EF6\u5217\u8868/\u7CFB\u7EDF\u76F8\u5173/\u8FDB\u7A0B\u7BA1\u7406-gproc","slug":"/docs/components/os-gproc-signal","permalink":"/en/docs/components/os-gproc-signal","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u7EC4\u4EF6\u5217\u8868/\u7CFB\u7EDF\u76F8\u5173/\u8FDB\u7A0B\u7BA1\u7406-gproc/\u8FDB\u7A0B\u7BA1\u7406-\u4FE1\u53F7\u76D1\u542C.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732443619000,"sidebarPosition":2,"frontMatter":{"slug":"/docs/components/os-gproc-signal","title":"Process - Signal","sidebar_position":2,"hide_title":true,"keywords":["GoFrame","signal listening","process management","gproc component","GoFrame framework","signal handling","smooth program exit","Go language","signal callback","AddSigHandler"],"description":"Using the gproc component in the GoFrame framework to implement signal listening and handling, addressing the issue of redundant signal processing logic among multiple components and the inability to exit programs smoothly. By unified signal registration and callback processing, it ensures that each component can effectively receive exit signals and perform deconstruction, making signal processing logic more rigorous."},"sidebar":"mainSidebar","previous":{"title":"Process - Communication","permalink":"/en/docs/components/os-gproc-communication-between-processes"},"next":{"title":"Process - Tracing","permalink":"/en/docs/components/os-gproc-tracing"}}'),o=i("785893"),t=i("250065");let r={slug:"/docs/components/os-gproc-signal",title:"Process - Signal",sidebar_position:2,hide_title:!0,keywords:["GoFrame","signal listening","process management","gproc component","GoFrame framework","signal handling","smooth program exit","Go language","signal callback","AddSigHandler"],description:"Using the gproc component in the GoFrame framework to implement signal listening and handling, addressing the issue of redundant signal processing logic among multiple components and the inability to exit programs smoothly. By unified signal registration and callback processing, it ensures that each component can effectively receive exit signals and perform deconstruction, making signal processing logic more rigorous."},a=void 0,l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Example 1, Using Standard Library Signal Listening",id:"example-1-using-standard-library-signal-listening",level:2},{value:"Example 2, Using <code>gproc</code> Signal Listening",id:"example-2-using-gproc-signal-listening",level:2}];function d(n){let e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"gproc"})," component provides a unified signal listening and callback processing feature, aimed at resolving the pain points of redundant signal processing logic among multiple different components in a program and the inability to destruct smoothly after receiving exit signals. Without a component for unified exit signal listening, when multiple components use ",(0,o.jsx)(e.code,{children:"goroutine"})," for asynchronous signal listening, the main ",(0,o.jsx)(e.code,{children:"goroutine"})," often exits directly upon receiving an exit signal or waits for an unpredictable amount of time to exit, which prevents the program from exiting smoothly and may trigger some unexpected issues. ",(0,o.jsx)(e.code,{children:"gproc"})," enables each component to receive exit signals effectively and perform corresponding deconstruction processing through unified signal registration and callback processing, ensuring that the program's signal processing logic is more rigorous."]}),"\n",(0,o.jsx)(e.p,{children:"Relevant methods:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:"// AddSigHandler adds custom signal handler for custom one or more signals.\nfunc AddSigHandler(handler SigHandler, signals ...os.Signal)\n\n// AddSigHandlerShutdown adds custom signal handler for shutdown signals:\n// syscall.SIGINT,\n// syscall.SIGQUIT,\n// syscall.SIGKILL,\n// syscall.SIGTERM,\n// syscall.SIGABRT.\nfunc AddSigHandlerShutdown(handler ...SigHandler)\n\n// Listen blocks and does signal listening and handling.\nfunc Listen()\n"})}),"\n",(0,o.jsx)(e.p,{children:"Brief Introduction:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["The ",(0,o.jsx)(e.code,{children:"AddSigHandler"})," method is used for adding listeners and corresponding callback function registrations for specified signals."]}),"\n",(0,o.jsxs)(e.li,{children:["The ",(0,o.jsx)(e.code,{children:"AddSigHandlerShutdown"})," method is used for adding listeners and corresponding callback function registrations for common process exit signals, allowing registration of multiple ",(0,o.jsx)(e.code,{children:"SigHandler"}),"."]}),"\n",(0,o.jsxs)(e.li,{children:["The ",(0,o.jsx)(e.code,{children:"Listen"})," method is for blocking signal listening and automatically executing callback function calls."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Let's look at two examples."}),"\n",(0,o.jsx)(e.h2,{id:"example-1-using-standard-library-signal-listening",children:"Example 1, Using Standard Library Signal Listening"}),"\n",(0,o.jsx)(e.p,{children:"The common code logic for using the standard library signal listening mechanism is as follows:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "os"\n    "os/signal"\n    "syscall"\n    "time"\n)\n\nfunc signalHandlerForMQ() {\n    var (\n        sig          os.Signal\n        receivedChan = make(chan os.Signal)\n    )\n    signal.Notify(\n        receivedChan,\n        syscall.SIGINT,\n        syscall.SIGQUIT,\n        syscall.SIGKILL,\n        syscall.SIGTERM,\n        syscall.SIGABRT,\n    )\n    for {\n        sig = <-receivedChan\n        fmt.Println("MQ is shutting down due to signal:", sig.String())\n        time.Sleep(time.Second)\n        fmt.Println("MQ is shut down smoothly")\n        return\n    }\n}\n\nfunc main() {\n    fmt.Println("Process start, pid:", os.Getpid())\n    go signalHandlerForMQ()\n\n    var (\n        sig          os.Signal\n        receivedChan = make(chan os.Signal)\n    )\n    signal.Notify(\n        receivedChan,\n        syscall.SIGINT,\n        syscall.SIGQUIT,\n        syscall.SIGKILL,\n        syscall.SIGTERM,\n        syscall.SIGABRT,\n    )\n    for {\n        sig = <-receivedChan\n        fmt.Println("MainProcess is shutting down due to signal:", sig.String())\n        return\n    }\n}\n'})}),"\n",(0,o.jsxs)(e.p,{children:["We execute it via the ",(0,o.jsx)(e.code,{children:"go run"})," command, then exit using the ",(0,o.jsx)(e.code,{children:"Ctrl+C"})," shortcut (",(0,o.jsx)(e.code,{children:"Command+C"})," for Mac users)."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"$ go run signal_handler.go\nProcess start, pid: 21928\n^CMainProcess is shutting down due to signal: interrupt\nMQ is shutting down due to signal: interrupt\n"})}),"\n",(0,o.jsxs)(e.p,{children:["As you can see, unfortunately, the ",(0,o.jsx)(e.code,{children:"MQ"})," ",(0,o.jsx)(e.code,{children:"goroutine"})," is forcibly closed before it is fully exited."]}),"\n",(0,o.jsxs)(e.h2,{id:"example-2-using-gproc-signal-listening",children:["Example 2, Using ",(0,o.jsx)(e.code,{children:"gproc"})," Signal Listening"]}),"\n",(0,o.jsxs)(e.p,{children:["The improved signal listening mechanism using the ",(0,o.jsx)(e.code,{children:"gproc"})," component is as follows:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "github.com/gogf/gf/v2/os/gproc"\n    "os"\n    "time"\n)\n\nfunc signalHandlerForMQ(sig os.Signal) {\n    fmt.Println("MQ is shutting down due to signal:", sig.String())\n    time.Sleep(time.Second)\n    fmt.Println("MQ is shut down smoothly")\n}\n\nfunc signalHandlerForMain(sig os.Signal) {\n    fmt.Println("MainProcess is shutting down due to signal:", sig.String())\n}\n\nfunc main() {\n    fmt.Println("Process start, pid:", os.Getpid())\n    gproc.AddSigHandlerShutdown(\n        signalHandlerForMQ,\n        signalHandlerForMain,\n    )\n    gproc.Listen()\n}\n'})}),"\n",(0,o.jsxs)(e.p,{children:["We execute it via the ",(0,o.jsx)(e.code,{children:"go run"})," command, then exit using the ",(0,o.jsx)(e.code,{children:"Ctrl+C"})," shortcut (",(0,o.jsx)(e.code,{children:"Command+C"})," for Mac users)."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"$ go run signal_handler_gproc.go\nProcess start, pid: 22876\n^CMQ is shutting down due to signal: interrupt\nMainProcess is shutting down due to signal: interrupt\nMQ is shut down smoothly\n"})}),"\n",(0,o.jsx)(e.p,{children:"See the difference! All signal listening functions complete normally, and then the process exits smoothly."})]})}function g(n={}){let{wrapper:e}={...(0,t.a)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},250065:function(n,e,i){i.d(e,{Z:function(){return a},a:function(){return r}});var s=i(667294);let o={},t=s.createContext(o);function r(n){let e=s.useContext(t);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),s.createElement(t.Provider,{value:e},n.children)}}}]);