"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["25707"],{287515:function(e,n,t){t.r(n),t.d(n,{metadata:()=>r,contentTitle:()=>o,default:()=>u,assets:()=>a,toc:()=>d,frontMatter:()=>c});var r=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-Struct\u8F6C\u6362","title":"Type Conversion - Struct","description":"Using the gconv module of GoFrame for struct conversion, including mapping from various data types to structs, automatic object creation, recursive conversion, and mapping rules, among other practical features, to help developers enhance coding efficiency and project maintenance capabilities.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-Struct\u8F6C\u6362.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362","slug":"/docs/core/gconv-struct","permalink":"/en/docs/core/gconv-struct","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-Struct\u8F6C\u6362.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732440306000,"sidebarPosition":2,"frontMatter":{"slug":"/docs/core/gconv-struct","title":"Type Conversion - Struct","sidebar_position":2,"hide_title":true,"keywords":["GoFrame","gconv","struct conversion","data mapping","struct conversion","automatic object creation","recursive conversion","mapping rules","struct","Go framework"],"description":"Using the gconv module of GoFrame for struct conversion, including mapping from various data types to structs, automatic object creation, recursive conversion, and mapping rules, among other practical features, to help developers enhance coding efficiency and project maintenance capabilities."},"sidebar":"mainSidebar","previous":{"title":"Type Conversion - Map","permalink":"/en/docs/core/gconv-map"},"next":{"title":"Type Conversion - Structs","permalink":"/en/docs/core/gconv-structs"}}'),s=t("785893"),i=t("250065");let c={slug:"/docs/core/gconv-struct",title:"Type Conversion - Struct",sidebar_position:2,hide_title:!0,keywords:["GoFrame","gconv","struct conversion","data mapping","struct conversion","automatic object creation","recursive conversion","mapping rules","struct","Go framework"],description:"Using the gconv module of GoFrame for struct conversion, including mapping from various data types to structs, automatic object creation, recursive conversion, and mapping rules, among other practical features, to help developers enhance coding efficiency and project maintenance capabilities."},o=void 0,a={},d=[{value:"Conversion Rules",id:"conversion-rules",level:2},{value:"Matching Rules Priority (only for map to struct conversion)",id:"matching-rules-priority-only-for-map-to-struct-conversion",level:2},{value:"Automatic Object Creation",id:"automatic-object-creation",level:2},{value:"<code>Struct</code> Recursive Conversion",id:"struct-recursive-conversion",level:2},{value:"Example 1: Basic Usage",id:"example-1-basic-usage",level:2},{value:"Example 2: Complex Attribute Types",id:"example-2-complex-attribute-types",level:2}];function l(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["In projects, we frequently encounter the use of a large number of ",(0,s.jsx)(n.code,{children:"struct"}),", and conversions/assignments from various data types to ",(0,s.jsx)(n.code,{children:"struct"})," (especially ",(0,s.jsx)(n.code,{children:"json"}),"/",(0,s.jsx)(n.code,{children:"xml"}),"/various protocol encoding conversions). To improve coding and project maintenance efficiency, the ",(0,s.jsx)(n.code,{children:"gconv"})," module provides developers with substantial benefits by offering greater flexibility in data parsing."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"gconv"})," module performs ",(0,s.jsx)(n.code,{children:"struct"})," type conversion through the ",(0,s.jsx)(n.code,{children:"Struct"})," method, defined as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"// Struct maps the params key-value pairs to the corresponding struct object's attributes.\n// The third parameter `mapping` is unnecessary, indicating the mapping rules between the\n// custom key name and the attribute name(case sensitive).\n//\n// Note:\n// 1. The `params` can be any type of map/struct, usually a map.\n// 2. The `pointer` should be type of *struct/**struct, which is a pointer to struct object\n//    or struct pointer.\n// 3. Only the public attributes of struct object can be mapped.\n// 4. If `params` is a map, the key of the map `params` can be lowercase.\n//    It will automatically convert the first letter of the key to uppercase\n//    in mapping procedure to do the matching.\n//    It ignores the map key, if it does not match.\nfunc Struct(params interface{}, pointer interface{}, mapping ...map[string]string) (err error)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Where:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"params"})," is the variable parameter to be converted to a ",(0,s.jsx)(n.code,{children:"struct"}),". It can be of any data type, commonly a ",(0,s.jsx)(n.code,{children:"map"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pointer"})," is the target ",(0,s.jsx)(n.code,{children:"struct"})," object for conversion. This parameter must be a pointer to the ",(0,s.jsx)(n.code,{children:"struct"})," object; the object's attributes will be updated upon successful conversion."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mapping"})," is a custom mapping between ",(0,s.jsx)(n.code,{children:"map key name"})," and ",(0,s.jsx)(n.code,{children:"struct attribute"}),". In this case, the ",(0,s.jsx)(n.code,{children:"params"})," parameter must be of ",(0,s.jsx)(n.code,{children:"map"})," type, otherwise the parameter is meaningless. In most cases, this parameter can be omitted, using the default conversion rules instead."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["For more ",(0,s.jsx)(n.code,{children:"struct"})," related conversion methods, please refer to the interface documentation: ",(0,s.jsx)(n.a,{href:"https://pkg.go.dev/github.com/gogf/gf/v2/util/gconv",children:"https://pkg.go.dev/github.com/gogf/gf/v2/util/gconv"})]})}),"\n",(0,s.jsx)(n.h2,{id:"conversion-rules",children:"Conversion Rules"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"gconv"})," module's ",(0,s.jsx)(n.code,{children:"struct"})," conversion feature is powerful, supporting mapping conversion from any data type to ",(0,s.jsx)(n.code,{children:"struct"})," attributes. Without custom ",(0,s.jsx)(n.code,{children:"mapping"})," conversion rules, the default conversion rules are as follows:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Attributes in the ",(0,s.jsx)(n.code,{children:"struct"})," that need to be matched must be ",(0,s.jsx)(n.strong,{children:"public attributes"})," (capitalized first letter)."]}),"\n",(0,s.jsxs)(n.li,{children:["Depending on the type of ",(0,s.jsx)(n.code,{children:"params"}),", the logic varies:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"params"})," is of type ",(0,s.jsx)(n.code,{children:"map"}),": The key name will be automatically matched to the struct attribute in a ",(0,s.jsx)(n.strong,{children:"case-insensitive"})," and ",(0,s.jsx)(n.strong,{children:"special character ignored"})," manner."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"params"})," is of another type: The value will be matched against the first attribute of the ",(0,s.jsx)(n.code,{children:"struct"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Additionally, if the attribute of the ",(0,s.jsx)(n.code,{children:"struct"})," is a complex data type such as ",(0,s.jsx)(n.code,{children:"slice"}),", ",(0,s.jsx)(n.code,{children:"map"}),", ",(0,s.jsx)(n.code,{children:"struct"}),", recursive matching and assignment will be performed."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"If matching is successful, the key value is assigned to the attribute, otherwise the key value is ignored."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"matching-rules-priority-only-for-map-to-struct-conversion",children:"Matching Rules Priority (only for map to struct conversion)"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["If the ",(0,s.jsx)(n.code,{children:"mapping"})," parameter is not empty, it maps according to the ",(0,s.jsx)(n.code,{children:"key"})," to ",(0,s.jsx)(n.code,{children:"struct field name"})," relationship."]}),"\n",(0,s.jsxs)(n.li,{children:["If a field ",(0,s.jsx)(n.code,{children:"tag"})," is set, it will use the ",(0,s.jsx)(n.code,{children:"tag"})," to match the ",(0,s.jsx)(n.code,{children:"key"})," of the ",(0,s.jsx)(n.code,{children:"params"})," parameter.\nIf no ",(0,s.jsx)(n.code,{children:"tag"})," is set, gconv will look for the field ",(0,s.jsx)(n.code,{children:"tag"})," in the order of ",(0,s.jsx)(n.code,{children:"gconv, param, c, p, json"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Match according to ",(0,s.jsx)(n.code,{children:"field name"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["If none of the above matches, gconv will iterate through all ",(0,s.jsx)(n.code,{children:"key"}),"s in ",(0,s.jsx)(n.code,{children:"params"}),", matching according to the following rules:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Field name"}),": ignore case and underscores"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Key"}),": ignore case, underscores, and special characters"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Tip"}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"Unless there are special circumstances, please try to satisfy the first three rules as the fourth rule is less performant."})}),"\n",(0,s.jsxs)(n.p,{children:["Here are some examples of ",(0,s.jsx)(n.code,{children:"map"})," key names and ",(0,s.jsx)(n.code,{children:"struct"})," attribute names:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"map key     struct attribute   match?\nname        Name               match\nEmail       Email              match\nnickname    NickName           match\nNICKNAME    NickName           match\nNick-Name   NickName           match\nnick_name   NickName           match\nnick name   NickName           match\nNickName    Nick_Name          match\nNick-name   Nick_Name          match\nnick_name   Nick_Name          match\nnick name   Nick_Name          match\n"})}),"\n",(0,s.jsx)(n.h2,{id:"automatic-object-creation",children:"Automatic Object Creation"}),"\n",(0,s.jsxs)(n.p,{children:["When the given ",(0,s.jsx)(n.code,{children:"pointer"})," parameter type is ",(0,s.jsx)(n.code,{children:"**struct"}),", the ",(0,s.jsx)(n.code,{children:"Struct"})," method will automatically create the ",(0,s.jsx)(n.code,{children:"struct"})," object and modify the pointer address to which the variable points."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/util/gconv"\n)\n\nfunc main() {\n    type User struct {\n        Uid  int\n        Name string\n    }\n    params := g.Map{\n        "uid":  1,\n        "name": "john",\n    }\n    var user *User\n    if err := gconv.Struct(params, &user); err != nil {\n        panic(err)\n    }\n    g.Dump(user)\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"After execution, the output is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n    Uid:  1,\n    Name: "john",\n}\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"struct-recursive-conversion",children:[(0,s.jsx)(n.code,{children:"Struct"})," Recursive Conversion"]}),"\n",(0,s.jsxs)(n.p,{children:["Recursive conversion refers to the capability to map ",(0,s.jsx)(n.code,{children:"params"})," parameter data (the first parameter) recursively onto sub-objects when a ",(0,s.jsx)(n.code,{children:"struct"})," object contains sub-objects that are defined in an ",(0,s.jsx)(n.code,{children:"embedded"})," manner. It is often used in ",(0,s.jsx)(n.code,{children:"struct"})," objects with inherited objects."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/util/gconv"\n)\n\nfunc main() {\n    type Ids struct {\n        Id         int    `json:"id"`\n        Uid        int    `json:"uid"`\n    }\n    type Base struct {\n        Ids\n        CreateTime string `json:"create_time"`\n    }\n    type User struct {\n        Base\n        Passport   string `json:"passport"`\n        Password   string `json:"password"`\n        Nickname   string `json:"nickname"`\n    }\n    data := g.Map{\n        "id"          : 1,\n        "uid"         : 100,\n        "passport"    : "john",\n        "password"    : "123456",\n        "nickname"    : "John",\n        "create_time" : "2019",\n    }\n    user := new(User)\n    gconv.Struct(data, user)\n    g.Dump(user)\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"After execution, the output in the terminal is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n    Id:         1,\n    Uid:        100,\n    CreateTime: "2019",\n    Passport:   "john",\n    Password:   "123456",\n    Nickname:   "John",\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"example-1-basic-usage",children:"Example 1: Basic Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/util/gconv"\n)\n\ntype User struct {\n    Uid      int\n    Name     string\n    SiteUrl  string\n    NickName string\n    Pass1    string `c:"password1"`\n    Pass2    string `c:"password2"`\n}\n\nfunc main() {\n    var user *User\n\n    // Use default mapping rules to bind attribute values to objects\n    user = new(User)\n    params1 := g.Map{\n        "uid":       1,\n        "Name":      "john",\n        "site_url":  "https://goframe.org",\n        "nick_name": "johng",\n        "PASS1":     "123",\n        "PASS2":     "456",\n    }\n    if err := gconv.Struct(params1, user); err == nil {\n        g.Dump(user)\n    }\n\n    // Use struct tag mapping to bind attribute values to objects\n    user = new(User)\n    params2 := g.Map{\n        "uid":       2,\n        "name":      "smith",\n        "site-url":  "https://goframe.org",\n        "nick name": "johng",\n        "password1": "111",\n        "password2": "222",\n    }\n    if err := gconv.Struct(params2, user); err == nil {\n        g.Dump(user)\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As seen, you can directly bind a ",(0,s.jsx)(n.code,{children:"map"})," to a ",(0,s.jsx)(n.code,{children:"struct"})," using the ",(0,s.jsx)(n.code,{children:"Struct"})," method with default rules or flexibly configure using the ",(0,s.jsx)(n.code,{children:"struct tag"}),". Additionally, the ",(0,s.jsx)(n.code,{children:"Struct"})," method has the third ",(0,s.jsx)(n.code,{children:"map"})," parameter to specify custom parameter name to attribute name mappings."]}),"\n",(0,s.jsx)(n.p,{children:"After execution, the output is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n    Uid:      1,\n    Name:     "john",\n    SiteUrl:  "https://goframe.org",\n    NickName: "johng",\n    Pass1:    "123",\n    Pass2:    "456",\n}\n{\n    Uid:      2,\n    Name:     "smith",\n    SiteUrl:  "https://goframe.org",\n    NickName: "johng",\n    Pass1:    "111",\n    Pass2:    "222",\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"example-2-complex-attribute-types",children:"Example 2: Complex Attribute Types"}),"\n",(0,s.jsxs)(n.p,{children:["Attributes support conversion of ",(0,s.jsx)(n.code,{children:"struct"})," objects or ",(0,s.jsx)(n.code,{children:"struct"})," object pointers (if the target is a pointer and ",(0,s.jsx)(n.code,{children:"nil"}),", it will be initialized during conversion)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "github.com/gogf/gf/v2/util/gconv"\n    "github.com/gogf/gf/v2/frame/g"\n    "fmt"\n)\n\nfunc main() {\n    type Score struct {\n        Name   string\n        Result int\n    }\n    type User1 struct {\n        Scores Score\n    }\n    type User2 struct {\n        Scores *Score\n    }\n\n    user1  := new(User1)\n    user2  := new(User2)\n    scores := g.Map{\n        "Scores": g.Map{\n            "Name":   "john",\n            "Result": 100,\n        },\n    }\n\n    if err := gconv.Struct(scores, user1); err != nil {\n        fmt.Println(err)\n    } else {\n        g.Dump(user1)\n    }\n    if err := gconv.Struct(scores, user2); err != nil {\n        fmt.Println(err)\n    } else {\n        g.Dump(user2)\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"After execution, the output is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n    Scores: {\n        Name:   "john",\n        Result: 100,\n    },\n}\n{\n    Scores: {\n        Name:   "john",\n        Result: 100,\n    },\n}\n'})})]})}function u(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return o},a:function(){return c}});var r=t(667294);let s={},i=r.createContext(s);function c(e){let n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);