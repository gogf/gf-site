"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["44020"],{25263:function(e,t,n){n.r(t),n.d(t,{metadata:()=>i,contentTitle:()=>d,default:()=>u,assets:()=>o,toc:()=>c,frontMatter:()=>a});var i=JSON.parse('{"id":"quick/\u9879\u76EE\u811A\u624B\u67B6/\u63A5\u53E3\u5F00\u53D1/Step3 - \u7F16\u5199api\u63A5\u53E3\u5B9A\u4E49","title":"Step3 - Write API Definition","description":"Define CRUD APIs in the project\'s api directory, adopting a RESTful style of API design, using HTTP Method to standardize API requests. API definitions use g.Meta to manage metadata information, including route address, request method, and API description. The request parameters and return data structures define detailed parameter validation rules. Starting with version v1 for API version control to maintain future compatibility. APIs flexibly receive parameters to meet the diverse needs of API requests.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/quick/\u9879\u76EE\u811A\u624B\u67B6/\u63A5\u53E3\u5F00\u53D1/Step3 - \u7F16\u5199api\u63A5\u53E3\u5B9A\u4E49.md","sourceDirName":"quick/\u9879\u76EE\u811A\u624B\u67B6/\u63A5\u53E3\u5F00\u53D1","slug":"/quick/scaffold-api-definition","permalink":"/en/quick/scaffold-api-definition","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/quick/\u9879\u76EE\u811A\u624B\u67B6/\u63A5\u53E3\u5F00\u53D1/Step3 - \u7F16\u5199api\u63A5\u53E3\u5B9A\u4E49.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732541616000,"sidebarPosition":3,"frontMatter":{"slug":"/quick/scaffold-api-definition","title":"Step3 - Write API Definition","hide_title":true,"sidebar_position":3,"keywords":["GoFrame","API Definition","RESTful","HTTP Method","Versioning","Parameter Validation","User Management","Metadata Management","Data Return","Golang"],"description":"Define CRUD APIs in the project\'s api directory, adopting a RESTful style of API design, using HTTP Method to standardize API requests. API definitions use g.Meta to manage metadata information, including route address, request method, and API description. The request parameters and return data structures define detailed parameter validation rules. Starting with version v1 for API version control to maintain future compatibility. APIs flexibly receive parameters to meet the diverse needs of API requests."},"sidebar":"quickSidebar","previous":{"title":"Step2 - Generate dao/do/entity","permalink":"/en/quick/scaffold-api-gen-dao"},"next":{"title":"Step4 - Generate Controller","permalink":"/en/quick/scaffold-api-controller"}}'),r=n("785893"),s=n("250065");let a={slug:"/quick/scaffold-api-definition",title:"Step3 - Write API Definition",hide_title:!0,sidebar_position:3,keywords:["GoFrame","API Definition","RESTful","HTTP Method","Versioning","Parameter Validation","User Management","Metadata Management","Data Return","Golang"],description:"Define CRUD APIs in the project's api directory, adopting a RESTful style of API design, using HTTP Method to standardize API requests. API definitions use g.Meta to manage metadata information, including route address, request method, and API description. The request parameters and return data structures define detailed parameter validation rules. Starting with version v1 for API version control to maintain future compatibility. APIs flexibly receive parameters to meet the diverse needs of API requests."},d=void 0,o={},c=[{value:"<code>Create</code>",id:"create",level:2},{value:"<code>Delete</code>",id:"delete",level:2},{value:"<code>Update</code>",id:"update",level:2},{value:"<code>GetOne</code>",id:"getone",level:2},{value:"<code>GetList</code>",id:"getlist",level:2},{value:"Learning Summary",id:"learning-summary",level:2}];function l(e){let t={a:"a",admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["In the ",(0,r.jsx)(t.code,{children:"api"})," directory of the project, we begin defining our ",(0,r.jsx)(t.code,{children:"CRUD"})," APIs."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["We use the ",(0,r.jsx)(t.code,{children:"RESTful"})," style for API design, fully utilizing the ",(0,r.jsx)(t.code,{children:"GET/POST/PUT/DELETE"})," HTTP Methods. This standardized design results in very elegant APIs."]}),"\n",(0,r.jsxs)(t.li,{children:["Similarly, we start with version ",(0,r.jsx)(t.code,{children:"v1"}),". Using version numbers is a good development habit, which helps in maintaining compatibility in future APIs."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"user api definition",src:n(614463).Z+"",width:"3412",height:"2002"})}),"\n",(0,r.jsx)(t.h2,{id:"create",children:(0,r.jsx)(t.code,{children:"Create"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",metastring:'title="api/user/v1/user.go"',children:'type CreateReq struct {\n    g.Meta `path:"/user" method:"post" tags:"User" summary:"Create user"`\n    Name   string `v:"required|length:3,10" dc:"user name"`\n    Age    uint   `v:"required|between:18,200" dc:"user age"`\n}\ntype CreateRes struct {\n    Id int64 `json:"id" dc:"user id"`\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"Brief Introduction:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["In API definitions, ",(0,r.jsx)(t.code,{children:"g.Meta"})," is used to manage API metadata information, which are defined as tags on the ",(0,r.jsx)(t.code,{children:"g.Meta"})," property. These metadata include ",(0,r.jsx)(t.code,{children:"path"})," (route address), ",(0,r.jsx)(t.code,{children:"method"})," (request method), ",(0,r.jsx)(t.code,{children:"tags"})," (API group for generating API documentation), and ",(0,r.jsx)(t.code,{children:"summary"})," (API description). These metadata are part of ",(0,r.jsx)(t.code,{children:"OpenAPIv3"}),", which we won't go into detail here. For those interested, refer to the chapter: ",(0,r.jsx)(t.a,{href:"/en/docs/web/api-document-openapiv3",children:"API Document - OpenAPIv3"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"Name"})," and ",(0,r.jsx)(t.code,{children:"Age"})," attributes here are the parameter definitions for our API. The ",(0,r.jsx)(t.code,{children:"dc"})," tag is a shorthand for ",(0,r.jsx)(t.code,{children:"description"}),", indicating the meaning of the parameter; the ",(0,r.jsx)(t.code,{children:"v"})," tag is a shorthand for ",(0,r.jsx)(t.code,{children:"valid"}),", indicating the validation rules for the parameter. We use three built-in validation rules here:","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"required"}),": The parameter is mandatory."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"length"}),": Validates the parameter's length."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"between"}),": Validates the parameter's range.\nLearn about these here, and refer to the section ",(0,r.jsx)(t.a,{href:"/en/docs/core/gvalid-rules",children:"Data Validation - Rules"})," for more validation rules."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["The request parameter structure ",(0,r.jsx)(t.code,{children:"CreateReq"})," does not specify parameter reception methods because the ",(0,r.jsx)(t.code,{children:"GoFrame"})," framework supports very flexible parameter reception methods, automatically recognizing ",(0,r.jsx)(t.code,{children:"Query String/Form/Json/Xml"})," submission methods and mapping the submitted parameters to the request parameter receiving objects."]}),"\n",(0,r.jsxs)(t.li,{children:["Only the return parameter structures have ",(0,r.jsx)(t.code,{children:"json"})," tags because the returned data usually needs to be converted to ",(0,r.jsx)(t.code,{children:"json"})," format for use by the frontend, and parameter naming in ",(0,r.jsx)(t.code,{children:"snake"})," style is more in line with frontend naming conventions."]}),"\n"]}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["In a ",(0,r.jsx)(t.code,{children:"RESTful"})," style API design, we typically use ",(0,r.jsx)(t.code,{children:"POST"})," from the ",(0,r.jsx)(t.code,{children:"HTTP Method"})," to denote write operations and ",(0,r.jsx)(t.code,{children:"PUT"})," to denote update operations."]})}),"\n",(0,r.jsx)(t.h2,{id:"delete",children:(0,r.jsx)(t.code,{children:"Delete"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",metastring:'title="api/user/v1/user.go"',children:'type DeleteReq struct {\n    g.Meta `path:"/user/{id}" method:"delete" tags:"User" summary:"Delete user"`\n    Id     int64 `v:"required" dc:"user id"`\n}\ntype DeleteRes struct{}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["The route tag ",(0,r.jsx)(t.code,{children:"path"})," uses ",(0,r.jsx)(t.code,{children:"/user/{id}"}),", where ",(0,r.jsx)(t.code,{children:"{id}"})," indicates a field-matching route, passed through the ",(0,r.jsx)(t.code,{children:"URL Path"}),", with the parameter name ",(0,r.jsx)(t.code,{children:"id"}),". As seen, we define an ",(0,r.jsx)(t.code,{children:"Id"})," parameter in the request parameter object, and the ",(0,r.jsx)(t.code,{children:"id"})," parameter from the route will ",(0,r.jsx)(t.strong,{children:"map directly without case sensitivity"})," to this ",(0,r.jsx)(t.code,{children:"Id"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["For example: In the route ",(0,r.jsx)(t.code,{children:"/user/1"}),", the ",(0,r.jsx)(t.code,{children:"id"})," parameter value is ",(0,r.jsx)(t.code,{children:"1"}),"; in the route ",(0,r.jsx)(t.code,{children:"/user/100"}),", the ",(0,r.jsx)(t.code,{children:"id"})," parameter value is ",(0,r.jsx)(t.code,{children:"100"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"update",children:(0,r.jsx)(t.code,{children:"Update"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",metastring:'title="api/user/v1/user.go"',children:'// Status marks user status.\ntype Status int\n\nconst (\n    StatusOK       Status = 0 // User is OK.\n    StatusDisabled Status = 1 // User is disabled.\n)\n\ntype UpdateReq struct {\n    g.Meta `path:"/user/{id}" method:"put" tags:"User" summary:"Update user"`\n    Id     int64   `v:"required" dc:"user id"`\n    Name   *string `v:"length:3,10" dc:"user name"`\n    Age    *uint   `v:"between:18,200" dc:"user age"`\n    Status *Status `v:"in:0,1" dc:"user status"`\n}\ntype UpdateRes struct{}\n'})}),"\n",(0,r.jsx)(t.p,{children:"Here:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["We define a user status type ",(0,r.jsx)(t.code,{children:"Status"}),", using the conventional ",(0,r.jsx)(t.code,{children:"enums"})," definition style in ",(0,r.jsx)(t.code,{children:"Golang"}),". Just for understanding here."]}),"\n",(0,r.jsxs)(t.li,{children:["The validation for the ",(0,r.jsx)(t.code,{children:"Status"})," parameter uses the ",(0,r.jsx)(t.code,{children:"in:0,1"})," rule, which checks that the passed ",(0,r.jsx)(t.code,{children:"Status"})," value must be one of the two constants we defined, ",(0,r.jsx)(t.code,{children:"StatusOK/StatusDisabled"}),", i.e., ",(0,r.jsx)(t.code,{children:"0/1"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["The API parameters use pointers to avoid default type values affecting our update API. For example, if ",(0,r.jsx)(t.code,{children:"Status"})," is not defined as a pointer, it will be affected by the default value ",(0,r.jsx)(t.code,{children:"0"}),". During processing logic, it's hard to determine whether the caller has passed the parameter and whether to actually change the value to ",(0,r.jsx)(t.code,{children:"0"}),". By using pointers, when users don't pass the parameter, its default value is ",(0,r.jsx)(t.code,{children:"nil"}),", making it easy to judge in processing logic."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"getone",children:(0,r.jsx)(t.code,{children:"GetOne"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",metastring:'title="api/user/v1/user.go"',children:'type GetOneReq struct {\n    g.Meta `path:"/user/{id}" method:"get" tags:"User" summary:"Get one user"`\n    Id     int64 `v:"required" dc:"user id"`\n}\ntype GetOneRes struct {\n    *entity.User `dc:"user"`\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Here, the return result uses the ",(0,r.jsx)(t.code,{children:"*entity.User"})," structure, which was generated by the ",(0,r.jsx)(t.code,{children:"make dao"})," command earlier. This data structure corresponds to the database table fields one-to-one."]}),"\n",(0,r.jsx)(t.h2,{id:"getlist",children:(0,r.jsx)(t.code,{children:"GetList"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",metastring:'title="api/user/v1/user.go"',children:'type GetListReq struct {\n    g.Meta `path:"/user" method:"get" tags:"User" summary:"Get users"`\n    Age    *uint   `v:"between:18,200" dc:"user age"`\n    Status *Status `v:"in:0,1" dc:"user age"`\n}\ntype GetListRes struct {\n    List []*entity.User `json:"list" dc:"user list"`\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["This API can query by ",(0,r.jsx)(t.code,{children:"Age"})," and ",(0,r.jsx)(t.code,{children:"Status"}),", returning multiple records ",(0,r.jsx)(t.code,{children:"List []*entity.User"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"learning-summary",children:"Learning Summary"}),"\n",(0,r.jsxs)(t.p,{children:["Sample code for this chapter: ",(0,r.jsx)(t.a,{href:"https://github.com/gogf/quick-demo/blob/main/api/user/v1/user.go",children:"https://github.com/gogf/quick-demo/blob/main/api/user/v1/user.go"})]}),"\n",(0,r.jsxs)(t.p,{children:["As shown, defining ",(0,r.jsx)(t.code,{children:"api"})," APIs in the ",(0,r.jsx)(t.code,{children:"GoFrame"})," framework's scaffolding project is quite elegant, with support for automatic data validation, metadata injection, flexible route configuration, and other practical features. This method of API definition allows for the automatic generation of API documentation, where the code serves as documentation, ensuring consistency between code and documentation."]}),"\n",(0,r.jsxs)(t.p,{children:["Moreover, this is not the full charm of ",(0,r.jsx)(t.code,{children:"GoFrame"}),", just a single petal on the rose. Next, we will use scaffold tools to automatically generate the corresponding ",(0,r.jsx)(t.code,{children:"controller"})," control code for us."]})]})}function u(e={}){let{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},614463:function(e,t,n){n.d(t,{Z:function(){return i}});let i=n.p+"assets/images/QQ_1732094808338-5f9ffafa066a9807c0f608bb42264581.png"},250065:function(e,t,n){n.d(t,{Z:function(){return d},a:function(){return a}});var i=n(667294);let r={},s=i.createContext(r);function a(e){let t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);