"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["42814"],{504870:function(e,n,t){t.r(n),t.d(n,{metadata:()=>i,contentTitle:()=>s,default:()=>h,assets:()=>c,toc:()=>d,frontMatter:()=>a});var i=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u9AD8\u7EA7\u7279\u6027/ORM\u9AD8\u7EA7\u7279\u6027-\u5B57\u6BB5\u6620\u5C04","title":"ORM Senior - Field Mapping","description":"Through the advanced ORM features of the GoFrame framework, automatic field mapping and recognition can be achieved. When parameters of Map or Struct types are used, table field names are automatically matched, significantly reducing the workload for developers in manually matching data fields and business attributes. In addition, by designing interfaces and caching field information in memory, data operation efficiency is improved. This article also demonstrates how to effectively query user and doctor information through practical examples.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u9AD8\u7EA7\u7279\u6027/ORM\u9AD8\u7EA7\u7279\u6027-\u5B57\u6BB5\u6620\u5C04.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u9AD8\u7EA7\u7279\u6027","slug":"/docs/core/gdb-senior-fields-mapping","permalink":"/en/docs/core/gdb-senior-fields-mapping","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u9AD8\u7EA7\u7279\u6027/ORM\u9AD8\u7EA7\u7279\u6027-\u5B57\u6BB5\u6620\u5C04.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732440306000,"sidebarPosition":4,"frontMatter":{"slug":"/docs/core/gdb-senior-fields-mapping","title":"ORM Senior - Field Mapping","sidebar_position":4,"hide_title":true,"keywords":["ORM Advanced Features","Field Mapping","Automatic Table Recognition","GoFrame Framework","Interface Design","Field Cache Management","Protobuf Interface","User Information Query","Field Matching Rules","SQL Query Optimization"],"description":"Through the advanced ORM features of the GoFrame framework, automatic field mapping and recognition can be achieved. When parameters of Map or Struct types are used, table field names are automatically matched, significantly reducing the workload for developers in manually matching data fields and business attributes. In addition, by designing interfaces and caching field information in memory, data operation efficiency is improved. This article also demonstrates how to effectively query user and doctor information through practical examples."},"sidebar":"mainSidebar","previous":{"title":"ORM Senior - Logging","permalink":"/en/docs/core/gdb-senior-logging"},"next":{"title":"ORM Senior - Dry Run","permalink":"/en/docs/core/gdb-senior-dry-run"}}'),o=t("785893"),r=t("250065");let a={slug:"/docs/core/gdb-senior-fields-mapping",title:"ORM Senior - Field Mapping",sidebar_position:4,hide_title:!0,keywords:["ORM Advanced Features","Field Mapping","Automatic Table Recognition","GoFrame Framework","Interface Design","Field Cache Management","Protobuf Interface","User Information Query","Field Matching Rules","SQL Query Optimization"],description:"Through the advanced ORM features of the GoFrame framework, automatic field mapping and recognition can be achieved. When parameters of Map or Struct types are used, table field names are automatically matched, significantly reducing the workload for developers in manually matching data fields and business attributes. In addition, by designing interfaces and caching field information in memory, data operation efficiency is improved. This article also demonstrates how to effectively query user and doctor information through practical examples."},s=void 0,c={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Important Notes",id:"important-notes",level:2},{value:"Interface Design",id:"interface-design",level:3},{value:"Field Cache",id:"field-cache",level:3},{value:"Usage Example",id:"usage-example",level:2}];function l(e){let n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(n.p,{children:["When writing or updating data using methods like ",(0,o.jsx)(n.code,{children:"Fields/Data/Scan"}),", if the given parameter is of ",(0,o.jsx)(n.code,{children:"map/struct"})," type, the key names/property names of the parameter will automatically be case-insensitively and character-independently mapped to the fields of the data table."]}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["This is why the ",(0,o.jsx)(n.code,{children:"SHOW FULL COLUMNS FROM 'xxx'"})," statement appears when performing database operations with database components. This statement is executed only once per table and the results are then cached in memory."]})}),"\n",(0,o.jsx)(n.p,{children:"Examples of matching rules:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",children:"Map Key     Field Name   Match\nnickname    nickname     match\nNICKNAME    nickname     match\nNick-Name   nickname     match\nnick_name   nickname     match\nnick name   nickname     match\nNickName    nickname     match\nNick-name   nickname     match\nnick_name   nickname     match\nnick name   nickname     match\n"})}),"\n",(0,o.jsx)(n.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,o.jsx)(n.h3,{id:"interface-design",children:"Interface Design"}),"\n",(0,o.jsxs)(n.p,{children:["This feature depends on the ",(0,o.jsx)(n.code,{children:"TableFields"})," interface defined in ",(0,o.jsx)(n.code,{children:"DB"}),". If this interface is not implemented, the upper-level business needs to maintain the mapping relationship between property/key names and table fields, which incurs a considerable overhead unrelated to business logic. The goal of the framework is to let developers focus as much as possible on the business, hence adopting automation in places where framework components can be automated. The ",(0,o.jsx)(n.code,{children:"driver"})," implementations integrated with the framework currently all support this interface."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"// TableFields retrieves and returns the fields' information of specified table of current\n// schema.\n//\n// The parameter `link` is optional, if given nil it automatically retrieves a raw sql connection\n// as its link to proceed necessary sql query.\n//\n// Note that it returns a map containing the field name and its corresponding fields.\n// As a map is unsorted, the TableField struct has an \"Index\" field marks its sequence in\n// the fields.\n//\n// It's using cache feature to enhance the performance, which is never expired until the\n// process restarts.\nfunc (db DB) TableFields(ctx context.Context, table string, schema ...string) (fields map[string]*TableField, err error)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"field-cache",children:"Field Cache"}),"\n",(0,o.jsx)(n.p,{children:"The field information of each data table is queried and cached in memory during the first operation on the table. If you need to manually refresh the field cache, you can do so with the following methods:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"// ClearTableFields removes certain cached table fields of current configuration group.\nfunc (c *Core) ClearTableFields(ctx context.Context, table string, schema ...string) (err error)\n\n// ClearTableFieldsAll removes all cached table fields of current configuration group.\nfunc (c *Core) ClearTableFieldsAll(ctx context.Context) (err error)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The introductions of the methods are as in the comments. As can be seen, these two methods are mounted on the ",(0,o.jsx)(n.code,{children:"Core"})," object, and the underlying ",(0,o.jsx)(n.code,{children:"Core"})," object is already exposed through the ",(0,o.jsx)(n.code,{children:"DB"})," interface, thus we can obtain the ",(0,o.jsx)(n.code,{children:"Core"})," object like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"g.DB().GetCore()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,o.jsx)(n.p,{children:"Let's look at an example where we implement an interface for querying basic user information, with the user being a doctor."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["We have two tables, a ",(0,o.jsx)(n.code,{children:"user"})," table with about ",(0,o.jsx)(n.code,{children:"30"})," fields, and a ",(0,o.jsx)(n.code,{children:"doctor_user"})," table with over ",(0,o.jsx)(n.code,{children:"80"})," fields."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"user"})," is the basic user table containing the most basic user information, while ",(0,o.jsx)(n.code,{children:"doctor_user"})," is a business extension table based on the ",(0,o.jsx)(n.code,{children:"user"})," table for a specific user role, forming a one-to-one relationship with the ",(0,o.jsx)(n.code,{children:"user"})," table."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["We have a ",(0,o.jsx)(n.code,{children:"GRPC"})," interface with the following definition (for demonstration purposes, some simplifications are made here):"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"GetDoctorInfoRes"})}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'// Query interface return data structure\ntype GetDoctorInfoRes struct {\n    UserInfo             *UserInfo   `protobuf:"bytes,1,opt,name=UserInfo,proto3" json:"UserInfo,omitempty"`\n    DoctorInfo           *DoctorInfo `protobuf:"bytes,2,opt,name=DoctorInfo,proto3" json:"DoctorInfo,omitempty"`\n    XXX_NoUnkeyedLiteral struct{}    `json:"-"`\n    XXX_unrecognized     []byte      `json:"-"`\n    XXX_sizecache        int32       `json:"-"`\n}\n'})}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"UserInfo"})}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'// Basic user information\ntype UserInfo struct {\n    Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`\n    Avatar               string   `protobuf:"bytes,2,opt,name=avatar,proto3" json:"avatar,omitempty"`\n    Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`\n    Sex                  int32    `protobuf:"varint,4,opt,name=sex,proto3" json:"sex,omitempty"`\n    XXX_NoUnkeyedLiteral struct{} `json:"-"`\n    XXX_unrecognized     []byte   `json:"-"`\n    XXX_sizecache        int32    `json:"-"`\n}\n'})}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"DoctorInfo"})}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'// Doctor information\ntype DoctorInfo struct {\n    Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`\n    Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`\n    Hospital             string   `protobuf:"bytes,4,opt,name=hospital,proto3" json:"hospital,omitempty"`\n    Section              string   `protobuf:"bytes,6,opt,name=section,proto3" json:"section,omitempty"`\n    Title                string   `protobuf:"bytes,8,opt,name=title,proto3" json:"title,omitempty"`\n    XXX_NoUnkeyedLiteral struct{} `json:"-"`\n    XXX_unrecognized     []byte   `json:"-"`\n    XXX_sizecache        int32    `json:"-"`\n}\n'})}),"\n",(0,o.jsxs)(n.ol,{start:"4",children:["\n",(0,o.jsx)(n.li,{children:"Query interface implementation code"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"// Query doctor information\nfunc (s *Service) GetDoctorInfo(ctx context.Context, req *pb.GetDoctorInfoReq) (res *pb.GetDoctorInfoRes, err error) {\n    // Protobuf return data structure\n    res = &pb.GetDoctorInfoRes{}\n    // Query doctor information\n    // SELECT `id`,`avatar`,`name`,`sex` FROM `user` WHERE `user_id`=xxx\n    err = dao.PrimaryDoctorUser.\n        Ctx(ctx).\n        Fields(res.DoctorInfo).\n        Where(dao.PrimaryDoctorUser.Columns.UserId, req.Id).\n        Scan(&res.DoctorInfo)\n    if err != nil {\n        return\n    }\n    // Query basic user information\n    // SELECT `id`,`name`,`hospital`,`section`,`title` FROM `doctor_user` WHERE `id`=xxx\n    err = dao.PrimaryUser.\n        Ctx(ctx).\n        Fields(res.DoctorInfo).\n        Where(dao.PrimaryUser.Columns.Id, req.Id).\n        Scan(&res.UserInfo)\n    return res, err\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["When we call ",(0,o.jsx)(n.code,{children:"GetDoctorInfo"})," to execute the query, two ",(0,o.jsx)(n.code,{children:"SQL"})," queries will be sent to the database, for instance:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"SELECT `id`,`avatar`,`name`,`sex` FROM `user` WHERE `user_id`=1\nSELECT `id`,`name`,`hospital`,`section`,`title` FROM `doctor_user` WHERE `id`=1\n"})}),"\n",(0,o.jsx)(n.p,{children:"As can be seen:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["When using the ",(0,o.jsx)(n.code,{children:"Fields"})," method, the parameter type is a ",(0,o.jsx)(n.code,{children:"struct"})," or ",(0,o.jsx)(n.code,{children:"*struct"}),", and the ",(0,o.jsx)(n.code,{children:"ORM"})," will automatically map the property names of the ",(0,o.jsx)(n.code,{children:"struct"})," to the field names of the data table. When the mapping is successful, only specific field data is queried, and non-existent property fields will be automatically filtered."]}),"\n",(0,o.jsxs)(n.li,{children:["When using the ",(0,o.jsx)(n.code,{children:"Scan"})," method (also applicable with ",(0,o.jsx)(n.code,{children:"Struct"}),"/",(0,o.jsx)(n.code,{children:"Structs"}),"), the parameter type is a ",(0,o.jsx)(n.code,{children:"*struct"})," or ",(0,o.jsx)(n.code,{children:"**struct"}),", and the query results will automatically map to the properties of the ",(0,o.jsx)(n.code,{children:"struct"}),". When the mapping is successful, conversion and assignment are automatically done; otherwise, no processing is done on the attributes of the parameters."]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return s},a:function(){return a}});var i=t(667294);let o={},r=i.createContext(o);function a(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);