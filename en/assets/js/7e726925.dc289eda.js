"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["771612"],{590477:function(n,e,t){t.r(e),t.d(e,{metadata:()=>r,contentTitle:()=>s,default:()=>l,assets:()=>c,toc:()=>u,frontMatter:()=>o});var r=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u4E8B\u52A1\u5904\u7406/ORM\u4E8B\u52A1\u5904\u7406-\u4E8B\u52A1\u4F20\u64AD","title":"ORM Transactions - Propagation","description":"GoFrame ORM transaction propagation provides a flexible transaction management mechanism, supporting various transaction propagation behaviors to meet transaction processing requirements in complex business scenarios.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u4E8B\u52A1\u5904\u7406/ORM\u4E8B\u52A1\u5904\u7406-\u4E8B\u52A1\u4F20\u64AD.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u4E8B\u52A1\u5904\u7406","slug":"/docs/core/gdb-transaction-propagation","permalink":"/en/docs/core/gdb-transaction-propagation","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u4E8B\u52A1\u5904\u7406/ORM\u4E8B\u52A1\u5904\u7406-\u4E8B\u52A1\u4F20\u64AD.md","tags":[],"version":"current","lastUpdatedBy":"John Guo","lastUpdatedAt":1742194305000,"sidebarPosition":4000,"frontMatter":{"slug":"/docs/core/gdb-transaction-propagation","title":"ORM Transactions - Propagation","sidebar_position":4000,"hide_title":true,"keywords":["GoFrame","ORM","Transaction","Transaction Propagation","Nested Transaction","Distributed Transaction"],"description":"GoFrame ORM transaction propagation provides a flexible transaction management mechanism, supporting various transaction propagation behaviors to meet transaction processing requirements in complex business scenarios."},"sidebar":"mainSidebar","previous":{"title":"ORM Transaction - Nested","permalink":"/en/docs/core/gdb-transaction-nested"},"next":{"title":"ORM Transactions - Isolation Levels","permalink":"/en/docs/core/gdb-transaction-isolation-level"}}'),a=t("785893"),i=t("250065");let o={slug:"/docs/core/gdb-transaction-propagation",title:"ORM Transactions - Propagation",sidebar_position:4e3,hide_title:!0,keywords:["GoFrame","ORM","Transaction","Transaction Propagation","Nested Transaction","Distributed Transaction"],description:"GoFrame ORM transaction propagation provides a flexible transaction management mechanism, supporting various transaction propagation behaviors to meet transaction processing requirements in complex business scenarios."},s=void 0,c={},u=[{value:"Basic Introduction",id:"basic-introduction",level:2},{value:"Advantages",id:"advantages",level:2},{value:"Application Scenarios",id:"application-scenarios",level:2},{value:"Usage Examples",id:"usage-examples",level:2},{value:"PropagationNested (Nested Transaction, Default)",id:"propagationnested-nested-transaction-default",level:3},{value:"PropagationRequired (Ensure Transaction)",id:"propagationrequired-ensure-transaction",level:3},{value:"PropagationRequiresNew (Create New Transaction)",id:"propagationrequiresnew-create-new-transaction",level:3},{value:"PropagationSupports (Support Current Transaction)",id:"propagationsupports-support-current-transaction",level:3},{value:"PropagationMandatory (Force Transaction Use)",id:"propagationmandatory-force-transaction-use",level:3},{value:"PropagationNever (Disallow Execution in Transaction)",id:"propagationnever-disallow-execution-in-transaction",level:3},{value:"PropagationNotSupported (Execute Without Transaction)",id:"propagationnotsupported-execute-without-transaction",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(n){let e={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.p,{children:["Transaction Propagation is an advanced transaction management mechanism provided by the ",(0,a.jsx)(e.code,{children:"GoFrame ORM"})," framework, used to control the behavior of nested transactions. In complex business scenarios, one transaction method may call other transaction methods, requiring clear definition of transaction propagation behavior to ensure data consistency and integrity."]}),"\n",(0,a.jsx)(e.h2,{id:"basic-introduction",children:"Basic Introduction"}),"\n",(0,a.jsxs)(e.p,{children:["Transaction propagation defines how a transaction method should behave when called by another transaction method. ",(0,a.jsx)(e.code,{children:"GoFrame ORM"})," supports multiple transaction propagation behaviors, allowing developers to choose the appropriate propagation type based on business requirements."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"GoFrame ORM"})," supports the following transaction propagation types:"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"PropagationNested"})," (default): If a transaction exists, creates a nested transaction (using savepoints); if no transaction exists, creates a new transaction."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"PropagationRequired"}),": If a transaction exists, joins that transaction; if no transaction exists, creates a new transaction."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"PropagationSupports"}),": If a transaction exists, joins that transaction; if no transaction exists, executes without a transaction."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"PropagationRequiresNew"}),": Creates a new transaction; if a transaction exists, suspends the current transaction."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"PropagationNotSupported"}),": Executes without a transaction; if a transaction exists, suspends the current transaction."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"PropagationMandatory"}),": If a transaction exists, joins that transaction; if no transaction exists, throws an exception."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"PropagationNever"}),": Executes without a transaction; if a transaction exists, throws an exception."]}),"\n"]}),"\n",(0,a.jsx)(e.admonition,{type:"info",children:(0,a.jsxs)(e.p,{children:["Note: To ensure compatibility with older versions of transaction processing, the default transaction propagation type in ",(0,a.jsx)(e.code,{children:"GoFrame ORM"})," is ",(0,a.jsx)(e.code,{children:"PropagationNested"}),", not ",(0,a.jsx)(e.code,{children:"PropagationRequired"}),"."]})}),"\n",(0,a.jsx)(e.h2,{id:"advantages",children:"Advantages"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Flexible Transaction Management"}),": Choose different transaction propagation behaviors based on business requirements for more granular transaction control."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Improved Code Reusability"}),": Service layer methods can define transaction behavior independently, without concern for whether the calling environment already has a transaction."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Reduced Transaction Conflicts"}),": Through appropriate propagation behavior, reduce locking and conflicts caused by long transactions."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Enhanced Error Isolation"}),": Using independent transactions (such as ",(0,a.jsx)(e.code,{children:"PropagationRequiresNew"}),") can isolate error impacts and avoid entire transaction rollbacks."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Simplified Complex Business Logic"}),": In complex business processes, different steps can use different transaction propagation strategies, making code clearer."]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"application-scenarios",children:"Application Scenarios"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Service Composition"}),": When one service method calls multiple other service methods, you can choose to share the same transaction or use independent transactions based on business requirements."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Logging"}),": Business operations need to record logs, but log write failures should not affect the main business logic; ",(0,a.jsx)(e.code,{children:"PropagationRequiresNew"})," can be used."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Batch Processing"}),": In batch processing, you might want each item to use an independent transaction so that the failure of one item does not affect others."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Transaction Compensation"}),": In distributed systems, different propagation behaviors can be used to implement transaction compensation mechanisms."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Nested Business Logic"}),": Some steps in complex business logic may need to be treated as independent transaction units, using ",(0,a.jsx)(e.code,{children:"PropagationNested"}),"."]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,a.jsx)(e.p,{children:"Before starting the examples, let's create a table for testing:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS `user` (\n    id INT PRIMARY KEY,\n    username VARCHAR(50)\n);\n"})}),"\n",(0,a.jsx)(e.admonition,{type:"tip",children:(0,a.jsxs)(e.p,{children:["If you want to run the following examples step by step, you need to clear the ",(0,a.jsx)(e.code,{children:"user"})," table data before running each new example."]})}),"\n",(0,a.jsx)(e.h3,{id:"propagationnested-nested-transaction-default",children:"PropagationNested (Nested Transaction, Default)"}),"\n",(0,a.jsx)(e.p,{children:"If a transaction exists, creates a nested transaction (using savepoints); if no transaction exists, creates a new transaction."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n	_ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n\n	"context"\n	"fmt"\n\n	"github.com/gogf/gf/v2/database/gdb"\n	"github.com/gogf/gf/v2/frame/g"\n)\n\nfunc main() {\n	var (\n		ctx = context.Background()\n		db  = g.DB()\n	)\n	db.SetDebug(true)\n\n	// Execute transaction\n	err := db.Transaction(ctx, func(ctx context.Context, tx gdb.TX) error {\n		// Insert data in the outer transaction\n		_, err := tx.Insert("user", g.Map{\n			"id":       1,\n			"username": "outer_user",\n		})\n		if err != nil {\n			return err\n		}\n\n		// Nested transaction - using PropagationNested to create a nested transaction (using savepoint)\n		err = tx.Transaction(ctx, func(ctx context.Context, tx2 gdb.TX) error {\n			// Insert data in the nested transaction\n			_, err = tx2.Insert("user", g.Map{\n				"id":       2,\n				"username": "nested_user",\n			})\n			if err != nil {\n				return err\n			}\n\n			// Simulate an error, causing the nested transaction to roll back to the savepoint\n			return fmt.Errorf("nested transaction deliberately failed")\n		})\n\n		// Nested transaction failed, but outer transaction can continue\n		fmt.Println("Nested transaction error:", err)\n\n		// Continue inserting data in the outer transaction\n		_, err = tx.Insert("user", g.Map{\n			"id":       3,\n			"username": "outer_after_nested",\n		})\n		// Outer transaction commits normally\n		return nil\n	})\n\n	if err != nil {\n		fmt.Println("Transaction execution failed:", err)\n		return\n	}\n\n	// Query results\n	result, err := db.Model("user").All()\n	if err != nil {\n		fmt.Println("Query failed:", err)\n		return\n	}\n\n	// Data only contains records with id 1 and 3, not 2\n	fmt.Println("Query results:", result)\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"The SQL statements executed by the above code are similar to:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-sql",children:"-- Start outer transaction\nBEGIN;\n-- Insert outer data\nINSERT INTO user(id,username) VALUES(1,'outer_user');\n\n-- Create savepoint\nSAVEPOINT sp1;\n-- Insert nested transaction data\nINSERT INTO user(id,username) VALUES(2,'nested_user');\n-- Nested transaction fails, roll back to savepoint\nROLLBACK TO SAVEPOINT sp1;\n\n-- Continue outer transaction\nINSERT INTO user(id,username) VALUES(3,'outer_after_nested');\n-- Commit outer transaction\nCOMMIT;\n"})}),"\n",(0,a.jsx)(e.h3,{id:"propagationrequired-ensure-transaction",children:"PropagationRequired (Ensure Transaction)"}),"\n",(0,a.jsxs)(e.p,{children:["The main difference between ",(0,a.jsx)(e.code,{children:"PropagationRequired"})," and ",(0,a.jsx)(e.code,{children:"PropagationNested"})," is that ",(0,a.jsx)(e.code,{children:"PropagationRequired"})," joins the existing transaction when a transaction exists, and creates a new transaction when no transaction exists, ",(0,a.jsx)(e.strong,{children:"without creating a nested transaction"}),"."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n	_ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n\n	"context"\n	"fmt"\n\n	"github.com/gogf/gf/v2/database/gdb"\n	"github.com/gogf/gf/v2/frame/g"\n)\n\nfunc main() {\n	var (\n		ctx = context.Background()\n		db  = g.DB()\n	)\n	db.SetDebug(true)\n\n	// Execute transaction\n	err := db.Transaction(ctx, func(ctx context.Context, tx gdb.TX) error {\n		// Insert data in the outer transaction\n		// Using tx object or db object to operate on data tables within the transaction closure is equivalent\n		_, err := tx.Insert("user", g.Map{\n			"id":       1,\n			"username": "outer_user",\n		})\n		if err != nil {\n			return err\n		}\n\n		// Nested transaction - default using PropagationRequired\n		err = tx.TransactionWithOptions(ctx, gdb.TxOptions{\n			Propagation: gdb.PropagationRequired,\n		}, func(ctx context.Context, tx2 gdb.TX) error {\n			// Insert data in the nested transaction (using the same transaction)\n			// Using tx2 object or db object to operate on data tables within the transaction closure is equivalent\n			_, err = tx2.Insert("user", g.Map{\n				"id":       2,\n				"username": "inner_user",\n			})\n			return err\n		})\n\n		return err\n	})\n	if err != nil {\n		fmt.Println("Transaction execution failed:", err)\n		return\n	}\n\n	// Query results\n	result, err := db.Model("user").All()\n	if err != nil {\n		fmt.Println("Query failed:", err)\n		return\n	}\n\n	fmt.Println("Query results:", result)\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"The SQL statements executed by the above code are similar to:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-sql",children:"-- Start outer transaction\nBEGIN;\n-- Insert outer data\nINSERT INTO user(id,username) VALUES(1,'outer_user');\n-- Insert inner data (using the same transaction)\nINSERT INTO user(id,username) VALUES(2,'inner_user');\n-- Commit transaction\nCOMMIT;\n"})}),"\n",(0,a.jsx)(e.h3,{id:"propagationrequiresnew-create-new-transaction",children:"PropagationRequiresNew (Create New Transaction)"}),"\n",(0,a.jsx)(e.p,{children:"Creates a new transaction; if a transaction exists, suspends the current transaction."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n	_ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n\n	"context"\n	"fmt"\n\n	"github.com/gogf/gf/v2/database/gdb"\n	"github.com/gogf/gf/v2/frame/g"\n)\n\nfunc main() {\n	var (\n		ctx = context.Background()\n		db  = g.DB()\n	)\n	db.SetDebug(true)\n\n	// Execute transaction\n	err := db.Transaction(ctx, func(ctx context.Context, tx gdb.TX) error {\n		// Insert data in the outer transaction\n		_, err := tx.Insert("user", g.Map{\n			"id":       1,\n			"username": "outer_user",\n		})\n		if err != nil {\n			return err\n		}\n\n		// Nested transaction - using PropagationRequiresNew to create a new transaction\n		err = tx.TransactionWithOptions(ctx, gdb.TxOptions{\n			Propagation: gdb.PropagationRequiresNew,\n		}, func(ctx context.Context, tx2 gdb.TX) error {\n			// Insert data in the new transaction\n			_, err = tx2.Insert("user", g.Map{\n				"id":       2,\n				"username": "new_tx_user",\n			})\n			// Simulate an error, causing the inner transaction to roll back\n			return fmt.Errorf("inner transaction deliberately failed")\n		})\n\n		// Inner transaction failure does not affect the outer transaction\n		fmt.Println("Inner transaction error:", err)\n\n		// Continue inserting data in the outer transaction\n		_, err = tx.Insert("user", g.Map{\n			"id":       3,\n			"username": "outer_after_error",\n		})\n		// Outer transaction commits normally\n		return nil\n	})\n\n	if err != nil {\n		fmt.Println("Transaction execution failed:", err)\n		return\n	}\n\n	// Query results\n	result, err := db.Model("user").All()\n	if err != nil {\n		fmt.Println("Query failed:", err)\n		return\n	}\n\n	fmt.Println("Query results:", result)\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"The SQL statements executed by the above code are similar to:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-sql",children:"-- Start outer transaction\nBEGIN;\n-- Insert outer data\nINSERT INTO user(id,username) VALUES(1,'outer_user');\n\n-- Start a new independent transaction\nBEGIN;\n-- Insert inner data (using new transaction)\nINSERT INTO user(id,username) VALUES(2,'new_tx_user');\n-- Inner transaction rolls back\nROLLBACK;\n\n-- Continue outer transaction\nINSERT INTO user(id,username) VALUES(3,'outer_after_error');\n-- Commit outer transaction\nCOMMIT;\n"})}),"\n",(0,a.jsx)(e.h3,{id:"propagationsupports-support-current-transaction",children:"PropagationSupports (Support Current Transaction)"}),"\n",(0,a.jsx)(e.p,{children:"If a transaction exists, joins that transaction; if no transaction exists, executes without a transaction."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n	_ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n\n	"context"\n	"fmt"\n\n	"github.com/gogf/gf/v2/database/gdb"\n	"github.com/gogf/gf/v2/frame/g"\n)\n\nfunc main() {\n	var (\n		ctx = context.Background()\n		db  = g.DB()\n	)\n	db.SetDebug(true)\n\n	// Scenario 1: When an external transaction exists, join the external transaction\n	err := db.Transaction(ctx, func(ctx context.Context, tx gdb.TX) error {\n		// Insert data in the outer transaction\n		_, err := tx.Insert("user", g.Map{\n			"id":       1,\n			"username": "outer_user",\n		})\n		if err != nil {\n			return err\n		}\n\n		// Nested transaction - using PropagationSupports\n		err = tx.TransactionWithOptions(ctx, gdb.TxOptions{\n			Propagation: gdb.PropagationSupports,\n		}, func(ctx context.Context, tx2 gdb.TX) error {\n			// Insert data in a way that supports the current transaction (using outer transaction)\n			_, err = tx2.Insert("user", g.Map{\n				"id":       2,\n				"username": "supports_user",\n			})\n			return err\n		})\n\n		return err\n	})\n	if err != nil {\n		fmt.Println("Scenario 1 execution failed:", err)\n		return\n	}\n\n	// Query results\n	result, err := db.Model("user").All()\n	if err != nil {\n		fmt.Println("Query failed:", err)\n		return\n	}\n\n	fmt.Println("Scenario 1 query results:", result)\n\n	// Clear data table\n	_, err = db.Exec(ctx, `TRUNCATE TABLE user`)\n	if err != nil {\n		fmt.Println("Execution failed:", err)\n		return\n	}\n\n	// Scenario 2: When no external transaction exists, execute without a transaction\n	err = db.TransactionWithOptions(ctx, gdb.TxOptions{\n		Propagation: gdb.PropagationSupports,\n	}, func(ctx context.Context, tx gdb.TX) error {\n		// Insert data without a transaction\n		_, err = tx.Insert("user", g.Map{\n			"id":       3,\n			"username": "non_tx_user",\n		})\n		return err\n	})\n	if err != nil {\n		fmt.Println("Scenario 2 execution failed:", err)\n		return\n	}\n\n	// Query results\n	result, err = db.Model("user").All()\n	if err != nil {\n		fmt.Println("Query failed:", err)\n		return\n	}\n\n	fmt.Println("Scenario 2 query results:", result)\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"The SQL statements executed by the above code are similar to:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-sql",children:"-- Scenario 1: With external transaction\n-- Start outer transaction\nBEGIN;\n-- Insert outer data\nINSERT INTO user(id,username) VALUES(1,'outer_user');\n-- Insert inner data (using outer transaction)\nINSERT INTO user(id,username) VALUES(2,'supports_user');\n-- Commit transaction\nCOMMIT;\n\n-- Scenario 2: Without external transaction\n-- Insert data directly without a transaction\nINSERT INTO user(id,username) VALUES(3,'non_tx_user');\n"})}),"\n",(0,a.jsx)(e.h3,{id:"propagationmandatory-force-transaction-use",children:"PropagationMandatory (Force Transaction Use)"}),"\n",(0,a.jsx)(e.p,{children:"If a transaction exists, joins that transaction; if no transaction exists, throws an exception."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n    _ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n\n    "context"\n    "fmt"\n\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/frame/g"\n)\n\nfunc main() {\n    var (\n        ctx = context.Background()\n        db  = g.DB()\n    )\n    db.SetDebug(true)\n\n    // Scenario 1: When an external transaction exists, join the external transaction\n    err := db.Transaction(ctx, func(ctx context.Context, tx gdb.TX) error {\n        // Insert data in the outer transaction\n        _, err := tx.Insert("user", g.Map{\n            "id":       1,\n            "username": "outer_user",\n        })\n        if err != nil {\n            return err\n        }\n\n        // Nested transaction - using PropagationMandatory\n        err = tx.TransactionWithOptions(ctx, gdb.TxOptions{\n            Propagation: gdb.PropagationMandatory,\n        }, func(ctx context.Context, tx2 gdb.TX) error {\n            // Insert data in a way that mandates using the current transaction (using outer transaction)\n            _, err = tx2.Insert("user", g.Map{\n                "id":       2,\n                "username": "mandatory_user",\n            })\n            return err\n        })\n\n        return err\n    })\n\n    if err != nil {\n        fmt.Println("Scenario 1 execution failed:", err)\n        return\n    }\n\n    // Query results\n    result, err := db.Model("user").All()\n    if err != nil {\n        fmt.Println("Query failed:", err)\n        return\n    }\n\n    fmt.Println("Scenario 1 query results:", result)\n\n    // Clear data table\n    _, err = db.Exec(ctx, `TRUNCATE TABLE user`)\n    if err != nil {\n        fmt.Println("Execution failed:", err)\n        return\n    }\n\n    // Scenario 2: When no external transaction exists, an exception will be thrown\n    fmt.Println("Scenario 2: Using PropagationMandatory without an external transaction")\n    err = db.TransactionWithOptions(ctx, gdb.TxOptions{\n        Propagation: gdb.PropagationMandatory,\n    }, func(ctx context.Context, tx gdb.TX) error {\n        // This code will not execute because an exception will be thrown when there is no external transaction\n        _, err = tx.Insert("user", g.Map{\n            "id":       3,\n            "username": "will_not_insert",\n        })\n        return err\n    })\n\n    // Should have an error because there is no external transaction\n    fmt.Println("Scenario 2 error:", err)\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"The SQL statements executed by the above code are similar to:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-sql",children:"-- Scenario 1: With external transaction\n-- Start outer transaction\nBEGIN;\n-- Insert outer data\nINSERT INTO user(id,username) VALUES(1,'outer_user');\n-- Insert inner data (using outer transaction)\nINSERT INTO user(id,username) VALUES(2,'mandatory_user');\n-- Commit transaction\nCOMMIT;\n\n-- Scenario 2: Without external transaction\n-- Throw exception: \"mandatory transaction is required, but none exists\"\n"})}),"\n",(0,a.jsx)(e.h3,{id:"propagationnever-disallow-execution-in-transaction",children:"PropagationNever (Disallow Execution in Transaction)"}),"\n",(0,a.jsx)(e.p,{children:"Executes without a transaction; if a transaction exists, throws an exception."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n	_ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n\n	"context"\n	"fmt"\n\n	"github.com/gogf/gf/v2/database/gdb"\n	"github.com/gogf/gf/v2/frame/g"\n)\n\nfunc main() {\n	var (\n		ctx = context.Background()\n		db  = g.DB()\n	)\n	db.SetDebug(true)\n\n	// Scenario 1: When an external transaction exists, an exception will be thrown\n	fmt.Println("Scenario 1: Using PropagationNever with an external transaction")\n	err := db.Transaction(ctx, func(ctx context.Context, tx gdb.TX) error {\n		// Insert data in the outer transaction\n		_, err := tx.Insert("user", g.Map{\n			"id":       1,\n			"username": "outer_user",\n		})\n		if err != nil {\n			return err\n		}\n\n		// Nested transaction - using PropagationNever\n		err = tx.TransactionWithOptions(ctx, gdb.TxOptions{\n			Propagation: gdb.PropagationNever,\n		}, func(ctx context.Context, tx2 gdb.TX) error {\n			// This code will not execute because an exception will be thrown when using PropagationNever in an external transaction\n			_, err := tx2.Insert("user", g.Map{\n				"id":       2,\n				"username": "will_not_insert",\n			})\n			return err\n		})\n\n		// Should have an error\n		fmt.Println("Nested transaction error:", err)\n\n		// Continue outer transaction\n		return nil\n	})\n	if err != nil {\n		fmt.Println("Scenario 1 execution failed:", err)\n		return\n	}\n\n	// Query results\n	result, err := db.Model("user").All()\n	if err != nil {\n		fmt.Println("Query failed:", err)\n		return\n	}\n	// Should only have record with id=1\n	fmt.Println("Scenario 1 query results:", result)\n\n	// Clear data table\n	_, err = db.Exec(ctx, `TRUNCATE TABLE user`)\n	if err != nil {\n		fmt.Println("Execution failed:", err)\n		return\n	}\n\n	// Scenario 2: When no external transaction exists, execute without a transaction\n	err = db.TransactionWithOptions(ctx, gdb.TxOptions{\n		Propagation: gdb.PropagationNever,\n	}, func(ctx context.Context, tx gdb.TX) error {\n		// Insert data without a transaction\n		_, err = tx.Insert("user", g.Map{\n			"id":       3,\n			"username": "non_tx_user",\n		})\n		return err\n	})\n	if err != nil {\n		fmt.Println("Scenario 2 execution failed:", err)\n		return\n	}\n\n	// Query results\n	result, err = db.Model("user").All()\n	if err != nil {\n		fmt.Println("Query failed:", err)\n		return\n	}\n	// Should have record with id=3\n	fmt.Println("Scenario 2 query results:", result)\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"The SQL statements executed by the above code are similar to:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-sql",children:"-- Scenario 1: With external transaction\n-- Start outer transaction\nBEGIN;\n-- Insert outer data\nINSERT INTO user(id,username) VALUES(1,'outer_user');\n-- Throw exception: \"transaction is existing, but never transaction is required\"\n-- Commit outer transaction\nCOMMIT;\n\n-- Scenario 2: Without external transaction\n-- Insert data directly without a transaction\nINSERT INTO user(id,username) VALUES(3,'non_tx_user');\n"})}),"\n",(0,a.jsx)(e.h3,{id:"propagationnotsupported-execute-without-transaction",children:"PropagationNotSupported (Execute Without Transaction)"}),"\n",(0,a.jsx)(e.p,{children:"Executes without a transaction; if a transaction exists, suspends the current transaction."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n	_ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n\n	"context"\n	"fmt"\n\n	"github.com/gogf/gf/v2/database/gdb"\n	"github.com/gogf/gf/v2/frame/g"\n)\n\nfunc main() {\n	var (\n		ctx = context.Background()\n		db  = g.DB()\n	)\n	db.SetDebug(true)\n\n	// Execute transaction\n	err := db.Transaction(ctx, func(ctx context.Context, tx gdb.TX) error {\n		// Insert data in transaction\n		_, err := tx.Insert("user", g.Map{\n			"id":       1,\n			"username": "tx_user",\n		})\n		if err != nil {\n			return err\n		}\n\n		// Use PropagationNotSupported to suspend current transaction\n		err = tx.TransactionWithOptions(ctx, gdb.TxOptions{\n			Propagation: gdb.PropagationNotSupported,\n		}, func(ctx context.Context, tx2 gdb.TX) error {\n			// Write data without a transaction\n			_, err = tx2.Insert("user", g.Map{\n				"id":       2,\n				"username": "non_tx_user",\n			})\n			return err\n		})\n		if err != nil {\n			return err\n		}\n\n		// Simulate an error, causing the outer transaction to roll back\n		return fmt.Errorf("outer transaction deliberately failed")\n	})\n\n	fmt.Println("Transaction execution result:", err)\n\n	// Query results\n	result, err := db.Model("user").All()\n	if err != nil {\n		fmt.Println("Query failed:", err)\n		return\n	}\n\n	// Should only see record with id=2, because record with id=1 was canceled when the transaction rolled back\n	fmt.Println("Query results:", result)\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"The SQL statements executed by the above code are similar to:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-sql",children:"-- Start transaction\nBEGIN;\n-- Insert transaction data\nINSERT INTO user(id,username) VALUES(1,'tx_user');\n\n-- Execute without transaction (commit directly)\nINSERT INTO user(id,username) VALUES(2,'non_tx_user');\n\n-- Outer transaction rolls back\nROLLBACK;\n"})}),"\n",(0,a.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsxs)(e.p,{children:["The transaction propagation feature of ",(0,a.jsx)(e.code,{children:"GoFrame ORM"})," provides developers with a flexible transaction management mechanism that can meet transaction processing requirements in complex business scenarios. By choosing appropriate transaction propagation behaviors, more granular transaction control can be achieved, improving system reliability and performance."]}),"\n",(0,a.jsx)(e.p,{children:"In practical applications, it is recommended to choose appropriate propagation behaviors based on business characteristics:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["For most scenarios, the default ",(0,a.jsx)(e.code,{children:"PropagationRequired"})," is sufficient."]}),"\n",(0,a.jsxs)(e.li,{children:["When independent transactions are needed to isolate error impacts, ",(0,a.jsx)(e.code,{children:"PropagationRequiresNew"})," can be used."]}),"\n",(0,a.jsxs)(e.li,{children:["For scenarios requiring savepoint functionality, ",(0,a.jsx)(e.code,{children:"PropagationNested"})," can be used."]}),"\n",(0,a.jsxs)(e.li,{children:["When certain operations do not need transaction protection, ",(0,a.jsx)(e.code,{children:"PropagationNotSupported"})," can be used."]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"By properly using the transaction propagation mechanism, more robust and maintainable applications can be built."})]})}function l(n={}){let{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},250065:function(n,e,t){t.d(e,{Z:function(){return s},a:function(){return o}});var r=t(667294);let a={},i=r.createContext(a);function o(n){let e=r.useContext(i);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);