"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["76011"],{220656:function(n,e,t){t.r(e),t.d(e,{metadata:()=>r,contentTitle:()=>s,default:()=>u,assets:()=>l,toc:()=>c,frontMatter:()=>o});var r=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u4E8B\u52A1\u5904\u7406/ORM\u4E8B\u52A1\u5904\u7406-\u53EA\u8BFB\u6A21\u5F0F","title":"ORM Transactions - Read-Only Mode","description":"A comprehensive guide to GoFrame ORM transaction read-only mode, including basic concepts, advantages, application scenarios, and code examples to help developers improve database operation safety and performance.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u4E8B\u52A1\u5904\u7406/ORM\u4E8B\u52A1\u5904\u7406-\u53EA\u8BFB\u6A21\u5F0F.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u4E8B\u52A1\u5904\u7406","slug":"/docs/core/gdb-transaction-readonly","permalink":"/en/docs/core/gdb-transaction-readonly","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u4E8B\u52A1\u5904\u7406/ORM\u4E8B\u52A1\u5904\u7406-\u53EA\u8BFB\u6A21\u5F0F.md","tags":[],"version":"current","lastUpdatedBy":"John Guo","lastUpdatedAt":1742194305000,"sidebarPosition":6000,"frontMatter":{"slug":"/docs/core/gdb-transaction-readonly","title":"ORM Transactions - Read-Only Mode","sidebar_position":6000,"hide_title":true,"keywords":["Transaction","Read-Only Mode","ReadOnly","ORM","Database","Transaction Safety","Data Consistency"],"description":"A comprehensive guide to GoFrame ORM transaction read-only mode, including basic concepts, advantages, application scenarios, and code examples to help developers improve database operation safety and performance."},"sidebar":"mainSidebar","previous":{"title":"ORM Transactions - Isolation Levels","permalink":"/en/docs/core/gdb-transaction-isolation-level"},"next":{"title":"ORM - Result Handling","permalink":"/en/docs/core/gdb-result"}}'),a=t("785893"),i=t("250065");let o={slug:"/docs/core/gdb-transaction-readonly",title:"ORM Transactions - Read-Only Mode",sidebar_position:6e3,hide_title:!0,keywords:["Transaction","Read-Only Mode","ReadOnly","ORM","Database","Transaction Safety","Data Consistency"],description:"A comprehensive guide to GoFrame ORM transaction read-only mode, including basic concepts, advantages, application scenarios, and code examples to help developers improve database operation safety and performance."},s=void 0,l={},c=[{value:"Basic Introduction",id:"basic-introduction",level:2},{value:"Advantages of Read-Only Mode",id:"advantages-of-read-only-mode",level:2},{value:"Application Scenarios",id:"application-scenarios",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Using <code>BeginWithOptions</code>",id:"using-beginwithoptions",level:3},{value:"Using <code>TransactionWithOptions</code>",id:"using-transactionwithoptions",level:3},{value:"Read-Only Transactions in MySQL",id:"read-only-transactions-in-mysql",level:2},{value:"Important Considerations",id:"important-considerations",level:2},{value:"Practical Application Examples",id:"practical-application-examples",level:2},{value:"Report Generation",id:"report-generation",level:3},{value:"Data Export",id:"data-export",level:3},{value:"Complex Data Analysis",id:"complex-data-analysis",level:3},{value:"Combining with Other Transaction Features",id:"combining-with-other-transaction-features",level:2},{value:"Combining with Isolation Levels",id:"combining-with-isolation-levels",level:3},{value:"Combining with Transaction Propagation",id:"combining-with-transaction-propagation",level:3},{value:"Alternative Approaches",id:"alternative-approaches",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(n){let e={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{id:"basic-introduction",children:"Basic Introduction"}),"\n",(0,a.jsxs)(e.p,{children:["Transaction read-only mode (",(0,a.jsx)(e.code,{children:"ReadOnly"}),") is a transaction processing feature provided by ",(0,a.jsx)(e.code,{children:"GoFrame ORM"})," that allows developers to mark a transaction as read-only. In a read-only transaction, the database prohibits any modification operations (such as ",(0,a.jsx)(e.code,{children:"INSERT"}),", ",(0,a.jsx)(e.code,{children:"UPDATE"}),", ",(0,a.jsx)(e.code,{children:"DELETE"}),", etc.) and only allows query operations. ",(0,a.jsx)(e.code,{children:"GoFrame ORM"})," supports this feature through the ",(0,a.jsx)(e.code,{children:"ReadOnly"})," field in the ",(0,a.jsx)(e.code,{children:"TxOptions"})," struct."]}),"\n",(0,a.jsx)(e.h2,{id:"advantages-of-read-only-mode",children:"Advantages of Read-Only Mode"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Enhanced Security"}),": Prevents accidental data modification operations, ensuring that only read operations can be performed within the transaction"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Optimized Performance"}),": Databases can apply specific optimizations for read-only transactions, such as avoiding write locks and reducing lock contention"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Reduced Resource Consumption"}),": Read-only transactions typically consume fewer database resources, especially in high-concurrency scenarios"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Increased Concurrency"}),": Multiple read-only transactions can execute in parallel without blocking each other"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Support for Load Balancing"}),": Read-only transactions can be routed to read-only replicas, reducing the load on the primary database"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"application-scenarios",children:"Application Scenarios"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Report Generation"}),": When generating complex reports that require querying large amounts of data but don't need to modify data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Data Export Functions"}),": Ensuring data consistency during exports while preventing accidental modifications"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Complex Data Queries"}),": Executing multiple related queries within a transaction to ensure data consistency"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Read-Only API Endpoints"}),": Providing transactional guarantees for API endpoints that only serve data queries"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Data Analysis Operations"}),": Ensuring that data won't be modified when executing complex data analysis queries"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Audit and Log Queries"}),": Preventing accidental modifications when viewing historical records and audit logs"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"GoFrame ORM"})," provides simple and easy-to-use APIs to create read-only transactions by using the ",(0,a.jsx)(e.code,{children:"BeginWithOptions"})," or ",(0,a.jsx)(e.code,{children:"TransactionWithOptions"})," methods and setting ",(0,a.jsx)(e.code,{children:"ReadOnly: true"})," to enable read-only mode."]}),"\n",(0,a.jsxs)(e.h3,{id:"using-beginwithoptions",children:["Using ",(0,a.jsx)(e.code,{children:"BeginWithOptions"})]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'// Start a read-only transaction\ntx, err := db.BeginWithOptions(ctx, gdb.TxOptions{\n    ReadOnly: true,\n})\n// SQL: BEGIN\n\nif err != nil {\n    // Handle error\n    return\n}\n\n// Ensure the transaction will eventually be committed or rolled back\ndefer func() {\n    if err := recover(); err != nil {\n        tx.Rollback()\n        panic(err)\n    }\n}()\n\n// Execute query operations\nusers, err := tx.Model("user").All()\n// SQL: SELECT * FROM user\n\n// Attempting to execute a modification operation will fail\n_, err = tx.Update("user", g.Map{"status": "active"}, "id=1")\n// In a read-only transaction, this will return an error\n\n// Commit the transaction\nif err = tx.Commit(); err != nil {\n    tx.Rollback()\n    return\n}\n'})}),"\n",(0,a.jsxs)(e.h3,{id:"using-transactionwithoptions",children:["Using ",(0,a.jsx)(e.code,{children:"TransactionWithOptions"})]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'// Use transaction closure function\nerr := db.TransactionWithOptions(ctx, gdb.TxOptions{\n    ReadOnly: true,\n}, func(ctx context.Context, tx gdb.TX) error {\n    // Execute query operations\n    users, err := tx.Model("user").Where("status", "active").All()\n    // SQL: SELECT * FROM user WHERE status=\'active\'\n    \n    if err != nil {\n        return err\n    }\n    \n    // Process query results\n    fmt.Println("Active users count:", len(users))\n    \n    // Attempting to execute a modification operation will fail and automatically roll back the transaction\n    _, err = tx.Model("user").Data(g.Map{"login_time": gtime.Now()}).Where("id", 1).Update()\n    // In a read-only transaction, this will return an error\n    \n    return err // Returning nil will automatically commit the transaction, returning an error will automatically roll back\n})\n'})}),"\n",(0,a.jsx)(e.h2,{id:"read-only-transactions-in-mysql",children:"Read-Only Transactions in MySQL"}),"\n",(0,a.jsxs)(e.p,{children:["In ",(0,a.jsx)(e.code,{children:"MySQL"}),", read-only transactions are implemented with the following SQL statements:"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-sql",children:"-- Start a read-only transaction\nSET TRANSACTION READ ONLY;\nSTART TRANSACTION;\n\n-- Execute query operations\nSELECT * FROM user;\n\n-- Attempting to execute a modification operation will fail\nUPDATE user SET status = 'active' WHERE id = 1;\n-- Error: ERROR 1792 (25006): Cannot execute statement in a READ ONLY transaction.\n\n-- Commit the transaction\nCOMMIT;\n"})}),"\n",(0,a.jsx)(e.h2,{id:"important-considerations",children:"Important Considerations"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Attempting to execute data modification operations in a read-only transaction will result in errors, and the transaction will be rolled back"}),"\n",(0,a.jsx)(e.li,{children:"Different databases may have varying levels of support and implementation for read-only transactions"}),"\n",(0,a.jsx)(e.li,{children:"Read-only transactions are primarily used to enhance security and performance, not as a forced access control mechanism"}),"\n",(0,a.jsx)(e.li,{children:"In high-concurrency systems, appropriate use of read-only transactions can significantly improve performance"}),"\n",(0,a.jsx)(e.li,{children:"Read-only transactions can typically be routed to read-only replicas of the database"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"practical-application-examples",children:"Practical Application Examples"}),"\n",(0,a.jsx)(e.h3,{id:"report-generation",children:"Report Generation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'// Use a read-only transaction to generate sales reports\nerr := db.TransactionWithOptions(ctx, gdb.TxOptions{\n    ReadOnly: true,\n}, func(ctx context.Context, tx gdb.TX) error {\n    // 1. Query total sales\n    totalSales, err := tx.Model("order").Where("status", "completed").Sum("amount")\n    // SQL: SELECT SUM(amount) FROM order WHERE status=\'completed\'\n    \n    if err != nil {\n        return err\n    }\n    \n    // 2. Query product sales information\n    productSales, err := tx.Model("order_item")\n        .Fields("product_id, SUM(quantity) as total_quantity, SUM(amount) as total_amount")\n        .Group("product_id")\n        .Order("total_amount DESC")\n        .All()\n    // SQL: SELECT product_id, SUM(quantity) as total_quantity, SUM(amount) as total_amount \n    //      FROM order_item GROUP BY product_id ORDER BY total_amount DESC\n    \n    if err != nil {\n        return err\n    }\n    \n    // 3. Query top customers\n    topCustomers, err := tx.Model("order")\n        .Fields("customer_id, COUNT(*) as order_count, SUM(amount) as total_spent")\n        .Group("customer_id")\n        .Order("total_spent DESC")\n        .Limit(10)\n        .All()\n    // SQL: SELECT customer_id, COUNT(*) as order_count, SUM(amount) as total_spent \n    //      FROM order GROUP BY customer_id ORDER BY total_spent DESC LIMIT 10\n    \n    // Report generation logic...\n    \n    return nil // Returning nil automatically commits the transaction\n})\n'})}),"\n",(0,a.jsx)(e.h3,{id:"data-export",children:"Data Export"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'// Use a read-only transaction to export user data\nerr := db.TransactionWithOptions(ctx, gdb.TxOptions{\n    ReadOnly: true,\n}, func(ctx context.Context, tx gdb.TX) error {\n    // Query basic user information\n    users, err := tx.Model("user").All()\n    // SQL: SELECT * FROM user\n    \n    if err != nil {\n        return err\n    }\n    \n    // Query detailed information for each user\n    for _, user := range users {\n        userId := user["id"]\n        \n        // Query user address\n        address, err := tx.Model("user_address").Where("user_id", userId).One()\n        // SQL: SELECT * FROM user_address WHERE user_id=?\n        \n        if err != nil {\n            return err\n        }\n        \n        // Query user orders\n        orders, err := tx.Model("order").Where("user_id", userId).All()\n        // SQL: SELECT * FROM order WHERE user_id=?\n        \n        if err != nil {\n            return err\n        }\n        \n        // Export data logic...\n    }\n    \n    return nil\n})\n'})}),"\n",(0,a.jsx)(e.h3,{id:"complex-data-analysis",children:"Complex Data Analysis"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'// Use a read-only transaction for complex data analysis\nerr := db.TransactionWithOptions(ctx, gdb.TxOptions{\n    ReadOnly: true,\n}, func(ctx context.Context, tx gdb.TX) error {\n    // 1. Query user activity data\n    userActivity, err := tx.Model("user_activity")\n        .Fields("user_id, COUNT(*) as activity_count")\n        .Where("activity_time", ">", "2023-01-01")\n        .Group("user_id")\n        .Order("activity_count DESC")\n        .All()\n    \n    if err != nil {\n        return err\n    }\n    \n    // 2. Query product popularity\n    productPopularity, err := tx.Model("product_view")\n        .Fields("product_id, COUNT(*) as view_count")\n        .Where("view_time", ">", "2023-01-01")\n        .Group("product_id")\n        .Order("view_count DESC")\n        .Limit(20)\n        .All()\n    \n    if err != nil {\n        return err\n    }\n    \n    // 3. Calculate conversion rates\n    conversionRates, err := tx.Raw(`\n        SELECT \n            p.category_id,\n            COUNT(DISTINCT pv.user_id) as viewers,\n            COUNT(DISTINCT o.user_id) as buyers,\n            COUNT(DISTINCT o.user_id) / COUNT(DISTINCT pv.user_id) * 100 as conversion_rate\n        FROM \n            product_view pv\n        JOIN \n            product p ON pv.product_id = p.id\n        LEFT JOIN \n            order_item oi ON oi.product_id = p.id\n        LEFT JOIN \n            order o ON oi.order_id = o.id\n        WHERE \n            pv.view_time > \'2023-01-01\'\n        GROUP BY \n            p.category_id\n        ORDER BY \n            conversion_rate DESC\n    `).All()\n    \n    if err != nil {\n        return err\n    }\n    \n    // Data analysis logic...\n    \n    return nil\n})\n'})}),"\n",(0,a.jsx)(e.h2,{id:"combining-with-other-transaction-features",children:"Combining with Other Transaction Features"}),"\n",(0,a.jsxs)(e.p,{children:["Read-only mode can be combined with other transaction features in ",(0,a.jsx)(e.code,{children:"GoFrame ORM"}),", such as isolation levels and transaction propagation, to achieve more precise transaction control."]}),"\n",(0,a.jsx)(e.h3,{id:"combining-with-isolation-levels",children:"Combining with Isolation Levels"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:"// Combine read-only mode with a specific isolation level\nerr := db.TransactionWithOptions(ctx, gdb.TxOptions{\n    ReadOnly: true,\n    Isolation: sql.LevelRepeatableRead,\n}, func(ctx context.Context, tx gdb.TX) error {\n    // Execute read operations with Repeatable Read isolation level\n    // This ensures consistent reads without allowing any modifications\n    \n    // ... query operations ...\n    \n    return nil\n})\n"})}),"\n",(0,a.jsx)(e.h3,{id:"combining-with-transaction-propagation",children:"Combining with Transaction Propagation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:"// Outer transaction with read-only mode\nerr := db.TransactionWithOptions(ctx, gdb.TxOptions{\n    ReadOnly: true,\n}, func(ctx context.Context, tx gdb.TX) error {\n    // Execute some read operations\n    \n    // Nested transaction with specific propagation behavior\n    // Since the outer transaction is read-only, the nested transaction will also be read-only\n    err := tx.TransactionWithOptions(ctx, gdb.TxOptions{\n        Propagation: gdb.PropagationRequired,\n    }, func(ctx context.Context, tx2 gdb.TX) error {\n        // Execute more read operations\n        \n        return nil\n    })\n    \n    return err\n})\n"})}),"\n",(0,a.jsx)(e.h2,{id:"alternative-approaches",children:"Alternative Approaches"}),"\n",(0,a.jsxs)(e.p,{children:["If you need similar functionality but don't want to use read-only transactions, ",(0,a.jsx)(e.code,{children:"GoFrame"})," provides alternative approaches:"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Manual Validation"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'// Manually check operations before executing them\nfunc ReadOnlyOperation(ctx context.Context, db gdb.DB) error {\n    return db.Transaction(ctx, func(ctx context.Context, tx gdb.TX) error {\n        // Only allow SELECT operations\n        result, err := tx.Model("user").All()\n        if err != nil {\n            return err\n        }\n        \n        // Process result...\n        \n        return nil\n    })\n}\n'})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"DryRun Feature"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:"# Enable via configuration file\ndatabase:\n  default:\n    dryrun: true\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'// The database will only print SQL without executing it\n_, err := db.Model("user").Data(g.Map{"name": "John"}).Insert()\n// This will only print the SQL without actually modifying the database\n'})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Read-Only Database Connection"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'// Configure a read-only database connection\ng.DB("readonly")\n\n// Use it for read operations\nresult, err := g.DB("readonly").Model("user").All()\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsxs)(e.p,{children:["Read-only transaction mode is a powerful feature in ",(0,a.jsx)(e.code,{children:"GoFrame ORM"})," that enhances both security and performance for read-intensive operations. By explicitly declaring a transaction as read-only, developers can prevent accidental data modifications and allow the database to optimize query execution. This feature is particularly valuable in reporting, data export, and analysis scenarios where data consistency is important but no modifications are needed."]}),"\n",(0,a.jsx)(e.p,{children:"When designing applications with complex data access patterns, consider using read-only transactions for operations that don't require data modifications to improve both safety and performance."})]})}function u(n={}){let{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},250065:function(n,e,t){t.d(e,{Z:function(){return s},a:function(){return o}});var r=t(667294);let a={},i=r.createContext(a);function o(n){let e=r.useContext(i);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);