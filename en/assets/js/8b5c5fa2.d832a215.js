"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["63302"],{626024:function(e,t,n){n.r(t),n.d(t,{metadata:()=>i,contentTitle:()=>a,default:()=>m,assets:()=>c,toc:()=>d,frontMatter:()=>s});var i=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u63A5\u53E3\u5F00\u53D1/ORM\u63A5\u53E3\u5F00\u53D1-\u56DE\u8C03\u5904\u7406","title":"ORM Interface - Callback","description":"When developing ORM interfaces using the GoFrame framework, custom callback handling is used to log or authenticate SQL statements. By implementing and overriding interface methods like DoQuery, DoExec, etc., developers can inject custom logic into the default implementation. The example demonstrates how to customize a MySQL driver to log executed SQL statements and configure gdb to use that driver.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u63A5\u53E3\u5F00\u53D1/ORM\u63A5\u53E3\u5F00\u53D1-\u56DE\u8C03\u5904\u7406.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u63A5\u53E3\u5F00\u53D1","slug":"/docs/core/gdb-interface-callback","permalink":"/en/docs/core/gdb-interface-callback","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u63A5\u53E3\u5F00\u53D1/ORM\u63A5\u53E3\u5F00\u53D1-\u56DE\u8C03\u5904\u7406.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732541616000,"sidebarPosition":0,"frontMatter":{"slug":"/docs/core/gdb-interface-callback","title":"ORM Interface - Callback","sidebar_position":0,"hide_title":true,"keywords":["GoFrame","ORM Interface","SQL Statements","Custom Callback","Logging","Authentication Operations","Database Driver","MySQL Driver","gdb Interface","Framework Override"],"description":"When developing ORM interfaces using the GoFrame framework, custom callback handling is used to log or authenticate SQL statements. By implementing and overriding interface methods like DoQuery, DoExec, etc., developers can inject custom logic into the default implementation. The example demonstrates how to customize a MySQL driver to log executed SQL statements and configure gdb to use that driver."},"sidebar":"mainSidebar","previous":{"title":"ORM - Interface","permalink":"/en/docs/core/gdb-interface"},"next":{"title":"ORM Interface - Driver","permalink":"/en/docs/core/gdb-interface-driver"}}'),r=n("785893"),o=n("250065");let s={slug:"/docs/core/gdb-interface-callback",title:"ORM Interface - Callback",sidebar_position:0,hide_title:!0,keywords:["GoFrame","ORM Interface","SQL Statements","Custom Callback","Logging","Authentication Operations","Database Driver","MySQL Driver","gdb Interface","Framework Override"],description:"When developing ORM interfaces using the GoFrame framework, custom callback handling is used to log or authenticate SQL statements. By implementing and overriding interface methods like DoQuery, DoExec, etc., developers can inject custom logic into the default implementation. The example demonstrates how to customize a MySQL driver to log executed SQL statements and configure gdb to use that driver."},a=void 0,c={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Example Usage",id:"example-usage",level:2},{value:"Notes",id:"notes",level:2}];function l(e){let t={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(t.p,{children:["Custom callback handling is the most common implementation in interface development, where it involves ",(0,r.jsx)(t.strong,{children:"replacing and modifying"})," some methods in the interface to inject custom logic into the default implementation of the driver. By referring to the interface relationship diagram (",(0,r.jsx)(t.a,{href:"/en/docs/core/gdb-interface",children:"ORM - Interface"}),"), we understand that all ",(0,r.jsx)(t.code,{children:"SQL"})," statement executions will pass through the ",(0,r.jsx)(t.code,{children:"DoQuery"}),", ",(0,r.jsx)(t.code,{children:"DoExec"}),", or ",(0,r.jsx)(t.code,{children:"DoFilter"})," interfaces. Depending on the requirements, you can ",(0,r.jsx)(t.strong,{children:"implement and override"})," the relevant interface methods in the custom driver to achieve the desired functionality."]}),"\n",(0,r.jsxs)(t.p,{children:["A common use case is to perform ",(0,r.jsx)(t.strong,{children:"log recording or unified security checks"})," on ",(0,r.jsx)(t.code,{children:"SQL"})," at the ",(0,r.jsx)(t.code,{children:"ORM"})," lower layer."]}),"\n",(0,r.jsx)(t.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsxs)(t.p,{children:["Let's look at an example of custom callback handling. Suppose we need to log all executed ",(0,r.jsx)(t.code,{children:"SQL"})," statements into a ",(0,r.jsx)(t.code,{children:"monitor"})," table for ",(0,r.jsx)(t.code,{children:"SQL"})," auditing purposes. The easiest way to achieve this is by creating a custom ",(0,r.jsx)(t.code,{children:"Driver"})," and then overriding the underlying interface methods of ",(0,r.jsx)(t.code,{children:"ORM"}),". To simplify the example, the following code demonstrates a custom ",(0,r.jsx)(t.code,{children:"MySQL"})," driver, which inherits from the ",(0,r.jsx)(t.code,{children:"mysql"})," module's ",(0,r.jsx)(t.code,{children:"Driver"})," under ",(0,r.jsx)(t.code,{children:"drivers"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'package driver\n\nimport (\n    "context"\n\n    "github.com/gogf/gf/contrib/drivers/mysql/v2"\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/os/gtime"\n)\n\n// MyDriver is a custom database driver, which is used for testing only.\n// For simplifying the unit testing case purpose, MyDriver struct inherits the mysql driver\n// gdb.Driver and overwrites its functions DoQuery and DoExec.\n// So if there\'s any sql execution, it goes through MyDriver.DoQuery/MyDriver.DoExec firstly\n// and then gdb.Driver.DoQuery/gdb.Driver.DoExec.\n// You can call it sql "HOOK" or "HiJack" as your will.\ntype MyDriver struct {\n    *mysql.Driver\n}\n\nvar (\n    // customDriverName is my driver name, which is used for registering.\n    customDriverName = "MyDriver"\n)\n\nfunc init() {\n    // It here registers my custom driver in package initialization function "init".\n    // You can later use this type in the database configuration.\n    if err := gdb.Register(customDriverName, &MyDriver{}); err != nil {\n        panic(err)\n    }\n}\n\n// New creates and returns a database object for mysql.\n// It implements the interface of gdb.Driver for extra database driver installation.\nfunc (d *MyDriver) New(core *gdb.Core, node *gdb.ConfigNode) (gdb.DB, error) {\n    return &MyDriver{\n        &mysql.Driver{\n            Core: core,\n        },\n    }, nil\n}\n\n// DoCommit commits current sql and arguments to underlying sql driver.\nfunc (d *MyDriver) DoCommit(ctx context.Context, in gdb.DoCommitInput) (out gdb.DoCommitOutput, err error) {\n    tsMilliStart := gtime.TimestampMilli()\n    out, err = d.Core.DoCommit(ctx, in)\n    tsMilliFinished := gtime.TimestampMilli()\n    _, _ = in.Link.ExecContext(ctx,\n        "INSERT INTO `monitor`(`sql`,`cost`,`time`,`error`) VALUES(?,?,?,?)",\n        gdb.FormatSqlWithArgs(in.Sql, in.Args),\n        tsMilliFinished-tsMilliStart,\n        gtime.Now(),\n        err,\n    )\n    return\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["We see that a custom driver is registered with a unique name in the package initialization function ",(0,r.jsx)(t.code,{children:"init"})," using ",(0,r.jsx)(t.code,{children:'gdb.Register("MyDriver", &MyDriver{})'}),". We can also override the existing framework ",(0,r.jsx)(t.code,{children:"mysql"})," driver with our own driver using ",(0,r.jsx)(t.code,{children:'gdb.Register("mysql", &MyDriver{})'}),"."]}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["The driver name ",(0,r.jsx)(t.code,{children:"mysql"})," is the default name for the framework's ",(0,r.jsx)(t.code,{children:"DriverMysql"}),"."]})}),"\n",(0,r.jsxs)(t.p,{children:["Since we are using a new driver name ",(0,r.jsx)(t.code,{children:"MyDriver"}),", it is necessary to specify this driver name in the ",(0,r.jsx)(t.code,{children:"type"})," field in the ",(0,r.jsx)(t.code,{children:"gdb"})," configuration. Below is an example configuration:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",children:'database:\n  default:\n  - link: "MyDriver:root:12345678@tcp(127.0.0.1:3306)/user"\n'})}),"\n",(0,r.jsx)(t.h2,{id:"notes",children:"Notes"}),"\n",(0,r.jsxs)(t.p,{children:["In the implementation of interface methods, use the ",(0,r.jsx)(t.code,{children:"Link"})," input object parameter to operate on the database. Using the ",(0,r.jsx)(t.code,{children:"g.DB"})," method to get a database object for operations may lead to deadlock issues."]})]})}function m(e={}){let{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},250065:function(e,t,n){n.d(t,{Z:function(){return a},a:function(){return s}});var i=n(667294);let r={},o=i.createContext(r);function s(e){let t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);