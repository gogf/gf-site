"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["29085"],{809246(e,n,r){r.r(n),r.d(n,{metadata:()=>o,default:()=>v,frontMatter:()=>s,contentTitle:()=>c,toc:()=>l,assets:()=>a});var o=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-Converter","title":"Type Conversion - Converter","description":"Implement rigorous type conversion using the gconv.Converter interface in the GoFrame framework, supporting error handling, custom conversion rules, and type registration. Compared to traditional gconv package methods, Converter provides stricter type checking and error handling mechanisms, suitable for scenarios with high data accuracy requirements.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-Converter.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362","slug":"/docs/core/gconv-converter","permalink":"/en/docs/core/gconv-converter","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-Converter.md","tags":[],"version":"current","lastUpdatedBy":"John Guo","lastUpdatedAt":1742194305000,"sidebarPosition":6000,"frontMatter":{"slug":"/docs/core/gconv-converter","title":"Type Conversion - Converter","sidebar_position":6000,"hide_title":true,"keywords":["GoFrame","GoFrame framework","Type Conversion","Converter","Conversion Object","Strict Conversion","Error Handling","Custom Conversion","Type Conversion Interface"],"description":"Implement rigorous type conversion using the gconv.Converter interface in the GoFrame framework, supporting error handling, custom conversion rules, and type registration. Compared to traditional gconv package methods, Converter provides stricter type checking and error handling mechanisms, suitable for scenarios with high data accuracy requirements."},"sidebar":"mainSidebar","previous":{"title":"Type Conversion - Performance","permalink":"/en/docs/core/gconv-benchmark"},"next":{"title":"Type Conversion - Custom Type Conversion","permalink":"/en/docs/core/gconv-register-converter-func"}}'),t=r(474848),i=r(28453);let s={slug:"/docs/core/gconv-converter",title:"Type Conversion - Converter",sidebar_position:6e3,hide_title:!0,keywords:["GoFrame","GoFrame framework","Type Conversion","Converter","Conversion Object","Strict Conversion","Error Handling","Custom Conversion","Type Conversion Interface"],description:"Implement rigorous type conversion using the gconv.Converter interface in the GoFrame framework, supporting error handling, custom conversion rules, and type registration. Compared to traditional gconv package methods, Converter provides stricter type checking and error handling mechanisms, suitable for scenarios with high data accuracy requirements."},c,a={},l=[{value:"Basic Introduction",id:"basic-introduction",level:2},{value:"Creating a Converter Object",id:"creating-a-converter-object",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Basic Type Conversion",id:"basic-type-conversion",level:3},{value:"Struct Conversion",id:"struct-conversion",level:3},{value:"Custom Type Conversion",id:"custom-type-conversion",level:3},{value:"Differences from Traditional <code>gconv</code> Package Methods",id:"differences-from-traditional-gconv-package-methods",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Conversion Options",id:"conversion-options",level:3}];function d(e){let n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"gconv.Converter"})," is a type conversion interface newly added in ",(0,t.jsx)(n.code,{children:"GoFrame v2.9"}),", which provides type conversion capabilities through the creation of conversion objects, offering a more rigorous and flexible type conversion mechanism. Unlike traditional ",(0,t.jsx)(n.code,{children:"gconv"})," package methods, the ",(0,t.jsx)(n.code,{children:"Converter"})," interface returns an error when conversion fails, rather than defaulting to zero or empty values."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Features"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rigorous Error Handling"}),": Returns error information when conversion fails, avoiding potential issues caused by silent failures"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type Safety"}),": Provides stricter type checking, reducing runtime errors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extensibility"}),": Supports registering custom type conversion functions, adapting to complex business scenarios"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consistent API"}),": All conversion methods follow the same pattern, making usage more consistent"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Independent Instances"}),": Multiple converter instances can be created, each with different configurations and registered conversion functions"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"basic-introduction",children:"Basic Introduction"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Converter"})," interface is a composite interface that includes multiple sub-interfaces, providing comprehensive type conversion capabilities:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type Converter interface {\n	ConverterForConvert\n	ConverterForRegister\n	ConverterForInt\n	ConverterForUint\n	ConverterForTime\n	ConverterForFloat\n	ConverterForMap\n	ConverterForSlice\n	ConverterForStruct\n	ConverterForBasic\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"These sub-interfaces provide different types of conversion functions, for example:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConverterForBasic"}),": Basic type conversion (string, boolean, etc.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConverterForInt"}),": Integer type conversion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConverterForUint"}),": Unsigned integer type conversion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConverterForFloat"}),": Floating-point type conversion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConverterForTime"}),": Time type conversion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConverterForMap"}),": Map type conversion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConverterForSlice"}),": Slice type conversion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConverterForStruct"}),": Struct type conversion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConverterForConvert"}),": Custom type conversion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConverterForRegister"}),": Register custom conversion functions"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"creating-a-converter-object",children:"Creating a Converter Object"}),"\n",(0,t.jsxs)(n.p,{children:["Use the ",(0,t.jsx)(n.code,{children:"gconv.NewConverter()"})," function to create a new ",(0,t.jsx)(n.code,{children:"Converter"})," object:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"converter := gconv.NewConverter()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsx)(n.h3,{id:"basic-type-conversion",children:"Basic Type Conversion"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n	"fmt"\n\n	"github.com/gogf/gf/v2/util/gconv"\n)\n\nfunc main() {\n	// Create a converter object\n	converter := gconv.NewConverter()\n\n	// Integer conversion\n	intValue, err := converter.Int("123")\n	if err != nil {\n		fmt.Println("Conversion failed:", err)\n	} else {\n		fmt.Println("Int conversion result:", intValue) // Output: 123\n	}\n\n	// Floating-point conversion\n	floatValue, err := converter.Float64("123.456")\n	if err != nil {\n		fmt.Println("Conversion failed:", err)\n	} else {\n		fmt.Println("Float64 conversion result:", floatValue) // Output: 123.456\n	}\n\n	// Boolean conversion\n	boolValue, err := converter.Bool("true")\n	if err != nil {\n		fmt.Println("Conversion failed:", err)\n	} else {\n		fmt.Println("Bool conversion result:", boolValue) // Output: true\n	}\n\n	// String conversion\n	strValue, err := converter.String(123)\n	if err != nil {\n		fmt.Println("Conversion failed:", err)\n	} else {\n		fmt.Println("String conversion result:", strValue) // Output: 123\n	}\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"struct-conversion",children:"Struct Conversion"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n	"fmt"\n    \n	"github.com/gogf/gf/v2/util/gconv"\n)\n\ntype User struct {\n	Id   int\n	Name string\n	Age  int\n}\n\nfunc main() {\n	converter := gconv.NewConverter()\n\n	// Map to struct conversion\n	data := map[string]interface{}{\n		"id":   1,\n		"name": "John",\n		"age":  30,\n	}\n\n	var user User\n	err := converter.Struct(data, &user, gconv.StructOption{})\n	if err != nil {\n		fmt.Println("Conversion failed:", err)\n	} else {\n		fmt.Printf("Struct conversion result: %+v\\n", user) // Output: {Id:1 Name:John Age:30}\n	}\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"custom-type-conversion",children:"Custom Type Conversion"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": Custom type conversion is primarily used for conversion between complex types (such as structs, slices, maps, etc.), and does not support alias types of basic types. This is to improve conversion efficiency and avoid unnecessary performance overhead."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here is an example of custom conversion using complex types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n	"fmt"\n	"time"\n\n	"github.com/gogf/gf/v2/util/gconv"\n)\n\n// UserInfo custom type\ntype UserInfo struct {\n	ID       int\n	Name     string\n	Birthday time.Time\n}\n\ntype UserDTO struct {\n	UserID   string\n	UserName string\n	Age      int\n}\n\nfunc userInfoT2UserDTO(in UserInfo) (*UserDTO, error) {\n	if in.ID <= 0 {\n		return nil, fmt.Errorf("invalid user ID: %d", in.ID)\n	}\n	// Calculate age\n	age := time.Now().Year() - in.Birthday.Year()\n	return &UserDTO{\n		UserID:   fmt.Sprintf("U%d", in.ID),\n		UserName: in.Name,\n		Age:      age,\n	}, nil\n}\n\nfunc main() {\n	converter := gconv.NewConverter()\n	// Register custom type conversion function - from UserInfo to UserDTO\n	err := converter.RegisterTypeConverterFunc(userInfoT2UserDTO)\n	if err != nil {\n		fmt.Println("Failed to register conversion function:", err)\n		return\n	}\n\n	// Use custom type conversion\n	userInfo := UserInfo{\n		ID:       101,\n		Name:     "Zhang San",\n		Birthday: time.Date(1990, 5, 15, 0, 0, 0, 0, time.Local),\n	}\n\n	var userDTO UserDTO\n	err = converter.Scan(userInfo, &userDTO)\n	if err != nil {\n		fmt.Println("Conversion failed:", err)\n	} else {\n		fmt.Printf("Custom type conversion result: %#v\\n", userDTO)\n		// Output similar to: Custom type conversion result: main.UserDTO{UserID:"U101", UserName:"Zhang San", Age:35}\n	}\n\n	// Test error handling\n	invalidUser := UserInfo{ID: -1, Name: "Invalid User"}\n	err = converter.Scan(invalidUser, &userDTO)\n	if err != nil {\n		fmt.Println("Expected error:", err) // Output error message: invalid user ID: -1\n	}\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the example above, we defined two complex types: ",(0,t.jsx)(n.code,{children:"UserInfo"})," (source type) and ",(0,t.jsx)(n.code,{children:"UserDTO"})," (target type), and registered a custom conversion function to convert ",(0,t.jsx)(n.code,{children:"UserInfo"})," to ",(0,t.jsx)(n.code,{children:"UserDTO"}),". This conversion is not just simple field mapping but also includes business logic (such as calculating age)."]}),"\n",(0,t.jsxs)(n.p,{children:["For more information about custom type conversion, please refer to the chapter: ",(0,t.jsx)(n.a,{href:"/en/docs/core/gconv-register-converter-func",children:"Type Conversion-Custom Type Conversion"})]}),"\n",(0,t.jsxs)(n.h2,{id:"differences-from-traditional-gconv-package-methods",children:["Differences from Traditional ",(0,t.jsx)(n.code,{children:"gconv"})," Package Methods"]}),"\n",(0,t.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsxs)(n.p,{children:["Traditional ",(0,t.jsx)(n.code,{children:"gconv"})," package methods default to returning zero or empty values when conversion fails, without returning error information:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Traditional method\nvalue := gconv.Int("not-a-number") // Returns 0, no error\n\n// Converter method\nconverter := gconv.NewConverter()\nvalue, err := converter.Int("not-a-number") // Returns 0 and error information\n'})}),"\n",(0,t.jsx)(n.h3,{id:"conversion-options",children:"Conversion Options"}),"\n",(0,t.jsxs)(n.p,{children:["The methods of the ",(0,t.jsx)(n.code,{children:"Converter"})," interface support more conversion option parameters, allowing for more fine-grained control of conversion behavior:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Struct conversion options\nstructOption := gconv.StructOption{\n    Mapping:           map[string]string{"ID": "UserId"},\n    RecursiveOption:   gconv.RecursiveOptionTrue,\n    ContinueOnError:   false,\n    PrivateAttribute:  true,\n}\n\n// Use options for conversion\nconverter.Struct(data, &user, structOption)\n'})})]})}function v(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453(e,n,r){r.d(n,{R:()=>s,x:()=>c});var o=r(296540);let t={},i=o.createContext(t);function s(e){let n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);