"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["753974"],{164531:function(e,n,a){a.r(n),a.d(n,{metadata:()=>i,contentTitle:()=>d,default:()=>g,assets:()=>o,toc:()=>l,frontMatter:()=>t});var i=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u5206\u5E93\u5206\u8868/ORM\u5206\u5E93\u5206\u8868-\u5206\u5E93\u7279\u6027","title":"ORM Sharding - Database Sharding","description":"GoFrame ORM Database Sharding provides flexible and efficient database partitioning functionality, supporting custom sharding rules to easily implement horizontal database scaling.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u5206\u5E93\u5206\u8868/ORM\u5206\u5E93\u5206\u8868-\u5206\u5E93\u7279\u6027.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u5206\u5E93\u5206\u8868","slug":"/docs/core/gdb-sharding-schema","permalink":"/en/docs/core/gdb-sharding-schema","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u5E93ORM/ORM\u5206\u5E93\u5206\u8868/ORM\u5206\u5E93\u5206\u8868-\u5206\u5E93\u7279\u6027.md","tags":[],"version":"current","lastUpdatedBy":"John Guo","lastUpdatedAt":1742194305000,"sidebarPosition":2000,"frontMatter":{"slug":"/docs/core/gdb-sharding-schema","title":"ORM Sharding - Database Sharding","sidebar_position":2000,"hide_title":true,"keywords":["Database Sharding","Horizontal Sharding","Schema Sharding","sharding","database sharding"],"description":"GoFrame ORM Database Sharding provides flexible and efficient database partitioning functionality, supporting custom sharding rules to easily implement horizontal database scaling."},"sidebar":"mainSidebar","previous":{"title":"ORM Sharding - Table Sharding","permalink":"/en/docs/core/gdb-sharding-table"},"next":{"title":"ORM - Senior Features","permalink":"/en/docs/core/gdb-senior"}}'),r=a("785893"),s=a("250065");let t={slug:"/docs/core/gdb-sharding-schema",title:"ORM Sharding - Database Sharding",sidebar_position:2e3,hide_title:!0,keywords:["Database Sharding","Horizontal Sharding","Schema Sharding","sharding","database sharding"],description:"GoFrame ORM Database Sharding provides flexible and efficient database partitioning functionality, supporting custom sharding rules to easily implement horizontal database scaling."},d=void 0,o={},l=[{value:"Basic Introduction",id:"basic-introduction",level:2},{value:"Advantages of Database Sharding",id:"advantages-of-database-sharding",level:2},{value:"Application Scenarios",id:"application-scenarios",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Database Sharding Configuration",id:"database-sharding-configuration",level:3},{value:"Default Database Sharding Rule",id:"default-database-sharding-rule",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Basic CRUD Operations",id:"basic-crud-operations",level:3},{value:"Custom Database Sharding Rules",id:"custom-database-sharding-rules",level:3},{value:"Combining Database and Table Sharding",id:"combining-database-and-table-sharding",level:3},{value:"Using <code>Hook</code> for Dynamic Database Sharding",id:"using-hook-for-dynamic-database-sharding",level:2},{value:"Important Considerations",id:"important-considerations",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"basic-introduction",children:"Basic Introduction"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ORM"})," Database Sharding (",(0,r.jsx)(n.code,{children:"Schema Sharding"}),") is a data partitioning solution provided by ",(0,r.jsx)(n.code,{children:"GoFrame ORM"})," that allows developers to distribute data from a logical table across multiple physical databases. Database sharding is an important approach for implementing horizontal database scaling. By distributing data across different database nodes, system processing capacity and scalability can be significantly improved."]}),"\n",(0,r.jsx)(n.h2,{id:"advantages-of-database-sharding",children:"Advantages of Database Sharding"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Overcomes Single Machine Performance Bottlenecks"}),": By distributing data across multiple database nodes, overcomes the performance limitations of a single database server"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Improves Concurrent Processing Capacity"}),": Distributes read and write pressure across multiple database nodes, improving overall concurrent processing capacity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enhances System Availability"}),": Failure of a single database node does not affect the entire system, improving system availability"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Geographic Distribution Advantages"}),": Can distribute data based on geographic location, reducing access latency and improving user experience"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexible Data Management"}),": Can distribute different types of data to different database nodes based on business requirements"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"application-scenarios",children:"Application Scenarios"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Large-Scale User Systems"}),": Sharding by user ID or geographic location to handle global user distribution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"E-commerce Platforms"}),": Sharding by merchant or product category to process large-scale product data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Financial Systems"}),": Sharding by account type or business line to achieve business isolation and high availability"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-tenant SaaS Platforms"}),": Sharding by tenant to ensure data isolation and security"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Big Data Analysis Systems"}),": Sharding by time or data type to optimize large-scale data processing"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GoFrame ORM"})," provides simple and easy-to-use database sharding APIs through the ",(0,r.jsx)(n.code,{children:"Sharding"})," and ",(0,r.jsx)(n.code,{children:"ShardingValue"})," methods."]}),"\n",(0,r.jsx)(n.h3,{id:"database-sharding-configuration",children:"Database Sharding Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Create database sharding configuration\nshardingConfig := gdb.ShardingConfig{\n    Schema: gdb.ShardingSchemaConfig{\n        Enable: true,     // Enable database sharding\n        Prefix: "db_",    // Database prefix\n        Rule: &gdb.DefaultShardingRule{\n            SchemaCount: 2, // Number of database shards\n        },\n    },\n}\n\n// Use sharding configuration and sharding value\nmodel := db.Model("user").\n    Sharding(shardingConfig).\n    ShardingValue(10001) // Sharding value, used to calculate which database the data routes to\n'})}),"\n",(0,r.jsx)(n.h3,{id:"default-database-sharding-rule",children:"Default Database Sharding Rule"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GoFrame ORM"})," includes a built-in default database sharding rule ",(0,r.jsx)(n.code,{children:"DefaultShardingRule"}),", which determines the database name based on the hash modulo of the sharding value:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Default database sharding rule implementation\nfunc (r *DefaultShardingRule) SchemaName(ctx context.Context, config ShardingSchemaConfig, value any) (string, error) {\n    if r.SchemaCount == 0 {\n        return "", gerror.NewCode(\n            gcode.CodeInvalidParameter, "schema count should not be 0 using DefaultShardingRule when schema sharding enabled",\n        )\n    }\n    hashValue, err := getHashValue(value)\n    if err != nil {\n        return "", err\n    }\n    nodeIndex := hashValue % uint64(r.SchemaCount)\n    return fmt.Sprintf("%s%d", config.Prefix, nodeIndex), nil\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,r.jsxs)(n.p,{children:["First, using ",(0,r.jsx)(n.code,{children:"MySQL"})," database as an example, we need to create multiple databases and corresponding table structures. For database sharding examples, we need to create multiple databases with the same table structure:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- Create databases needed for sharding\nCREATE DATABASE IF NOT EXISTS `db_0`;\nCREATE DATABASE IF NOT EXISTS `db_1`;\n\n-- Create tables with identical structure in each database\n-- Create table in db_0\nUSE `db_0`;\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL,\n  `name` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n-- Create table in db_1\nUSE `db_1`;\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL,\n  `name` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"basic-crud-operations",children:"Basic CRUD Operations"}),"\n",(0,r.jsxs)(n.p,{children:["The following example demonstrates how to perform basic ",(0,r.jsx)(n.code,{children:"CRUD"})," operations in a database sharding environment:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    _ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/frame/g"\n)\n\n// User structure\ntype User struct {\n    Id   int    `json:"id"`\n    Name string `json:"name"`\n}\n\nfunc main() {\n    // Create database sharding configuration\n    shardingConfig := gdb.ShardingConfig{\n        Schema: gdb.ShardingSchemaConfig{\n            Enable: true,  // Enable database sharding\n            Prefix: "db_", // Database prefix\n            Rule: &gdb.DefaultShardingRule{\n                SchemaCount: 2, // Number of database shards\n            },\n        },\n    }\n\n    // Prepare test data\n    user := User{\n        Id:   1,\n        Name: "John",\n    }\n\n    // Create sharded model\n    db := g.DB()\n    db.SetDebug(true)\n    model := db.Model("user").\n        Sharding(shardingConfig).\n        ShardingValue(user.Id) // Use user ID as sharding value\n\n    // Insert data\n    _, err := model.Data(user).Insert()\n    if err != nil {\n        panic(err)\n    }\n    // INSERT INTO `user`(`id`,`name`) VALUES(1,\'John\')\n    // Note: The operation is actually performed on the user table in the db_1 database\n\n    // Query data\n    var result User\n    err = model.Where("id", user.Id).Scan(&result)\n    if err != nil {\n        panic(err)\n    }\n    // SELECT * FROM `user` WHERE `id`=1 LIMIT 1\n    // Note: The query is actually performed on the user table in the db_1 database\n    g.DumpJson(result)\n\n    // Update data\n    _, err = model.Data(g.Map{"name": "John Doe"}).\n        Where("id", user.Id).\n        Update()\n    if err != nil {\n        panic(err)\n    }\n    // UPDATE `user` SET `name`=\'John Doe\' WHERE `id`=1\n    // Note: The update is actually performed on the user table in the db_1 database\n\n    // Delete data\n    _, err = model.Where("id", user.Id).Delete()\n    if err != nil {\n        panic(err)\n    }\n    // DELETE FROM `user` WHERE `id`=1\n    // Note: The deletion is actually performed on the user table in the db_1 database\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"custom-database-sharding-rules",children:"Custom Database Sharding Rules"}),"\n",(0,r.jsxs)(n.p,{children:["You can create custom database sharding rules by implementing the ",(0,r.jsx)(n.code,{children:"ShardingRule"})," interface:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    _ "github.com/gogf/gf/contrib/drivers/mysql/v2"\n\n    "context"\n    "fmt"\n\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/frame/g"\n)\n\n// RegionShardingRule implements region-based database sharding\ntype RegionShardingRule struct {\n    // Mapping from region to database\n    RegionMapping map[string]string\n}\n\n// SchemaName implements region-based database sharding rule\nfunc (r *RegionShardingRule) SchemaName(ctx context.Context, config gdb.ShardingSchemaConfig, value any) (string, error) {\n    // Convert sharding value to region information\n    region, ok := value.(string)\n    if !ok {\n        return "", fmt.Errorf("sharding value must be string for RegionShardingRule")\n    }\n\n    // Get the database name corresponding to the region\n    if dbName, exists := r.RegionMapping[region]; exists {\n        return dbName, nil\n    }\n\n    // If no corresponding region is found, use the default database\n    return config.Prefix + "default", nil\n}\n\n// TableName implements table sharding interface\nfunc (r *RegionShardingRule) TableName(ctx context.Context, config gdb.ShardingTableConfig, value any) (string, error) {\n    // Not implementing table sharding, return empty string\n    return "", nil\n}\n\nfunc main() {\n    // Create mapping from region to database\n    regionMapping := map[string]string{\n        "east":  "db_east",\n        "west":  "db_west",\n        "north": "db_north",\n        "south": "db_south",\n    }\n\n    // Create region-based database sharding configuration\n    shardingConfig := gdb.ShardingConfig{\n        Schema: gdb.ShardingSchemaConfig{\n            Enable: true,                                              // Enable database sharding\n            Prefix: "db_",                                             // Database prefix\n            Rule:   &RegionShardingRule{RegionMapping: regionMapping}, // Custom database sharding rule\n        },\n    }\n\n    // Sharding value is the user\'s region\n    region := "east"\n\n    // Create sharded model\n    db := g.DB()\n    db.SetDebug(true)\n    model := g.DB().Model("user").\n        Sharding(shardingConfig).\n        ShardingValue(region) // Use region as sharding value\n\n    // Insert user data\n    _, err := model.Data(g.Map{\n        "id":     1001,\n        "name":   "John",\n        "region": region,\n    }).Insert()\n    if err != nil {\n        panic(err)\n    }\n    // INSERT INTO `user`(`id`,`name`,`region`) VALUES(1001,\'John\',\'east\')\n    // Note: The operation is actually performed on the user table in the db_east database\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"combining-database-and-table-sharding",children:"Combining Database and Table Sharding"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GoFrame ORM"})," supports configuring both database and table sharding simultaneously for more granular data partitioning:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Configure both database and table sharding\nshardingConfig := gdb.ShardingConfig{\n    Schema: gdb.ShardingSchemaConfig{\n        Enable: true,     // Enable database sharding\n        Prefix: "db_",    // Database prefix\n        Rule: &gdb.DefaultShardingRule{\n            SchemaCount: 2, // Number of database shards\n        },\n    },\n    Table: gdb.ShardingTableConfig{\n        Enable: true,     // Enable table sharding\n        Prefix: "user_",  // Table prefix\n        Rule: &gdb.DefaultShardingRule{\n            TableCount: 4, // Number of table shards\n        },\n    },\n}\n\n// Use database and table sharding configuration\nmodel := g.DB().Model("user").\n    Sharding(shardingConfig).\n    ShardingValue(10001)  // The same sharding value is used to calculate both database and table\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"using-hook-for-dynamic-database-sharding",children:["Using ",(0,r.jsx)(n.code,{children:"Hook"})," for Dynamic Database Sharding"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GoFrame ORM"})," provides a powerful ",(0,r.jsx)(n.code,{children:"Hook"})," mechanism that can be used to implement more flexible database sharding strategies:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Using Hook for dynamic database sharding\nmodel := db.Model("user").Hook(gdb.HookHandler{\n    Select: func(ctx context.Context, in *gdb.HookSelectInput) (result gdb.Result, err error) {\n        // Dynamically determine database based on query conditions\n        in.Schema = determineSchema(in.Model.GetWhere())\n        return in.Next(ctx)\n    },\n    Insert: func(ctx context.Context, in *gdb.HookInsertInput) (result sql.Result, err error) {\n        // Dynamically determine database based on insert data\n        in.Schema = determineSchemaFromData(in.Data)\n        return in.Next(ctx)\n    },\n    // Other Hook methods...\n})\n'})}),"\n",(0,r.jsxs)(n.p,{children:["For more information about the ",(0,r.jsx)(n.code,{children:"Hook"})," feature, please refer to the chapter: ",(0,r.jsx)(n.a,{href:"/en/docs/core/gdb-chaining-hook",children:"ORM Chain Operations-Hook Feature"})]}),"\n",(0,r.jsx)(n.h2,{id:"important-considerations",children:"Important Considerations"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sharding Value Must Be Provided"}),": When database sharding is enabled, a sharding value must be provided via the ",(0,r.jsx)(n.code,{children:"ShardingValue"})," method, otherwise an error will be returned"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sharding Rule Must Be Set"}),": When database sharding is enabled, a sharding rule must be set, otherwise an error will be returned"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cross-Database Transaction Limitations"}),": By default, transactions cannot span multiple databases; distributed transactions must be used to solve this"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Database Configuration Requirements"}),": All database shard nodes need to be correctly configured in the configuration file to ensure connectivity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cross-Database Query Limitations"}),": By default, queries are only routed to a single database shard; for cross-database queries, custom implementation is required"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsxs)(n.p,{children:["The database sharding feature of ",(0,r.jsx)(n.code,{children:"GoFrame ORM"})," provides a flexible and powerful horizontal database partitioning solution suitable for scenarios requiring large-scale data processing capabilities. By properly configuring database sharding strategies, you can significantly improve system performance and scalability. Whether using the built-in default database sharding rules or implementing custom sharding logic, ",(0,r.jsx)(n.code,{children:"GoFrame"})," provides flexible API support."]}),"\n",(0,r.jsx)(n.p,{children:"In practical applications, it is recommended to choose appropriate database sharding strategies based on business characteristics and data distribution, and pay attention to handling cross-database queries and transaction issues."})]})}function g(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},250065:function(e,n,a){a.d(n,{Z:function(){return d},a:function(){return t}});var i=a(667294);let r={},s=i.createContext(r);function t(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);