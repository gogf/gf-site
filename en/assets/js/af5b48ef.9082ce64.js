"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["13337"],{451522:function(e,n,t){t.r(n),t.d(n,{metadata:()=>a,contentTitle:()=>o,default:()=>u,assets:()=>d,toc:()=>l,frontMatter:()=>i});var a=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u6821\u9A8C/\u6570\u636E\u6821\u9A8C-\u53C2\u6570\u7C7B\u578B/\u6570\u636E\u6821\u9A8C-Struct\u6821\u9A8C/Struct\u6821\u9A8C-\u57FA\u672C\u4F7F\u7528","title":"Struct Validation - Example","description":"Conducting validation for Struct type data using the GoFrame framework, including detailed explanations of validation tag rules and methods for different data types, such as basic validation, using map for custom rules, and recursive validation of structs. Example code demonstrates how to set field aliases and customize error messages, implementing complex validation logic for different attributes within a struct object.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u6821\u9A8C/\u6570\u636E\u6821\u9A8C-\u53C2\u6570\u7C7B\u578B/\u6570\u636E\u6821\u9A8C-Struct\u6821\u9A8C/Struct\u6821\u9A8C-\u57FA\u672C\u4F7F\u7528.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u6821\u9A8C/\u6570\u636E\u6821\u9A8C-\u53C2\u6570\u7C7B\u578B/\u6570\u636E\u6821\u9A8C-Struct\u6821\u9A8C","slug":"/docs/core/gvalid-parameter-type-struct-example","permalink":"/en/docs/core/gvalid-parameter-type-struct-example","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u6570\u636E\u6821\u9A8C/\u6570\u636E\u6821\u9A8C-\u53C2\u6570\u7C7B\u578B/\u6570\u636E\u6821\u9A8C-Struct\u6821\u9A8C/Struct\u6821\u9A8C-\u57FA\u672C\u4F7F\u7528.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732541616000,"sidebarPosition":0,"frontMatter":{"slug":"/docs/core/gvalid-parameter-type-struct-example","title":"Struct Validation - Example","sidebar_position":0,"hide_title":true,"keywords":["Struct Validation","GoFrame Framework","gvalid","Parameter Validation","Field Alias","Validation Rules","Chain Operation","Nested Validation","Recursive Validation","Go"],"description":"Conducting validation for Struct type data using the GoFrame framework, including detailed explanations of validation tag rules and methods for different data types, such as basic validation, using map for custom rules, and recursive validation of structs. Example code demonstrates how to set field aliases and customize error messages, implementing complex validation logic for different attributes within a struct object."},"sidebar":"mainSidebar","previous":{"title":"Data Type - Struct","permalink":"/en/docs/core/gvalid-parameter-type-struct"},"next":{"title":"Struct Validation - Assoc","permalink":"/en/docs/core/gvalid-parameter-type-struct-assoc"}}'),s=t("785893"),r=t("250065");let i={slug:"/docs/core/gvalid-parameter-type-struct-example",title:"Struct Validation - Example",sidebar_position:0,hide_title:!0,keywords:["Struct Validation","GoFrame Framework","gvalid","Parameter Validation","Field Alias","Validation Rules","Chain Operation","Nested Validation","Recursive Validation","Go"],description:"Conducting validation for Struct type data using the GoFrame framework, including detailed explanations of validation tag rules and methods for different data types, such as basic validation, using map for custom rules, and recursive validation of structs. Example code demonstrates how to set field aliases and customize error messages, implementing complex validation logic for different attributes within a struct object."},o=void 0,d={},l=[{value:"Validation <code>tag</code> Rules Introduction",id:"validation-tag-rules-introduction",level:2},{value:"Validation <code>tag</code> Usage Example",id:"validation-tag-usage-example",level:2},{value:"Using <code>map</code> to Specify Validation Rules",id:"using-map-to-specify-validation-rules",level:2},{value:"Struct Recursive Validation (Nested Validation)",id:"struct-recursive-validation-nested-validation",level:2}];function c(e){let n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Struct"})," validation is often used in the following chain operation method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"g.Validator().Data(object).Run(ctx)\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"validation-tag-rules-introduction",children:["Validation ",(0,s.jsx)(n.code,{children:"tag"})," Rules Introduction"]}),"\n",(0,s.jsxs)(n.p,{children:["Before introducing ",(0,s.jsx)(n.code,{children:"Struct"})," parameter type validation, let's introduce some common validation ",(0,s.jsx)(n.code,{children:"tag"})," rules. The rules are as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[FieldAlias@]ValidationRule[#ErrorMessage]\n"})}),"\n",(0,s.jsx)(n.p,{children:"Where:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FieldAlias"})," and ",(0,s.jsx)(n.code,{children:"ErrorMessage"})," are ",(0,s.jsx)(n.strong,{children:"optional fields"}),", and ",(0,s.jsx)(n.code,{children:"ValidationRule"})," is a ",(0,s.jsx)(n.strong,{children:"mandatory field."})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FieldAlias"})," is an optional field, specifying the alias of the corresponding ",(0,s.jsx)(n.code,{children:"struct"})," field used in validation. The ",(0,s.jsx)(n.code,{children:"error"})," object returned after validation will use this alias. This is particularly useful when dealing with request forms, as field names in forms often do not match the property names in the ",(0,s.jsx)(n.code,{children:"struct"}),". In most scenarios, you don't need to set the field alias and can directly use the property name by default."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ValidationRule"})," is the validation rule for the current property. Multiple validation rules can be combined using the ",(0,s.jsx)(n.code,{children:"|"})," symbol, for example: ",(0,s.jsx)(n.code,{children:"required|between:1,100"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ErrorMessage"})," is an optional field, representing a custom error message that overrides the default error message when the rule validation fails."]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"validation-tag-usage-example",children:["Validation ",(0,s.jsx)(n.code,{children:"tag"})," Usage Example"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/os/gctx"\n)\n\ntype User struct {\n    Uid   int    `v:"uid      @integer|min:1#|Please enter the user ID"`\n    Name  string `v:"name     @required|length:6,30#Please enter the user name|Invalid length for user name"`\n    Pass1 string `v:"password1@required|password3"`\n    Pass2 string `v:"password2@required|password3|same:Pass1#|Invalid password format|The two passwords do not match, please re-enter"`\n}\n\nfunc main() {\n    var (\n        ctx  = gctx.New()\n        user = &User{\n            Name:  "john",\n            Pass1: "Abc123!@#",\n            Pass2: "123",\n        }\n    )\n\n    err := g.Validator().Data(user).Run(ctx)\n    if err != nil {\n        g.Dump(err.Items())\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As you can see, we can bind validation rules and error messages using ",(0,s.jsx)(n.code,{children:"gvalid tag"})," when defining the ",(0,s.jsx)(n.code,{children:"struct"}),". In this sample code, the rule ",(0,s.jsx)(n.code,{children:"same:password1"})," is the same as using ",(0,s.jsx)(n.code,{children:"same:Pass1"}),". ",(0,s.jsxs)(n.strong,{children:["This means that data validation can use both the original ",(0,s.jsx)(n.code,{children:"struct"})," property name and the alias simultaneously. However, the returned result will only use the alias, which is the primary purpose of the alias."]})," Also, when validating a ",(0,s.jsx)(n.code,{children:"struct"})," object, you can pass validation and error message parameters, which will override the corresponding parameters bound when the ",(0,s.jsx)(n.code,{children:"struct"})," is defined."]}),"\n",(0,s.jsx)(n.p,{children:"After executing the above example, the output is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'[\n    {\n        "uid": {\n            "min": "Please enter the user ID",\n        },\n    },\n    {\n        "name": {\n            "length": "Invalid length for user name",\n        },\n    },\n    {\n        "password2": {\n            "password3": "Invalid password format",\n        },\n    },\n]\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"using-map-to-specify-validation-rules",children:["Using ",(0,s.jsx)(n.code,{children:"map"})," to Specify Validation Rules"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/os/gctx"\n)\n\nfunc main() {\n    type User struct {\n        Age  int\n        Name string\n    }\n    var (\n        ctx   = gctx.New()\n        user  = User{Name: "john"}\n        rules = map[string]string{\n            "Name": "required|length:6,16",\n            "Age":  "between:18,30",\n        }\n        messages = map[string]interface{}{\n            "Name": map[string]string{\n                "required": "Name cannot be empty",\n                "length":   "Name length must be between {min} and {max} characters",\n            },\n            "Age": "Age must be between 18 to 30 years old",\n        }\n    )\n\n    err := g.Validator().Rules(rules).Messages(messages).Data(user).Run(ctx)\n    if err != nil {\n        g.Dump(err.Maps())\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the above example, the ",(0,s.jsx)(n.code,{children:"Age"})," property has a default value of ",(0,s.jsx)(n.code,{children:"0"}),", which can cause the ",(0,s.jsx)(n.code,{children:"required"})," rule to be ineffective. Therefore, we use the ",(0,s.jsx)(n.code,{children:"between"})," rule for validation instead. After executing the example, the terminal outputs:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n    "Age": {\n        "between": "Age must be between 18 to 30 years old"\n    },\n    "Name": {\n        "length": "Name length must be between 6 to 16 characters"\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"struct-recursive-validation-nested-validation",children:"Struct Recursive Validation (Nested Validation)"}),"\n",(0,s.jsx)(n.p,{children:"Supports recursive struct validation (nested validation), meaning if a property is a struct (nested structs are also supported), it will automatically perform recursive validation on that property. Example usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/os/gctx"\n)\n\nfunc main() {\n    type Pass struct {\n        Pass1 string `v:"password1@required|same:password2#Please enter your password|The two passwords do not match"`\n        Pass2 string `v:"password2@required|same:password1#Please re-enter your password|The two passwords do not match"`\n    }\n    type User struct {\n        Pass\n        Id   int\n        Name string `valid:"name@required#Please enter your name"`\n    }\n    var (\n        ctx  = gctx.New()\n        user = &User{\n            Name: "john",\n            Pass: Pass{\n                Pass1: "1",\n                Pass2: "2",\n            },\n        }\n    )\n    err := g.Validator().Data(user).Run(ctx)\n    g.Dump(err.Maps())\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Or when properties are nested structs (",(0,s.jsx)(n.code,{children:"embedded"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/os/gctx"\n)\n\nfunc main() {\n    type Pass struct {\n        Pass1 string `v:"password1@required|same:password2#Please enter your password|The two passwords do not match"`\n        Pass2 string `v:"password2@required|same:password1#Please re-enter your password|The two passwords do not match"`\n    }\n    type User struct {\n        Id   int\n        Name string `valid:"name@required#Please enter your name"`\n        Pass Pass\n    }\n    var (\n        ctx  = gctx.New()\n        user = &User{\n            Name: "john",\n            Pass: Pass{\n                Pass1: "1",\n                Pass2: "2",\n            },\n        }\n    )\n    err := g.Validator().Data(user).Run(ctx)\n    g.Dump(err.Maps())\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Once executed, the terminal output is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n    "password1": {\n        "same": "The two passwords do not match",\n    },\n    "password2": {\n        "same": "The two passwords do not match",\n    },\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["For more introductions on recursive validation, please refer to the section: ",(0,s.jsx)(n.a,{href:"/en/docs/core/gvalid-recursive-validating",children:"Data Validation - Recursive"})]})]})}function u(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return o},a:function(){return i}});var a=t(667294);let s={},r=a.createContext(s);function i(e){let n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);