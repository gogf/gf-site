"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["19343"],{453654:function(e,n,r){r.r(n),r.d(n,{metadata:()=>t,contentTitle:()=>s,default:()=>u,assets:()=>c,toc:()=>l,frontMatter:()=>i});var t=JSON.parse('{"id":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-UnmarshalValue","title":"Type Conversion - Interface","description":"Use the gconv module in the GoFrame framework for type conversions, especially custom conversions through the UnmarshalValue interface. A detailed discussion on the application of reflection features in complex type conversions and their performance impact, along with multiple code examples, including custom struct conversion and TCP data unpacking, to help developers optimize conversion efficiency.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-UnmarshalValue.md","sourceDirName":"docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362","slug":"/docs/core/gconv-unmarshal-value","permalink":"/en/docs/core/gconv-unmarshal-value","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/docs/\u6838\u5FC3\u7EC4\u4EF6/\u7C7B\u578B\u8F6C\u6362/\u7C7B\u578B\u8F6C\u6362-UnmarshalValue.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1732440306000,"sidebarPosition":6,"frontMatter":{"slug":"/docs/core/gconv-unmarshal-value","title":"Type Conversion - Interface","sidebar_position":6,"hide_title":true,"keywords":["GoFrame","GoFrame Framework","gconv","UnmarshalValue","type conversion","custom conversion","struct conversion","interface definition","performance optimization","reflection"],"description":"Use the gconv module in the GoFrame framework for type conversions, especially custom conversions through the UnmarshalValue interface. A detailed discussion on the application of reflection features in complex type conversions and their performance impact, along with multiple code examples, including custom struct conversion and TCP data unpacking, to help developers optimize conversion efficiency."},"sidebar":"mainSidebar","previous":{"title":"Type Conversion - Converter","permalink":"/en/docs/core/gconv-converter"},"next":{"title":"Type Conversion - Performance","permalink":"/en/docs/core/gconv-benchmark"}}'),a=r("785893"),o=r("250065");let i={slug:"/docs/core/gconv-unmarshal-value",title:"Type Conversion - Interface",sidebar_position:6,hide_title:!0,keywords:["GoFrame","GoFrame Framework","gconv","UnmarshalValue","type conversion","custom conversion","struct conversion","interface definition","performance optimization","reflection"],description:"Use the gconv module in the GoFrame framework for type conversions, especially custom conversions through the UnmarshalValue interface. A detailed discussion on the application of reflection features in complex type conversions and their performance impact, along with multiple code examples, including custom struct conversion and TCP data unpacking, to help developers optimize conversion efficiency."},s=void 0,c={},l=[{value:"Interface Definition",id:"interface-definition",level:2},{value:"Usage Examples",id:"usage-examples",level:2},{value:"1. Custom Data Table Query Result <code>struct</code> Conversion",id:"1-custom-data-table-query-result-struct-conversion",level:3},{value:"2. Custom Binary TCP Data Unpacking",id:"2-custom-binary-tcp-data-unpacking",level:3}];function d(e){let n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Of course, you might have already guessed that the ",(0,a.jsx)(n.code,{children:"gconv"})," module actually uses reflection for conversions involving complex types such as ",(0,a.jsx)(n.code,{children:"struct"}),". While it provides a great convenience for developers, it does come at the cost of performance. For ",(0,a.jsx)(n.code,{children:"struct"})," conversions, if developers have clearly defined conversion rules and are concerned about performance costs, they can implement the ",(0,a.jsx)(n.code,{children:"UnmarshalValue"})," interface for specific ",(0,a.jsx)(n.code,{children:"structs"})," to achieve ",(0,a.jsx)(n.strong,{children:"custom conversion"}),". When using the ",(0,a.jsx)(n.code,{children:"gconv"})," module for conversion, whether the ",(0,a.jsx)(n.code,{children:"struct"})," is directly the conversion object or a property of the conversion object, ",(0,a.jsx)(n.code,{children:"gconv"})," will automatically recognize the implemented ",(0,a.jsx)(n.code,{children:"UnmarshalValue"})," interface and use it for type conversion instead of using reflection."]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Common deserialization interfaces in the standard library, such as ",(0,a.jsx)(n.code,{children:"UnmarshalText(text []byte) error"}),", are also supported, and they are used in a similar manner to ",(0,a.jsx)(n.code,{children:"UnmarshalValue"}),", with different parameters."]})}),"\n",(0,a.jsx)(n.h2,{id:"interface-definition",children:"Interface Definition"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"// apiUnmarshalValue is the interface for custom defined types customizing value assignment.\n// Note that only pointer can implement interface apiUnmarshalValue.\ntype apiUnmarshalValue interface {\n    UnmarshalValue(interface{}) error\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As you can see, custom types can implement the ",(0,a.jsx)(n.code,{children:"UnmarshalValue"})," method for custom type conversion. The input parameter here is of ",(0,a.jsx)(n.code,{children:"interface{}"})," type, and developers can use type assertions or other methods for type conversion in practical use cases."]}),"\n",(0,a.jsxs)(n.admonition,{type:"warning",children:[(0,a.jsxs)(n.p,{children:["It's important to note that because the ",(0,a.jsx)(n.code,{children:"UnmarshalValue"})," type conversion modifies the properties of the current object, the receiver of the interface implementation must be a pointer type."]}),(0,a.jsx)(n.p,{children:"Correct interface implementation example (using pointer receiver):"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"func (c *Receiver) UnmarshalValue(interface{}) error\n"})}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Incorrect"})," interface implementation example (using value receiver):"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"func (c Receiver) UnmarshalValue(interface{}) error\n"})})]}),"\n",(0,a.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,a.jsxs)(n.h3,{id:"1-custom-data-table-query-result-struct-conversion",children:["1. Custom Data Table Query Result ",(0,a.jsx)(n.code,{children:"struct"})," Conversion"]}),"\n",(0,a.jsx)(n.p,{children:"Data table structure:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE `user` (\n   id bigint unsigned NOT NULL AUTO_INCREMENT,\n   passport varchar(45),\n   password char(32) NOT NULL,\n   nickname varchar(45) NOT NULL,\n   create_time timestamp NOT NULL,\n   PRIMARY KEY (id)\n) ;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Example code:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "github.com/gogf/gf/v2/container/garray"\n    "github.com/gogf/gf/v2/database/gdb"\n    "github.com/gogf/gf/v2/errors/gerror"\n    "github.com/gogf/gf/v2/frame/g"\n    "github.com/gogf/gf/v2/os/gtime"\n    "reflect"\n)\n\ntype User struct {\n    Id         int\n    Passport   string\n    Password   string\n    Nickname   string\n    CreateTime *gtime.Time\n}\n\n// Implement UnmarshalValue interface for custom struct conversion\nfunc (user *User) UnmarshalValue(value interface{}) error {\n    if record, ok := value.(gdb.Record); ok {\n        *user = User{\n            Id:         record["id"].Int(),\n            Passport:   record["passport"].String(),\n            Password:   "",\n            Nickname:   record["nickname"].String(),\n            CreateTime: record["create_time"].GTime(),\n        }\n        return nil\n    }\n    return gerror.Newf(`unsupported value type for UnmarshalValue: %v`, reflect.TypeOf(value))\n}\n\nfunc main() {\n    var (\n        err   error\n        users []*User\n    )\n    array := garray.New(true)\n    for i := 1; i <= 10; i++ {\n        array.Append(g.Map{\n            "id":          i,\n            "passport":    fmt.Sprintf(`user_%d`, i),\n            "password":    fmt.Sprintf(`pass_%d`, i),\n            "nickname":    fmt.Sprintf(`name_%d`, i),\n            "create_time": gtime.NewFromStr("2018-10-24 10:00:00").String(),\n        })\n    }\n    // Insert data\n    _, err = g.Model("user").Data(array).Insert()\n    if err != nil {\n        panic(err)\n    }\n    // Query data\n    err = g.Model("user").Order("id asc").Scan(&users)\n    if err != nil {\n        panic(err)\n    }\n    g.Dump(users)\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"After execution, the terminal output:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'[\n    {\n        Id:         1,\n        Passport:   "user_1",\n        Password:   "",\n        Nickname:   "name_1",\n        CreateTime: "2018-10-24 10:00:00",\n    },\n    {\n        Id:         2,\n        Passport:   "user_2",\n        Password:   "",\n        Nickname:   "name_2",\n        CreateTime: "2018-10-24 10:00:00",\n    },\n    {\n        Id:         3,\n        Passport:   "user_3",\n        Password:   "",\n        Nickname:   "name_3",\n        CreateTime: "2018-10-24 10:00:00",\n    },\n    {\n        Id:         4,\n        Passport:   "user_4",\n        Password:   "",\n        Nickname:   "name_4",\n        CreateTime: "2018-10-24 10:00:00",\n    },\n    {\n        Id:         5,\n        Passport:   "user_5",\n        Password:   "",\n        Nickname:   "name_5",\n        CreateTime: "2018-10-24 10:00:00",\n    },\n    {\n        Id:         6,\n        Passport:   "user_6",\n        Password:   "",\n        Nickname:   "name_6",\n        CreateTime: "2018-10-24 10:00:00",\n    },\n    {\n        Id:         7,\n        Passport:   "user_7",\n        Password:   "",\n        Nickname:   "name_7",\n        CreateTime: "2018-10-24 10:00:00",\n    },\n    {\n        Id:         8,\n        Passport:   "user_8",\n        Password:   "",\n        Nickname:   "name_8",\n        CreateTime: "2018-10-24 10:00:00",\n    },\n    {\n        Id:         9,\n        Passport:   "user_9",\n        Password:   "",\n        Nickname:   "name_9",\n        CreateTime: "2018-10-24 10:00:00",\n    },\n    {\n        Id:         10,\n        Passport:   "user_10",\n        Password:   "",\n        Nickname:   "name_10",\n        CreateTime: "2018-10-24 10:00:00",\n    },\n]\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["As you can see, the custom ",(0,a.jsx)(n.code,{children:"UnmarshalValue"})," type conversion method does not use reflection, which greatly improves conversion performance. You can try increasing the data volume (e.g., ",(0,a.jsx)(n.code,{children:"1 million"}),") and compare the time cost of type conversion without ",(0,a.jsx)(n.code,{children:"UnmarshalValue"}),"."]})}),"\n",(0,a.jsx)(n.h3,{id:"2-custom-binary-tcp-data-unpacking",children:"2. Custom Binary TCP Data Unpacking"}),"\n",(0,a.jsx)(n.p,{children:"An example of unpacking a TCP communication data packet."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "errors"\n    "fmt"\n    "github.com/gogf/gf/v2/crypto/gcrc32"\n    "github.com/gogf/gf/v2/encoding/gbinary"\n    "github.com/gogf/gf/v2/util/gconv"\n)\n\ntype Pkg struct {\n    Length uint16 // Total length.\n    Crc32  uint32 // CRC32.\n    Data   []byte\n}\n\n// NewPkg creates and returns a package with given data.\nfunc NewPkg(data []byte) *Pkg {\n    return &Pkg{\n        Length: uint16(len(data) + 6),\n        Crc32:  gcrc32.Encrypt(data),\n        Data:   data,\n    }\n}\n\n// Marshal encodes the protocol struct to bytes.\nfunc (p *Pkg) Marshal() []byte {\n    b := make([]byte, 6+len(p.Data))\n    copy(b, gbinary.EncodeUint16(p.Length))\n    copy(b[2:], gbinary.EncodeUint32(p.Crc32))\n    copy(b[6:], p.Data)\n    return b\n}\n\n// UnmarshalValue decodes bytes to protocol struct.\nfunc (p *Pkg) UnmarshalValue(v interface{}) error {\n    b := gconv.Bytes(v)\n    if len(b) < 6 {\n        return errors.New("invalid package length")\n    }\n    p.Length = gbinary.DecodeToUint16(b[:2])\n    if len(b) < int(p.Length) {\n        return errors.New("invalid data length")\n    }\n    p.Crc32 = gbinary.DecodeToUint32(b[2:6])\n    p.Data = b[6:]\n    if gcrc32.Encrypt(p.Data) != p.Crc32 {\n        return errors.New("crc32 validation failed")\n    }\n    return nil\n}\n\nfunc main() {\n    var p1, p2 *Pkg\n\n    // Create a demo pkg as p1.\n    p1 = NewPkg([]byte("123"))\n    fmt.Println(p1)\n\n    // Convert bytes from p1 to p2 using gconv.Struct.\n    err := gconv.Struct(p1.Marshal(), &p2)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(p2)\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"After execution, the terminal output:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"&{9 2286445522 [49 50 51]}\n&{9 2286445522 [49 50 51]}\n"})})]})}function u(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},250065:function(e,n,r){r.d(n,{Z:function(){return s},a:function(){return i}});var t=r(667294);let a={},o=t.createContext(a);function i(e){let n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);