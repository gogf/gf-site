"use strict";(self.webpackChunkgf_site=self.webpackChunkgf_site||[]).push([["53833"],{135161:function(e,n,a){a.r(n),a.d(n,{metadata:()=>r,contentTitle:()=>d,default:()=>h,assets:()=>o,toc:()=>l,frontMatter:()=>t});var r=JSON.parse('{"id":"community/\u793E\u533A\u6295\u7A3F/\u7535\u5546\u7CFB\u7EDF\u6848\u4F8B\uFF0CGo\u8BED\u8A00\u6570\u636E\u5E93\u5206\u5E93\u5206\u8868\u5B9E\u6218","title":"Database Sharding in Go: A Practical E-commerce Case Study","description":"A comprehensive guide on implementing database sharding in Go using a real-world e-commerce system case study, covering design principles and practical implementation with MySQL to handle large-scale data challenges.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/community/\u793E\u533A\u6295\u7A3F/\u7535\u5546\u7CFB\u7EDF\u6848\u4F8B\uFF0CGo\u8BED\u8A00\u6570\u636E\u5E93\u5206\u5E93\u5206\u8868\u5B9E\u6218.md","sourceDirName":"community/\u793E\u533A\u6295\u7A3F","slug":"/articles/database-sharding-in-go","permalink":"/en/articles/database-sharding-in-go","draft":false,"unlisted":false,"editUrl":"https://github.com/gogf/gf-site/blob/main/docs/community/\u793E\u533A\u6295\u7A3F/\u7535\u5546\u7CFB\u7EDF\u6848\u4F8B\uFF0CGo\u8BED\u8A00\u6570\u636E\u5E93\u5206\u5E93\u5206\u8868\u5B9E\u6218.md","tags":[],"version":"current","lastUpdatedBy":"John","lastUpdatedAt":1742294032000,"frontMatter":{"slug":"/articles/database-sharding-in-go","title":"Database Sharding in Go: A Practical E-commerce Case Study","hide_title":true,"keywords":["GoFrame","Database Sharding","Database Partitioning","Horizontal Scaling","MySQL Sharding","E-commerce System","Go Implementation","High Performance"],"description":"A comprehensive guide on implementing database sharding in Go using a real-world e-commerce system case study, covering design principles and practical implementation with MySQL to handle large-scale data challenges."},"sidebar":"communitySidebar","previous":{"title":"Building High-Performance Real-Time Communication: Go Language SSE Implementation Guide","permalink":"/en/articles/go-sse-implementation-guide"}}'),i=a("785893"),s=a("250065");let t={slug:"/articles/database-sharding-in-go",title:"Database Sharding in Go: A Practical E-commerce Case Study",hide_title:!0,keywords:["GoFrame","Database Sharding","Database Partitioning","Horizontal Scaling","MySQL Sharding","E-commerce System","Go Implementation","High Performance"],description:"A comprehensive guide on implementing database sharding in Go using a real-world e-commerce system case study, covering design principles and practical implementation with MySQL to handle large-scale data challenges."},d=void 0,o={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Database Sharding Use Cases",id:"database-sharding-use-cases",level:2},{value:"What is Database Sharding?",id:"what-is-database-sharding",level:3},{value:"Suitable Scenarios",id:"suitable-scenarios",level:3},{value:"Why Sharding is Necessary",id:"why-sharding-is-necessary",level:3},{value:"E-commerce Order System Case Study",id:"e-commerce-order-system-case-study",level:2},{value:"Business Requirements Analysis",id:"business-requirements-analysis",level:3},{value:"Sharding Strategy Design",id:"sharding-strategy-design",level:3},{value:"Technical Implementation",id:"technical-implementation",level:3},{value:"1. Database Preparation",id:"1-database-preparation",level:4},{value:"2. Database Configuration",id:"2-database-configuration",level:4},{value:"3. Custom Sharding Rules",id:"3-custom-sharding-rules",level:4},{value:"4. Order Model Definition",id:"4-order-model-definition",level:4},{value:"Best Practices and Considerations",id:"best-practices-and-considerations",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){let n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"As business scales grow, the performance bottlenecks of single databases become increasingly apparent. When data volume reaches a certain threshold, excessive data in a single table or high load on a single database can significantly degrade read and write performance, potentially leading to system unavailability. Database sharding has become an indispensable part of large-scale system architecture as an effective solution to this challenge."}),"\n",(0,i.jsxs)(n.p,{children:["This article uses an e-commerce system as a practical case study, demonstrating database sharding design and implementation using the ",(0,i.jsx)(n.code,{children:"GoFrame"})," framework and ",(0,i.jsx)(n.code,{children:"MySQL"})," database, helping developers tackle large-scale data challenges effectively."]}),"\n",(0,i.jsx)(n.h2,{id:"database-sharding-use-cases",children:"Database Sharding Use Cases"}),"\n",(0,i.jsx)(n.h3,{id:"what-is-database-sharding",children:"What is Database Sharding?"}),"\n",(0,i.jsx)(n.p,{children:"Database sharding involves distributing table data across different databases or tables according to specific rules, addressing performance issues caused by large data volumes in single databases or tables."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Database Sharding"}),": Distributing data across different database instances to address limitations in database connections, single-machine disk space, and computing power."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Table Sharding"}),": Spreading data across multiple tables within the same database to improve query efficiency when dealing with large data volumes."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"suitable-scenarios",children:"Suitable Scenarios"}),"\n",(0,i.jsx)(n.p,{children:"Database sharding is particularly useful in these scenarios:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User Systems"}),": User data in large internet applications can be sharded by user ID across multiple databases and tables."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Order Systems"}),": E-commerce platform order data can be sharded by order ID or time dimension to handle high-concurrency order processing."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Logging Systems"}),": System logs and operation logs with rapidly growing data volumes are typically sharded by time dimension."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Social Media"}),": User relationships and content data in social platforms can be sharded by user ID or content ID."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"IoT Applications"}),": Massive device-generated data can be sharded by device ID or time."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"why-sharding-is-necessary",children:"Why Sharding is Necessary"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance Enhancement"}),": Reduces single table data volume, decreases index depth, improves query efficiency; distributes database load to increase concurrent processing capability."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Breaking Limitations"}),": Overcomes single-machine database limitations in storage capacity, connections, and computing power."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High Availability"}),": Database-level sharding enables fault isolation, improving overall system availability."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scalability"}),": Supports horizontal scaling through adding database nodes or tables as business grows."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Maintenance Efficiency"}),": Enables independent backup, recovery, and archiving operations per shard, simplifying database maintenance."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"e-commerce-order-system-case-study",children:"E-commerce Order System Case Study"}),"\n",(0,i.jsxs)(n.p,{children:["Let's explore implementing database sharding with ",(0,i.jsx)(n.code,{children:"GoFrame"})," using an e-commerce order system as an example."]}),"\n",(0,i.jsx)(n.h3,{id:"business-requirements-analysis",children:"Business Requirements Analysis"}),"\n",(0,i.jsx)(n.p,{children:"Consider an e-commerce platform generating massive order data daily, where a single table can no longer handle the load, necessitating database sharding."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Order Table Structure"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Order ID: Unique identifier"}),"\n",(0,i.jsx)(n.li,{children:"User ID: Ordering user"}),"\n",(0,i.jsx)(n.li,{children:"Order Amount: Total order amount"}),"\n",(0,i.jsx)(n.li,{children:"Order Status: Current order status"}),"\n",(0,i.jsx)(n.li,{children:"Create Time: Order creation time"}),"\n",(0,i.jsx)(n.li,{children:"Update Time: Order update time"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Business Characteristics"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Large and rapidly growing order data volume"}),"\n",(0,i.jsx)(n.li,{children:"Queries primarily based on order ID and user ID"}),"\n",(0,i.jsx)(n.li,{children:"Historical order queries are less frequent but require long-term storage"}),"\n",(0,i.jsx)(n.li,{children:"System needs to support rapid capacity expansion"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"sharding-strategy-design",children:"Sharding Strategy Design"}),"\n",(0,i.jsx)(n.p,{children:"Based on business characteristics, we adopt the following sharding strategy:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Database Sharding"}),": ",(0,i.jsx)(n.strong,{children:"Shard by user ID modulo"})," to distribute different users' orders across database instances"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Table Sharding"}),": ",(0,i.jsx)(n.strong,{children:"Shard by order creation time monthly"})," for efficient historical data archiving and query optimization"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Sharding Structure"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Databases: ",(0,i.jsx)(n.code,{children:"db_0, db_1"})," (by user ID modulo)"]}),"\n",(0,i.jsxs)(n.li,{children:["Tables: ",(0,i.jsx)(n.code,{children:"order_202501, order_202502, ..."})," (named by month)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"technical-implementation",children:"Technical Implementation"}),"\n",(0,i.jsx)(n.h4,{id:"1-database-preparation",children:"1. Database Preparation"}),"\n",(0,i.jsx)(n.p,{children:"First, create the sharded databases and corresponding table structures:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Create databases\nCREATE DATABASE IF NOT EXISTS `db_0`;\nCREATE DATABASE IF NOT EXISTS `db_1`;\n\n-- Create monthly sharded tables in each database (example for January and February 2025)\nUSE `db_0`;\nCREATE TABLE `order_202501` (\n  `order_id` varchar(32) NOT NULL COMMENT 'Order ID',\n  `user_id` int(11) NOT NULL COMMENT 'User ID',\n  `amount` decimal(10,2) NOT NULL COMMENT 'Order Amount',\n  `status` tinyint(4) NOT NULL COMMENT 'Order Status',\n  `create_time` datetime NOT NULL COMMENT 'Create Time',\n  `update_time` datetime NOT NULL COMMENT 'Update Time',\n  PRIMARY KEY (`order_id`),\n  KEY `idx_user_id` (`user_id`),\n  KEY `idx_create_time` (`create_time`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='January 2025 Order Table';\n\nCREATE TABLE `order_202502` (\n  `order_id` varchar(32) NOT NULL COMMENT 'Order ID',\n  `user_id` int(11) NOT NULL COMMENT 'User ID',\n  `amount` decimal(10,2) NOT NULL COMMENT 'Order Amount',\n  `status` tinyint(4) NOT NULL COMMENT 'Order Status',\n  `create_time` datetime NOT NULL COMMENT 'Create Time',\n  `update_time` datetime NOT NULL COMMENT 'Update Time',\n  PRIMARY KEY (`order_id`),\n  KEY `idx_user_id` (`user_id`),\n  KEY `idx_create_time` (`create_time`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='February 2025 Order Table';\n\n-- Create same table structure in db_1\nUSE `db_1`;\nCREATE TABLE `order_202501` (\n  -- Same structure as db_0\n);\n\nCREATE TABLE `order_202502` (\n  -- Same structure as db_0\n);\n"})}),"\n",(0,i.jsx)(n.h4,{id:"2-database-configuration",children:"2. Database Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["Configure multiple database connections in ",(0,i.jsx)(n.code,{children:"config.yaml"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'database:\n  default:\n    link: "mysql:root:password@tcp(127.0.0.1:3306)/default"\n    debug: true\n  db_0:\n    link: "mysql:root:password@tcp(127.0.0.1:3306)/db_0"\n    debug: true\n  db_1:\n    link: "mysql:root:password@tcp(127.0.0.1:3306)/db_1"\n    debug: true\n'})}),"\n",(0,i.jsx)(n.h4,{id:"3-custom-sharding-rules",children:"3. Custom Sharding Rules"}),"\n",(0,i.jsxs)(n.p,{children:["Implement custom sharding rules supporting ",(0,i.jsx)(n.strong,{children:"database sharding by user ID"})," and ",(0,i.jsx)(n.strong,{children:"table sharding by time"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// ShardingValue represents sharding parameters\ntype ShardingValue struct {\n    UserId     int64       \n    CreateTime time.Time\n}\n\n// OrderShardingRule defines order sharding rules\ntype OrderShardingRule struct {\n    SchemaCount int64 // Number of database shards\n}\n\n// Implement SchemaName method of ShardingRule interface\nfunc (r *OrderShardingRule) SchemaName(\n    ctx context.Context, config gdb.ShardingSchemaConfig, value any,\n) (string, error) {\n    if r.SchemaCount <= 0 {\n        return "", gerror.New("schema count should be greater than 0")\n    }\n    // Get user ID\n    sv, ok := value.(ShardingValue)\n    if !ok {\n        return "", gerror.New("invalid sharding value")\n    }\n    userId := sv.UserId\n    if userId <= 0 {\n        return "", gerror.New("invalid user_id for sharding")\n    }\n    // Determine database by user ID modulo\n    schemaIndex := userId % int64(r.SchemaCount)\n    return fmt.Sprintf("%s%d", config.Prefix, schemaIndex), nil\n}\n\n// Implement TableName method of ShardingRule interface\nfunc (r *OrderShardingRule) TableName(\n    ctx context.Context, config gdb.ShardingTableConfig, value any,\n) (string, error) {\n    // Get order creation time\n    sv, ok := value.(ShardingValue)\n    if !ok {\n        return "", gerror.New("invalid sharding value")\n    }\n    createTime := sv.CreateTime\n    if createTime.IsZero() {\n        return "", gerror.New("invalid create_time for sharding")\n    }\n    // Determine table by month\n    tableName := fmt.Sprintf(\n        "%s%d%02d", config.Prefix, createTime.Year(), createTime.Month(),\n    )\n    return tableName, nil\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"4-order-model-definition",children:"4. Order Model Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Order model structure\ntype Order struct {\n    OrderId    string    `json:"order_id"    description:"Order ID"`\n    UserId     int64     `json:"user_id"     description:"User ID"`\n    Amount     float64   `json:"amount"      description:"Order Amount"`\n    Status     int       `json:"status"      description:"Order Status"`\n    CreateTime time.Time `json:"create_time" description:"Create Time"`\n    UpdateTime time.Time `json:"update_time" description:"Update Time"`\n}\n\n// OrderService handles order business logic\ntype OrderService struct{}\n\n// CreateOrder creates a new order\nfunc (s *OrderService) CreateOrder(ctx context.Context, userId int64, amount float64) (string, error) {\n    // Generate order ID (can\'t use auto-increment with sharding)\n    orderId := grand.S()\n    \n    // Create order object\n    order := &Order{\n        OrderId:    orderId,\n        UserId:     userId,\n        Amount:     amount,\n        Status:     1,\n        CreateTime: time.Now(),\n        UpdateTime: time.Now(),\n    }\n    \n    // Get sharding value\n    sv := ShardingValue{\n        UserId:     userId,\n        CreateTime: order.CreateTime,\n    }\n    \n    // Insert order with sharding\n    _, err := g.DB().Model("order").Data(order).HookSharding(sv).Insert()\n    if err != nil {\n        return "", err\n    }\n    \n    return orderId, nil\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-and-considerations",children:"Best Practices and Considerations"}),"\n",(0,i.jsx)(n.p,{children:"Based on the above analysis and practical experience, here are the best practices for database sharding:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Early Planning"}),": Consider sharding strategy during initial system design to avoid high costs of later modifications."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Careful Shard Key Selection"}),": Choose shard keys that are frequently queried, evenly distributed, and unlikely to change."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Global Unique IDs"}),": Use solutions like the Snowflake algorithm to generate globally unique IDs instead of auto-increment primary keys."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Migration Strategy"}),": Plan for smooth data migration and implement proper monitoring and rollback mechanisms."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance Monitoring"}),": Implement comprehensive monitoring for sharded databases to identify and address performance issues early."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistent Hash"}),": Consider using consistent hashing for more flexible scaling when adding or removing database nodes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Transaction Handling"}),": Be cautious with cross-shard transactions and implement proper compensation mechanisms when needed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testing"}),": Thoroughly test sharding logic, especially edge cases and failure scenarios."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"Database sharding is a powerful solution for handling large-scale data in modern applications. Through this e-commerce system case study, we've demonstrated how to implement database sharding effectively using Go and the GoFrame framework. While sharding adds complexity to the system, proper planning and implementation can significantly improve system scalability and performance."}),"\n",(0,i.jsx)(n.p,{children:"Remember that sharding is not always the best solution for every scenario. Evaluate your specific business needs, data growth patterns, and maintenance capabilities before implementing a sharding strategy. Start with a simple and maintainable solution, then evolve it as your system grows."})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},250065:function(e,n,a){a.d(n,{Z:function(){return d},a:function(){return t}});var r=a(667294);let i={},s=r.createContext(i);function t(e){let n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);